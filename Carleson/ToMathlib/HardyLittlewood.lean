import Carleson.ToMathlib.DoublingMeasure
import Carleson.ToMathlib.RealInterpolation.Main
import Mathlib.MeasureTheory.Covering.Vitali
import Carleson.Defs

open MeasureTheory Metric Bornology Set TopologicalSpace Vitali Filter ENNReal Pointwise
open scoped NNReal
noncomputable section

/-! This should roughly contain the contents of chapter 9. -/

section Prelude

variable {X : Type*} [PseudoMetricSpace X] [SeparableSpace X]

variable (X) in
/-- Lemma 9.0.2 -/
-- maybe not suited for Mathlib in this form
lemma covering_separable_space :
    ‚àÉ C : Set X, C.Countable ‚àß ‚àÄ r > 0, ‚ãÉ c ‚àà C, ball c r = univ := by
  simp_rw [‚Üê Metric.dense_iff_iUnion_ball, exists_countable_dense]

-- maybe not suited for Mathlib in this form
lemma countable_globalMaximalFunction :
    (covering_separable_space X).choose √óÀ¢ (univ : Set ‚Ñ§) |>.Countable :=
  (covering_separable_space X).choose_spec.1.prod countable_univ

-- probably not suited for Mathlib in this form
lemma exists_ball_subset_ball_two (c : X) {r : ‚Ñù} (hr : 0 < r) :
    ‚àÉ c' ‚àà (covering_separable_space X).choose,
      ‚àÉ m : ‚Ñ§, ball c r ‚äÜ ball c' (2 ^ m) ‚àß 2 ^ m ‚â§ 2 * r ‚àß ball c' (2 ^ m) ‚äÜ ball c (4 * r) := by
  obtain ‚ü®_, hCr‚ü© := (covering_separable_space X).choose_spec
  let m := ‚åäReal.logb 2 r‚åã
  have hm : 2 ^ m ‚â§ r := by
    calc _ ‚â§ (2 : ‚Ñù) ^ (Real.logb 2 r) := by
          convert Real.monotone_rpow_of_base_ge_one one_le_two (Int.floor_le _)
          exact (Real.rpow_intCast 2 m).symm
      _ = _ := Real.rpow_logb zero_lt_two (OfNat.one_ne_ofNat 2).symm hr
  have hm' : r < 2 ^ (m + 1) := by
    calc _ = (2 : ‚Ñù) ^ Real.logb 2 r := (Real.rpow_logb zero_lt_two (OfNat.one_ne_ofNat 2).symm hr).symm
      _ < _ := by
        rw [‚Üê Real.rpow_intCast 2 (m + 1)]
        refine Real.strictMono_rpow_of_base_gt_one one_lt_two ?_
        simp [m]
  let a := ((2 : ‚Ñù) ^ (m + 1) - r) / 2
  have h_univ := hCr a (by simp [a, hm'])
  obtain ‚ü®c', hc', hcc'‚ü© := mem_iUnion‚ÇÇ.mp <| h_univ ‚ñ∏ Set.mem_univ c
  refine ‚ü®c', hc', m + 1, ball_subset_ball_of_le ?_, ?_, ?_‚ü©
  ¬∑ calc
      _ ‚â§ a + r := by gcongr; exact (dist_comm c c' ‚ñ∏ mem_ball.mp hcc').le
      _ ‚â§ _ := by simp only [a, sub_div]; linarith
  ¬∑ rw [‚Üê Real.rpow_intCast 2 (m + 1)]
    push_cast
    rw [Real.rpow_add_one two_ne_zero m, mul_comm]
    gcongr
    exact_mod_cast hm
  ¬∑ refine ball_subset_ball_of_le ?_
    calc
      _ ‚â§ a + 2 ^ (m + 1) := by gcongr; exact (mem_ball.mp hcc').le
      _ ‚â§ 2 ^ (m + 1) + 2 ^ (m + 1) := by
        gcongr
        simp only [a]
        linarith
      _ ‚â§ 2 * r + 2 * r := by
        rw [‚Üê Real.rpow_intCast 2 (m + 1)]
        push_cast
        rw [Real.rpow_add_one two_ne_zero m, mul_comm]
        gcongr <;> simp [hm]
      _ = 4 * r := by ring

end Prelude

variable {X E : Type*} {A : ‚Ñù‚â•0} [MetricSpace X] [MeasurableSpace X]
  {Œº : Measure X} [Œº.IsDoubling A] [NormedAddCommGroup E]
  {f : X ‚Üí E} {x : X} {Œπ : Type*} {ùìë : Set Œπ} {c : Œπ ‚Üí X} {r : Œπ ‚Üí ‚Ñù}
  -- feel free to assume `A ‚â• 16` or similar

-- unused in Carleson
-- move to separate file (not sure where)
lemma lowerSemiContinuousOn_integral_ball [OpensMeasurableSpace X] (hf2 : AEStronglyMeasurable f Œº) :
    LowerSemicontinuousOn (fun x : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª y in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº) (univ √óÀ¢ Ioi 0) := by
  refine lowerSemicontinuousOn_iff_le_liminf.mpr fun x hx ‚Ü¶ _root_.le_of_forall_pos_le_add ?_
  intro Œ¥ hŒ¥
  let M := liminf (fun x ‚Ü¶ ‚à´‚Åª (y : X) in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº)
      (nhdsWithin x (univ √óÀ¢ Ioi 0)) + Œ¥
  by_cases htop : liminf (fun x ‚Ü¶ ‚à´‚Åª (y : X) in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº)
      (nhdsWithin x (univ √óÀ¢ Ioi 0)) = ‚àû; ¬∑ rw [htop]; simp
  have hM : liminf (fun x ‚Ü¶ ‚à´‚Åª (y : X) in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº)
      (nhdsWithin x (univ √óÀ¢ Ioi 0)) < M := lt_add_right htop hŒ¥.ne'
  have : ‚àÉ·∂† (z : X √ó ‚Ñù) in nhdsWithin x (univ √óÀ¢ Ioi 0),
      ‚à´‚Åª (y : X) in ball z.1 z.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº < M := by
    refine frequently_lt_of_liminf_lt ?_ hM
    simp only [IsCoboundedUnder, Filter.IsCobounded, ge_iff_le, eventually_map]
    use ‚à´‚Åª (y : X) in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº
    intro a ha; apply Eventually.self_of_nhdsWithin ha hx
  obtain ‚ü®ns, hns‚ÇÄ, hns‚ÇÅ‚ü© :=
    exists_seq_forall_of_frequently (l := nhdsWithin x (univ √óÀ¢ Ioi 0))
        (p := fun z ‚Ü¶ ‚à´‚Åª (y : X) in ball z.1 z.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº < M) this
  let g (n : ‚Ñï) := (ball (ns n).1 (ns n).2).indicator (fun y ‚Ü¶ ‚Äñf y‚Äñ‚Çë)
  have (z : X) : (ball x.1 x.2).indicator (fun y ‚Ü¶ ‚Äñf y‚Äñ‚Çë) z ‚â§
      liminf (fun n ‚Ü¶ g n z) atTop := by
    apply le_liminf_of_le (f := atTop)
    unfold g indicator
    split_ifs with hz
    ¬∑ have hz2 : ‚àÄ·∂† n : ‚Ñï in atTop, z ‚àà ball (ns n).1 (ns n).2 := by
        let dist_sub (y : X √ó ‚Ñù) := dist z y.1 - y.2
        have : ContinuousOn dist_sub (univ √óÀ¢ Ioi 0) := by fun_prop
        have : Tendsto (dist_sub ‚àò ns) atTop (nhds (dist_sub x)) := Tendsto.comp (this x hx) hns‚ÇÄ
        have : ‚àÄ·∂† (n : ‚Ñï) in atTop, dist z (ns n).1 - (ns n).2 < 0 := by
          rw [mem_ball, ‚Üê sub_lt_zero] at hz; exact Tendsto.eventually_lt_const hz this
        filter_upwards [this]; simp
      filter_upwards [hz2]; intro a ha; split_ifs; rfl
    ¬∑ simp
  calc
  ‚à´‚Åª (y : X) in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº
    ‚â§ ‚à´‚Åª y, (ball x.1 x.2).indicator (fun z ‚Ü¶ ‚Äñf z‚Äñ‚Çë) y ‚àÇŒº := by
    rw [lintegral_indicator]; exact measurableSet_ball
  _ ‚â§ ‚à´‚Åª y, liminf (fun n ‚Ü¶ g n y) atTop ‚àÇŒº := by gcongr with y; exact this y
  _ ‚â§ liminf (fun n ‚Ü¶ ‚à´‚Åª y, g n y ‚àÇŒº) atTop := by
    exact lintegral_liminf_le' fun n ‚Ü¶ AEMeasurable.indicator (AEStronglyMeasurable.enorm
        hf2) measurableSet_ball
  _ ‚â§ M := by
    apply liminf_le_of_le (f := atTop)
    intro b hb
    simp only [eventually_atTop, ge_iff_le] at hb
    obtain ‚ü®a, ha‚ü© := hb
    exact le_of_lt <| lt_of_le_of_lt (ha a le_rfl) <|
        by unfold g; rw [lintegral_indicator measurableSet_ball]; exact hns‚ÇÅ a

/-- The Hardy-Littlewood maximal function w.r.t. a collection of balls ùìë.
M_{ùìë, p} in the blueprint. -/
def maximalFunction (Œº : Measure X) (ùìë : Set Œπ) (c : Œπ ‚Üí X) (r : Œπ ‚Üí ‚Ñù)
    (p : ‚Ñù) (u : X ‚Üí E) (x : X) : ‚Ñù‚â•0‚àû :=
  (‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator (x := x)
    fun _ ‚Ü¶ ‚®ç‚Åª y in ball (c i) (r i), ‚Äñu y‚Äñ‚Çë ^ p ‚àÇŒº) ^ p‚Åª¬π

/-- The Hardy-Littlewood maximal function w.r.t. a collection of balls ùìë with exponent 1.
M_ùìë in the blueprint. -/
abbrev MB (Œº : Measure X) (ùìë : Set Œπ) (c : Œπ ‚Üí X) (r : Œπ ‚Üí ‚Ñù) (u : X ‚Üí E) (x : X) : ‚Ñù‚â•0‚àû :=
  maximalFunction Œº ùìë c r 1 u x

lemma MB_def : MB Œº ùìë c r f x = (‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator (x := x)
    fun _ ‚Ü¶ ‚®ç‚Åª y in ball (c i) (r i), ‚Äñf y‚Äñ‚Çë ‚àÇŒº) := by
  unfold MB maximalFunction; simp_rw [inv_one, rpow_one]

lemma maximalFunction_eq_MB
    {Œº : Measure X} {ùìë : Set Œπ} {c : Œπ ‚Üí X} {r : Œπ ‚Üí ‚Ñù} {p : ‚Ñù} {u : X ‚Üí E} {x : X} (hp : 0 ‚â§ p) :
    maximalFunction Œº ùìë c r p u x = (MB Œº ùìë c r (‚Äñu ¬∑‚Äñ ^ p) x) ^ p‚Åª¬π := by
  rw [maximalFunction, MB_def]
  congr! 8
  rw [enorm_eq_nnnorm, enorm_eq_nnnorm, ‚Üê ENNReal.coe_rpow_of_nonneg _ hp, ENNReal.coe_inj,
    Real.nnnorm_rpow_of_nonneg (by simp), nnnorm_norm]

-- We will replace the criterion `P` used in `MeasureTheory.AESublinearOn.maximalFunction` with the
-- weaker criterion `LocallyIntegrable` that is closed under addition and scalar multiplication.

-- The average that appears in the definition of `MB`
variable (Œº c r) in
private def T (i : Œπ) (u : X ‚Üí E) := ‚®ç‚Åª (y : X) in ball (c i) (r i), ‚Äñu y‚Äñ‚Çë ‚àÇŒº

-- move
lemma MeasureTheory.LocallyIntegrable.integrableOn_of_isBounded [ProperSpace X]
    {f : X ‚Üí E} (hf : LocallyIntegrable f Œº) {s : Set X}
    (hs : IsBounded s) : IntegrableOn f s Œº :=
  hf.integrableOn_isCompact hs.isCompact_closure |>.mono_set subset_closure

-- move
lemma MeasureTheory.LocallyIntegrable.integrableOn_ball [ProperSpace X]
    {f : X ‚Üí E} (hf : LocallyIntegrable f Œº) {x : X} {r : ‚Ñù} : IntegrableOn f (ball x r) Œº :=
  hf.integrableOn_of_isBounded isBounded_ball

lemma continuous_integral_ball [OpensMeasurableSpace X]
    (g : X ‚Üí ‚Ñù‚â•0‚àû) (hg : ‚àÄ x : X, ‚àÄ r > (0 : ‚Ñù), ‚à´‚Åª (y : X) in ball x r, g y ‚àÇŒº < ‚ä§)
    (hg2 : AEMeasurable g Œº) (hŒº : ‚àÄ z : X, ‚àÄ r > (0 : ‚Ñù), Œº (sphere z r) = 0 ):
    ContinuousOn (fun x : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª y in ball x.1 x.2, g y ‚àÇŒº) (univ √óÀ¢ Ioi 0) := by
  unfold ContinuousOn ContinuousWithinAt
  intro x hx
  have hx_pos : x.2 > 0 := by simp only [mem_prod, mem_univ, mem_Ioi, true_and] at hx; exact hx
  dsimp only
  have : (fun x : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª (y : X) in ball x.1 x.2, g y ‚àÇŒº) =
      fun x : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª (y : X), (ball x.1 x.2).indicator g y ‚àÇŒº := by
    ext x
    rw [‚Üê lintegral_indicator measurableSet_ball]
  rw [this, ‚Üê lintegral_indicator measurableSet_ball]
  apply tendsto_of_seq_tendsto
  intro z hz
  have hz' : Tendsto z atTop (nhds x) := tendsto_nhds_of_tendsto_nhdsWithin hz
  have := isBounded_range_of_tendsto z hz'
  obtain ‚ü®r, hr‚ü© := Bornology.IsBounded.subset_ball this x
  simp only [range, ball, setOf_subset_setOf, forall_exists_index,
        forall_apply_eq_imp_iff] at hr
  simp_rw [Prod.dist_eq] at hr
  have hsub (n : ‚Ñï) : ball (z n).1 (z n).2 ‚äÜ ball x.1 (x.2 + 2 * r) := by
    unfold ball
    intro y hy
    simp only [mem_setOf_eq] at hy ‚ä¢
    calc
    dist y x.1
      ‚â§ dist y (z n).1 + dist (z n).1 x.1 := dist_triangle y (z n).1 x.1
    _ ‚â§ (z n).2 + dist (z n).1 x.1 := by gcongr
    _ ‚â§ |(z n).2| + dist (z n).1 x.1 := by gcongr; exact le_abs_self (z n).2
    _ = |(z n).2 - x.2 + x.2| + dist (z n).1 x.1 := by rw [@sub_add_cancel]
    _ ‚â§ |(z n).2 - x.2| + |x.2| + dist (z n).1 x.1 := by
      gcongr; exact abs_add_le _ _
    _ < r + |x.2| + r := by
      gcongr
      ¬∑ calc
        _ = dist (z n).2 x.2 := by rw [‚Üê Real.dist_eq]
        _ ‚â§ _ := le_max_right (dist (z n).1 x.1) (dist (z n).2 x.2)
        _ < r := hr _
      ¬∑ calc
        _ ‚â§ _ := le_max_left (dist (z n).1 x.1) (dist (z n).2 x.2)
        _ < r := hr _
    _ = r + x.2 + r := by
      congr
      simp only [mem_prod, mem_univ, mem_Ioi, true_and] at hx; rw [abs_of_nonneg hx.le]
    _ = x.2 + 2 * r := by linarith
  let bound := (ball x.1 (x.2 + 2 * r)).indicator g
  apply tendsto_lintegral_of_dominated_convergence' bound
  ¬∑ exact fun _ ‚Ü¶ AEMeasurable.indicator hg2 measurableSet_ball
  ¬∑ intro n
    filter_upwards with a
    unfold bound indicator
    split_ifs with h‚ÇÄ h‚ÇÅ
    ¬∑ simp
    ¬∑ contrapose! h‚ÇÅ; exact hsub n h‚ÇÄ
    ¬∑ simp
    ¬∑ simp
  ¬∑ unfold bound
    rw [lintegral_indicator measurableSet_ball]
    apply ne_of_lt
    apply hg
    have : 0 < r := by
      calc
      0 ‚â§ dist (z 0).1 x.1 := dist_nonneg
      _ ‚â§ max (dist (z 0).1 x.1) (dist (z 0).2 x.2) := le_max_left _ _
      _ < r := by exact hr _
    linarith
  ¬∑ have : ‚àÄ·µê z : X ‚àÇŒº, dist z x.1 ‚â† x.2 := by
      change (Œº ({z | ¬¨ (dist z x.1 ‚â† x.2)}) = 0)
      simp only [ne_eq, Decidable.not_not]
      exact hŒº x.1 x.2 hx_pos
    filter_upwards [this]
    intro y hy
    by_cases hy2 : dist y x.1 < x.2
    ¬∑ simp only [indicator, ball, mem_setOf_eq]
      split_ifs
      apply tendsto_nhds_of_eventually_eq
      have hz2 : ‚àÄ·∂† n : ‚Ñï in atTop, dist y (z n).1 < (z n).2 := by
        let dist_sub (a : X √ó ‚Ñù) := dist y a.1 - a.2
        have : ContinuousOn dist_sub (univ √óÀ¢ Ioi 0) := by fun_prop
        have : Tendsto (dist_sub ‚àò z) atTop (nhds (dist_sub x)) := Tendsto.comp (this x hx) hz
        have : ‚àÄ·∂† (n : ‚Ñï) in atTop, dist y (z n).1 - (z n).2 < 0 := by
          rw [‚Üê sub_lt_zero] at hy2; exact Tendsto.eventually_lt_const hy2 this
        filter_upwards [this]; simp
      filter_upwards [hz2]; intro a ha; split_ifs; rfl
    ¬∑ have hz2 : ‚àÄ·∂† n : ‚Ñï in atTop, dist y (z n).1 > (z n).2 := by
        let dist_sub (a : X √ó ‚Ñù) := dist y a.1 - a.2
        have : ContinuousOn dist_sub (univ √óÀ¢ Ioi 0) := by fun_prop
        have hcmp : Tendsto (dist_sub ‚àò z) atTop (nhds (dist_sub x)) := Tendsto.comp (this x hx) hz
        have hy2 : dist y x.1 > x.2 := by order
        have hy2 : 0 < dist y x.1 - x.2 := sub_pos.mpr hy2
        have : ‚àÄ·∂† (n : ‚Ñï) in atTop, 0 < dist y (z n).1 - (z n).2 := by
          exact Tendsto.eventually_const_lt hy2 hcmp
        filter_upwards [this]; simp
      simp only [indicator, ball, mem_setOf_eq]
      apply tendsto_nhds_of_eventually_eq
      filter_upwards [hz2] with n hn
      have : ¬¨ (dist y (z n).1 < (z n).2) := by linarith
      split_ifs; rfl

-- unused in Carleson
-- move to separate file (not sure where)
lemma continuous_average_ball [Œº.IsOpenPosMeasure] [IsFiniteMeasureOnCompacts Œº] [OpensMeasurableSpace X]
    [ProperSpace X] (hf : LocallyIntegrable f Œº)
    (hŒº : ‚àÄ z : X, ‚àÄ r > (0 : ‚Ñù), Œº (sphere z r) = 0) :
    ContinuousOn (fun x : X √ó ‚Ñù ‚Ü¶ ‚®ç‚Åª y in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº) (univ √óÀ¢ Ioi 0) := by
  have hopen : IsOpen ((univ : Set X) √óÀ¢ Ioi (0 : ‚Ñù)) := IsOpen.prod isOpen_univ isOpen_Ioi
  rw [IsOpen.continuousOn_iff hopen]
  intro x hx
  have hx_pos : 0 < x.2 := by simp only [mem_prod, mem_univ, mem_Ioi, true_and] at hx; exact hx
  have : (fun x : X √ó ‚Ñù ‚Ü¶ ‚®ç‚Åª y in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº) =
    fun x : X √ó ‚Ñù ‚Ü¶ (Œº (ball x.1 x.2))‚Åª¬π * ‚à´‚Åª y in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº
     := by ext x; simp [Pi.div_apply, laverage]
  rw [this]
  apply ENNReal.Tendsto.mul
  ¬∑ apply Tendsto.inv
    have : (fun z : X √ó ‚Ñù ‚Ü¶ Œº (ball z.1 z.2)) =
        (fun z : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª (y : X) in ball z.1 z.2, (1 : ‚Ñù‚â•0‚àû) ‚àÇŒº) := by simp
    rw [this, Eq.symm (setLIntegral_one (ball x.1 x.2))]
    have : ContinuousOn (fun x : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª y in ball x.1 x.2, (1 : ‚Ñù‚â•0‚àû) ‚àÇŒº) (univ √óÀ¢ Ioi 0) := by
      apply continuous_integral_ball _ _ aemeasurable_const hŒº
      intro p r hr; rw [@setLIntegral_one]; exact measure_ball_lt_top
    rw [IsOpen.continuousOn_iff hopen] at this
    apply this hx
  ¬∑ exact Or.inr (LT.lt.ne (LocallyIntegrable.integrableOn_ball hf).right)
  ¬∑ have : ContinuousOn (fun x : X √ó ‚Ñù ‚Ü¶ ‚à´‚Åª y in ball x.1 x.2, ‚Äñf y‚Äñ‚Çë ‚àÇŒº) (univ √óÀ¢ Ioi 0) := by
      apply continuous_integral_ball _ _ _ hŒº
      ¬∑ intro x r hr; exact (LocallyIntegrable.integrableOn_ball hf).right
      ¬∑ exact AEStronglyMeasurable.enorm (LocallyIntegrable.aestronglyMeasurable hf)
    rw [IsOpen.continuousOn_iff hopen] at this; exact this hx
  ¬∑ exact Or.inr (inv_ne_top.mpr (ne_of_gt (measure_ball_pos Œº x.1 hx_pos)))

-- probably unsuitable for Mathlib
lemma MeasureTheory.LocallyIntegrable.laverage_ball_lt_top [ProperSpace X]
    {f : X ‚Üí E} (hf : LocallyIntegrable f Œº)
    {x‚ÇÄ : X} {r : ‚Ñù} :
    ‚®ç‚Åª x in ball x‚ÇÄ r, ‚Äñf x‚Äñ‚Çë ‚àÇŒº < ‚ä§ :=
  laverage_lt_top hf.integrableOn_ball.2.ne

private lemma T.add_le [MeasurableSpace E] [BorelSpace E] [BorelSpace X] [ProperSpace X]
    (i : Œπ) {f g : X ‚Üí E} (hf : LocallyIntegrable f Œº) :
    ‚ÄñT Œº c r i (f + g)‚Äñ‚Çë ‚â§ ‚ÄñT Œº c r i f‚Äñ‚Çë + ‚ÄñT Œº c r i g‚Äñ‚Çë := by
  simp only [T, Pi.add_apply, enorm_eq_self, ‚Üê enorm_eq_nnnorm]
  rw [‚Üê laverage_add_left hf.integrableOn_ball.aemeasurable.enorm]
  exact laverage_mono (fun x ‚Ü¶ enorm_add_le (f x) (g x))

-- move to `ENNReal.Basic` or similar
lemma NNReal.smul_ennreal_eq_mul (x : ‚Ñù‚â•0) (y : ‚Ñù‚â•0‚àû) : x ‚Ä¢ y = x * y := rfl

private lemma T.smul [NormedSpace ‚Ñù E] (i : Œπ) {f : X ‚Üí E} {d : ‚Ñù‚â•0} :
    T Œº c r i (d ‚Ä¢ f) = d ‚Ä¢ T Œº c r i f := by
  simp_rw [T, Pi.smul_apply, NNReal.smul_def, NNReal.smul_ennreal_eq_mul,
    laverage_const_mul ENNReal.coe_ne_top]
  simp [_root_.enorm_smul]

-- move near `exists_disjoint_subfamily_covering_enlargement_closedBall`
-- slightly more general than the Mathlib version
-- the extra conclusion says that if there is a nonnegative radius, then we can choose `r b` to be
-- larger than `r a` (up to a constant)
theorem exists_disjoint_subfamily_covering_enlargement_closedBall' {Œ±} [MetricSpace Œ±] (t : Set Œπ)
    (x : Œπ ‚Üí Œ±) (r : Œπ ‚Üí ‚Ñù) (R : ‚Ñù) (hr : ‚àÄ a ‚àà t, r a ‚â§ R) (œÑ : ‚Ñù) (hœÑ : 3 < œÑ) :
    ‚àÉ u ‚äÜ t,
      (u.PairwiseDisjoint fun a => closedBall (x a) (r a)) ‚àß
        ‚àÄ a ‚àà t, ‚àÉ b ‚àà u, closedBall (x a) (r a) ‚äÜ closedBall (x b) (œÑ * r b) ‚àß
        (‚àÄ u ‚àà t, 0 ‚â§ r u ‚Üí r a ‚â§ (œÑ - 1) / 2 * r b) := by
  rcases eq_empty_or_nonempty t with (rfl | _)
  ¬∑ exact ‚ü®‚àÖ, Subset.refl _, pairwiseDisjoint_empty, by simp‚ü©
  by_cases ht : ‚àÄ a ‚àà t, r a < 0
  ¬∑ refine ‚ü®t, .rfl, fun a ha b _ _ ‚Ü¶ by
      simp only [Function.onFun, closedBall_eq_empty.2 (ht a ha), empty_disjoint],
      fun a ha => ‚ü®a, ha, by simp only [closedBall_eq_empty.2 (ht a ha), empty_subset],
      fun u hut hu ‚Ü¶ (ht u hut).not_le hu |>.elim‚ü©‚ü©
  push_neg at ht
  let t' := { a ‚àà t | 0 ‚â§ r a }
  have h2œÑ : 1 < (œÑ - 1) / 2 := by linarith
  rcases exists_disjoint_subfamily_covering_enlargement (fun a => closedBall (x a) (r a)) t' r
      ((œÑ - 1) / 2) h2œÑ (fun a ha => ha.2) R (fun a ha => hr a ha.1) fun a ha =>
      ‚ü®x a, mem_closedBall_self ha.2‚ü© with
    ‚ü®u, ut', u_disj, hu‚ü©
  have A : ‚àÄ a ‚àà t', ‚àÉ b ‚àà u, closedBall (x a) (r a) ‚äÜ closedBall (x b) (œÑ * r b) ‚àß
    ‚àÄ u ‚àà t, 0 ‚â§ r u ‚Üí r a ‚â§ (œÑ - 1) / 2 * r b := by
    intro a ha
    rcases hu a ha with ‚ü®b, bu, hb, rb‚ü©
    refine ‚ü®b, bu, ?_‚ü©
    have : dist (x a) (x b) ‚â§ r a + r b := dist_le_add_of_nonempty_closedBall_inter_closedBall hb
    exact ‚ü®closedBall_subset_closedBall' <| by linarith, fun _ _ _ ‚Ü¶ rb‚ü©
  refine ‚ü®u, ut'.trans fun a ha => ha.1, u_disj, fun a ha => ?_‚ü©
  rcases le_or_lt 0 (r a) with (h'a | h'a)
  ¬∑ exact A a ‚ü®ha, h'a‚ü©
  ¬∑ rcases ht with ‚ü®b, rb‚ü©
    rcases A b ‚ü®rb.1, rb.2‚ü© with ‚ü®c, cu, _, hc‚ü©
    refine ‚ü®c, cu, by simp only [closedBall_eq_empty.2 h'a, empty_subset], fun _ _ _ ‚Ü¶ ?_‚ü©
    have : 0 ‚â§ r c := nonneg_of_mul_nonneg_right (rb.2.trans <| hc b rb.1 rb.2) (by positivity)
    exact h'a.le.trans <| by positivity

-- move to Vitali
theorem Vitali.exists_disjoint_subfamily_covering_enlargement_ball {Œ±} [MetricSpace Œ±] (t : Set Œπ)
    (x : Œπ ‚Üí Œ±) (r : Œπ ‚Üí ‚Ñù) (R : ‚Ñù) (hr : ‚àÄ a ‚àà t, r a ‚â§ R) (œÑ : ‚Ñù) (hœÑ : 3 < œÑ) :
    ‚àÉ u ‚äÜ t,
      (u.PairwiseDisjoint fun a => ball (x a) (r a)) ‚àß
        ‚àÄ a ‚àà t, ‚àÉ b ‚àà u, ball (x a) (r a) ‚äÜ ball (x b) (œÑ * r b) := by
  obtain ‚ü®œÉ, hœÉ, hœÉœÑ‚ü© := exists_between hœÑ
  obtain ‚ü®u, hut, hux, hu‚ü© :=
    exists_disjoint_subfamily_covering_enlargement_closedBall' t x r R hr œÉ hœÉ
  refine ‚ü®u, hut, fun i hi j hj hij ‚Ü¶ ?_, fun a ha => ?_‚ü©
  ¬∑ exact (hux hi hj hij).mono ball_subset_closedBall ball_subset_closedBall
  obtain ‚ü®b, hbu, hb‚ü© := hu a ha
  refine ‚ü®b, hbu, ?_‚ü©
  obtain h2a|h2a := le_or_lt (r a) 0
  ¬∑ simp_rw [ball_eq_empty.mpr h2a, empty_subset]
  refine ball_subset_closedBall.trans hb.1 |>.trans <| closedBall_subset_ball ?_
  gcongr
  apply pos_of_mul_pos_right <| h2a.trans_le <| hb.2 a ha h2a.le
  linarith

-- move next to Finset.exists_le
lemma Finset.exists_image_le {Œ± Œ≤} [Nonempty Œ≤] [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â§ ¬∑)]
    (s : Finset Œ±) (f : Œ± ‚Üí Œ≤) : ‚àÉ b : Œ≤, ‚àÄ a ‚àà s, f a ‚â§ b := by
  classical
  simpa using s.image f |>.exists_le

-- move
lemma Set.Finite.exists_image_le {Œ± Œ≤} [Nonempty Œ≤] [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â§ ¬∑)]
    {s : Set Œ±} (hs : s.Finite) (f : Œ± ‚Üí Œ≤) : ‚àÉ b : Œ≤, ‚àÄ a ‚àà s, f a ‚â§ b := by
  simpa using hs.toFinset.exists_image_le f

theorem Set.Countable.measure_biUnion_le_lintegral [OpensMeasurableSpace X] (hùìë : ùìë.Countable)
    (l : ‚Ñù‚â•0‚àû) (u : X ‚Üí ‚Ñù‚â•0‚àû) (R : ‚Ñù) (hR : ‚àÄ a ‚àà ùìë, r a ‚â§ R)
    (h2u : ‚àÄ i ‚àà ùìë, l * Œº (ball (c i) (r i)) ‚â§ ‚à´‚Åª x in ball (c i) (r i), u x ‚àÇŒº) :
    l * Œº (‚ãÉ i ‚àà ùìë, ball (c i) (r i)) ‚â§ A ^ 2 * ‚à´‚Åª x, u x ‚àÇŒº  := by
  obtain ‚ü®B, hBùìë, hB, h2B‚ü© := Vitali.exists_disjoint_subfamily_covering_enlargement_ball
    ùìë c r R hR (2 ^ 2) (by norm_num)
  have : Countable B := hùìë.mono hBùìë
  have disj := fun i j hij ‚Ü¶
    hB (Subtype.coe_prop i) (Subtype.coe_prop j) (Subtype.coe_ne_coe.mpr hij)
  calc
    l * Œº (‚ãÉ i ‚àà ùìë, ball (c i) (r i)) ‚â§ l * Œº (‚ãÉ i ‚àà B, ball (c i) (2 ^ 2 * r i)) := by
          refine mul_left_mono (Œº.mono fun x hx ‚Ü¶ ?_)
          simp only [mem_iUnion, mem_ball, exists_prop] at hx
          rcases hx with ‚ü®i, iùìë, hi‚ü©
          obtain ‚ü®b, bB, hb‚ü© := h2B i iùìë
          refine mem_iUnion‚ÇÇ.mpr ‚ü®b, bB, hb <| mem_ball.mpr hi‚ü©
    _ ‚â§ l * ‚àë' i : B, Œº (ball (c i) (2 ^ 2 * r i)) :=
          mul_left_mono <| measure_biUnion_le Œº (hùìë.mono hBùìë) fun i ‚Ü¶ ball (c i) (2 ^ 2 * r i)
    _ ‚â§ l * ‚àë' i : B, A ^ 2 * Œº (ball (c i) (r i)) := by
          refine mul_left_mono <| ENNReal.tsum_le_tsum (fun i ‚Ü¶ ?_)
          rw [sq, sq, mul_assoc, mul_assoc]
          apply (measure_ball_two_le_same (c i) (2 * r i)).trans
          exact mul_left_mono (measure_ball_two_le_same (c i) (r i))
    _ = A ^ 2 * ‚àë' i : B, l * Œº (ball (c i) (r i)) := by
          rw [ENNReal.tsum_mul_left, ENNReal.tsum_mul_left, ‚Üê mul_assoc, ‚Üê mul_assoc, mul_comm l]
    _ ‚â§ A ^ 2 * ‚àë' i : B, ‚à´‚Åª x in ball (c i) (r i), u x ‚àÇŒº := by
          gcongr; exact h2u _ (hBùìë (Subtype.coe_prop _))
    _ = A ^ 2 * ‚à´‚Åª x in ‚ãÉ i ‚àà B, ball (c i) (r i), u x ‚àÇŒº := by
          congr; simpa using (lintegral_iUnion (fun i ‚Ü¶ measurableSet_ball) disj u).symm
    _ ‚â§ A ^ 2 * ‚à´‚Åª x, u x ‚àÇŒº := by
          gcongr; exact setLIntegral_le_lintegral (‚ãÉ i ‚àà B, ball (c i) (r i)) u

protected theorem Finset.measure_biUnion_le_lintegral [OpensMeasurableSpace X] (ùìë : Finset Œπ)
    (l : ‚Ñù‚â•0‚àû) (u : X ‚Üí ‚Ñù‚â•0‚àû)
    (h2u : ‚àÄ i ‚àà ùìë, l * Œº (ball (c i) (r i)) ‚â§ ‚à´‚Åª x in ball (c i) (r i), u x ‚àÇŒº) :
    l * Œº (‚ãÉ i ‚àà ùìë, ball (c i) (r i)) ‚â§ A ^ 2 * ‚à´‚Åª x, u x ‚àÇŒº  :=
  let ‚ü®c, hc‚ü© := ùìë.exists_image_le r
  ùìë.countable_toSet.measure_biUnion_le_lintegral l u c hc h2u

protected theorem MeasureTheory.AEStronglyMeasurable.maximalFunction [BorelSpace X] {p : ‚Ñù}
    {u : X ‚Üí E} (hùìë : ùìë.Countable) : AEStronglyMeasurable (maximalFunction Œº ùìë c r p u) Œº :=
  (AEMeasurable.biSup ùìë hùìë fun _ _ ‚Ü¶ aemeasurable_const.indicator measurableSet_ball).pow
    aemeasurable_const |>.aestronglyMeasurable

theorem MeasureTheory.AEStronglyMeasurable.maximalFunction_toReal [BorelSpace X]
    {p : ‚Ñù} {u : X ‚Üí E} (hùìë : ùìë.Countable) :
    AEStronglyMeasurable (fun x ‚Ü¶ maximalFunction Œº ùìë c r p u x |>.toReal) Œº :=
  AEStronglyMeasurable.maximalFunction hùìë |>.ennreal_toReal

theorem MB_le_eLpNormEssSup {u : X ‚Üí E} {x : X} : MB Œº ùìë c r u x ‚â§ eLpNormEssSup u Œº :=
  calc MB Œº ùìë c r u x ‚â§
    ‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator (x := x)
        fun _x ‚Ü¶ ‚®ç‚Åª _y in ball (c i) (r i), eLpNormEssSup u Œº ‚àÇŒº := by
        simp_rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]
        gcongr
        exact MeasureTheory.enorm_ae_le_eLpNormEssSup u Œº
    _ ‚â§ ‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator (x := x) fun _x ‚Ü¶ eLpNormEssSup u Œº := by
      gcongr; apply setLaverage_const_le
    _ ‚â§ ‚®Ü i ‚àà ùìë, eLpNormEssSup u Œº := by gcongr; apply indicator_le_self
    _ ‚â§ eLpNormEssSup u Œº := by
      simp_rw [iSup_le_iff, le_refl, implies_true]

protected theorem HasStrongType.MB_top [BorelSpace X] (hùìë : ùìë.Countable) :
    HasStrongType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ MB Œº ùìë c r u x) ‚ä§ ‚ä§ Œº Œº 1 := by
  intro f _
  use AEStronglyMeasurable.maximalFunction hùìë
  simp only [ENNReal.coe_one, one_mul, eLpNorm_exponent_top]
  exact essSup_le_of_ae_le _ (Eventually.of_forall fun x ‚Ü¶ MB_le_eLpNormEssSup)

/- The proof is roughly between (9.0.12)-(9.0.22). -/
protected theorem HasWeakType.MB_one [BorelSpace X] (hùìë : ùìë.Countable)
    {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R) :
    HasWeakType (MB (E := E) Œº ùìë c r) 1 1 Œº Œº (A ^ 2) := by
  intro f _
  use AEStronglyMeasurable.maximalFunction hùìë
  let B‚Çó (‚Ñì : ‚Ñù‚â•0‚àû) := { i ‚àà ùìë | ‚à´‚Åª y in (ball (c i) (r i)), ‚Äñf y‚Äñ‚Çë ‚àÇŒº ‚â• ‚Ñì * Œº (ball (c i) (r i)) }
  simp only [wnorm, one_ne_top, wnorm', toReal_one, inv_one, ENNReal.rpow_one, reduceIte,
    ENNReal.coe_pow, eLpNorm, one_ne_zero, eLpNorm', ne_eq, not_false_eq_true, div_self,
    iSup_le_iff]
  intro t
  by_cases ht : t = 0
  ¬∑ simp [ht]
  have hB‚Çó : (B‚Çó t).Countable := hùìë.mono (fun i hi ‚Ü¶ mem_of_mem_inter_left hi)
  refine le_trans ?_ (hB‚Çó.measure_biUnion_le_lintegral (c := c) (r := r) (l := t)
    (u := fun x ‚Ü¶ ‚Äñf x‚Äñ‚Çë) (R := R) ?_ ?_)
  ¬∑ refine mul_left_mono <| Œº.mono (fun x hx ‚Ü¶ mem_iUnion‚ÇÇ.mpr ?_)
    -- We need a ball in `B‚Çó t` containing `x`. Since `MB Œº ùìë c r f x` is large, such a ball exists
    simp only [mem_setOf_eq] at hx
    -- replace hx := lt_of_lt_of_le hx coe_toNNReal_le_self
    simp only [MB, maximalFunction, ENNReal.rpow_one, inv_one] at hx
    obtain ‚ü®i, ht‚ü© := lt_iSup_iff.mp hx
    replace hx : x ‚àà ball (c i) (r i) :=
      by_contradiction <| fun h ‚Ü¶ not_lt_of_ge (zero_le t) (ENNReal.coe_lt_coe.mp <| by simp [h] at ht)
    refine ‚ü®i, ?_, hx‚ü©
    -- It remains only to confirm that the chosen ball is actually in `B‚Çó t`
    simp only [ge_iff_le, mem_setOf_eq, B‚Çó]
    have hi : i ‚àà ùìë :=
      by_contradiction <| fun h ‚Ü¶ not_lt_of_ge (zero_le t) (ENNReal.coe_lt_coe.mp <| by simp [h] at ht)
    exact ‚ü®hi, mul_le_of_le_div <| le_of_lt (by simpa [setLAverage_eq, hi, hx] using ht)‚ü©
  ¬∑ exact fun i hi ‚Ü¶ hR i (mem_of_mem_inter_left hi)
  ¬∑ exact fun i hi ‚Ü¶ hi.2.trans (setLIntegral_mono' measurableSet_ball fun x _ ‚Ü¶ by simp)

include A in
theorem MB_ae_ne_top [BorelSpace X] (hùìë : ùìë.Countable)
    {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R)
    {u : X ‚Üí E} (hu : MemLp u 1 Œº) : ‚àÄ·µê x : X ‚àÇŒº, MB Œº ùìë c r u x ‚â† ‚àû := by
  simpa only [enorm_eq_self] using HasWeakType.MB_one hùìë hR |>.memWLp hu coe_lt_top |>.ae_ne_top

-- move
lemma MeasureTheory.MemLp.eLpNormEssSup_lt_top {Œ±} [MeasurableSpace Œ±] {Œº : Measure Œ±}
    {u : Œ± ‚Üí E} (hu : MemLp u ‚ä§ Œº) : eLpNormEssSup u Œº < ‚ä§ := by
  simp_rw [MemLp, eLpNorm_exponent_top] at hu
  exact hu.2

include A in
theorem MB_ae_ne_top' [BorelSpace X] (hùìë : ùìë.Countable)
    {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R)
    ‚¶Éu : X ‚Üí E‚¶Ñ (hu : MemLp u ‚àû Œº ‚à® MemLp u 1 Œº) : ‚àÄ·µê x : X ‚àÇŒº, MB Œº ùìë c r u x ‚â† ‚àû := by
  obtain hu|hu := hu
  ¬∑ refine .of_forall fun x ‚Ü¶ ?_
    simp_rw [‚Üê lt_top_iff_ne_top, MB, maximalFunction, inv_one, rpow_one]
    calc
      _ ‚â§ ‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator
        (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c i) (r i), eLpNormEssSup u Œº ‚àÇŒº) x := by
          gcongr; exact ENNReal.ae_le_essSup fun y ‚Ü¶ ‚Äñu y‚Äñ‚Çë
      _ ‚â§ ‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator (fun x ‚Ü¶ eLpNormEssSup u Œº) x := by
          gcongr; exact setLaverage_const_le
      _ ‚â§ ‚®Ü i ‚àà ùìë, eLpNormEssSup u Œº := by gcongr; exact indicator_le_self ..
      _ ‚â§ ‚®Ü i : Œπ, eLpNormEssSup u Œº := by gcongr; exact iSup_const_le
      _ ‚â§ eLpNormEssSup u Œº := iSup_const_le
      _ < ‚àû := hu.eLpNormEssSup_lt_top
  ¬∑ exact MB_ae_ne_top hùìë hR hu

include A in
protected theorem MeasureTheory.AESublinearOn.maximalFunction
    [BorelSpace X] [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E]
    [IsFiniteMeasureOnCompacts Œº] [ProperSpace X] (hùìë : ùìë.Countable)
    {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R) :
    AESublinearOn (fun (u : X ‚Üí E) (x : X) ‚Ü¶ MB Œº ùìë c r u x)
    (fun f ‚Ü¶ MemLp f ‚àû Œº ‚à® MemLp f 1 Œº) 1 Œº := by
  let P := fun g ‚Ü¶ g ‚àà {f : X ‚Üí E | MemLp f ‚àû Œº} + {f | MemLp f 1 Œº}
  have hP : ‚àÄ {g}, P g ‚Üí LocallyIntegrable g Œº := by
    rintro _ ‚ü®f, hf, g, hg, rfl‚ü©
    exact (MemLp.locallyIntegrable hf le_top).add (MemLp.locallyIntegrable hg le_rfl)
  simp_rw [MB, maximalFunction, inv_one, ENNReal.rpow_one]
  refine AESublinearOn.biSup2 hùìë ?_ ?_ MemLp.zero MemLp.zero MemLp.add MemLp.add ?_ ?_ ?_
  ¬∑ intro u hu
    filter_upwards [MB_ae_ne_top' hùìë hR (.inl hu)] with x hx
    simpa [MB, maximalFunction] using hx
  ¬∑ intro u hu
    filter_upwards [MB_ae_ne_top hùìë hR hu] with x hx
    simpa [MB, maximalFunction] using hx
  ¬∑ intro f c hf; rw [NNReal.smul_def]; exact hf.const_smul _
  ¬∑ intro f c hf; rw [NNReal.smul_def]; exact hf.const_smul _
  ¬∑ intro i _
    refine AESublinearOn.const (T Œº c r i) P (fun hf hg ‚Ü¶ T.add_le i (hP hf))
      (fun f d hf ‚Ü¶ T.smul i) |>.indicator _

/-- The constant factor in the statement that `M_ùìë` has strong type. -/
irreducible_def CMB (A p : ‚Ñù‚â•0) : ‚Ñù‚â•0 := C_realInterpolation ‚ä§ 1 ‚ä§ 1 p 1 (A ^ 2) 1 p‚Åª¬π

lemma CMB_defaultA_two_eq {a : ‚Ñï} : CMB (defaultA a) 2 = 2 ^ (a + (3 / 2 : ‚Ñù)) := by
  suffices (2 : ‚Ñù‚â•0) * 2 ^ (2 : ‚Ñù)‚Åª¬π * (ENNReal.ofReal |2 - 1|‚Åª¬π).toNNReal ^ (2 : ‚Ñù)‚Åª¬π *
      ((2 ^ a) ^ (2 : ‚Ñù)) ^ (2 : ‚Ñù)‚Åª¬π = 2 ^ (a + 3 / (2 : ‚Ñù)) by
    simpa [CMB, C_realInterpolation, C_realInterpolation_ENNReal]
  rw [‚Üê NNReal.rpow_mul, show (3 / 2 : ‚Ñù) = 1 + (1 / 2 : ‚Ñù) by norm_num]
  repeat rw [NNReal.rpow_add two_ne_zero]
  norm_num
  ring

/-- Special case of equation (2.0.44). The proof is given between (9.0.12) and (9.0.34).
Use the real interpolation theorem instead of following the blueprint. -/
lemma hasStrongType_MB [BorelSpace X] [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E]
    [IsFiniteMeasureOnCompacts Œº] [ProperSpace X] [Nonempty X] [Œº.IsOpenPosMeasure]
    (hùìë : ùìë.Countable) {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R) {p : ‚Ñù‚â•0} (hp : 1 < p) :
    HasStrongType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ MB Œº ùìë c r u x) p p Œº Œº (CMB A p) := by
  rw [‚Üê hasStrongType_toReal_iff sorry /- cleanup after RealInterpolation works for ENorm. -/]
  have h2p : 0 < p := by positivity
  rw [CMB]
  apply exists_hasStrongType_real_interpolation
    (T := fun (u : X ‚Üí E) (x : X) ‚Ü¶ MB Œº ùìë c r u x |>.toReal) (p := p) (q := p) (A := 1)
    ‚ü®ENNReal.zero_lt_top, le_rfl‚ü©
    ‚ü®zero_lt_one, le_rfl‚ü© (by norm_num) zero_lt_one (by simp [inv_lt_one_iff‚ÇÄ, hp, h2p] : p‚Åª¬π ‚àà _)
    zero_lt_one (pow_pos (A_pos Œº) 2)
    (by simp [ENNReal.coe_inv h2p.ne']) (by simp [ENNReal.coe_inv h2p.ne'])
    (fun f _ ‚Ü¶ AEStronglyMeasurable.maximalFunction_toReal hùìë)
    _ (HasStrongType.MB_top hùìë |>.toReal.hasWeakType le_top)
    (HasWeakType.MB_one hùìë hR).toReal
  exact ((AESublinearOn.maximalFunction hùìë hR).toReal <| MB_ae_ne_top' hùìë hR).1

lemma hasStrongType_MB_finite [BorelSpace X] [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E]
    [IsFiniteMeasureOnCompacts Œº] [ProperSpace X] [Nonempty X] [Œº.IsOpenPosMeasure]
    (hùìë : ùìë.Finite) {p : ‚Ñù‚â•0} (hp : 1 < p) :
    HasStrongType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ MB Œº ùìë c r u x) p p Œº Œº (CMB A p) :=
  hasStrongType_MB hùìë.countable (Finite.exists_image_le hùìë _).choose_spec hp

/-- The constant factor in the statement that `M_{ùìë, p}` has strong type. -/
irreducible_def C2_0_6 (A p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0) : ‚Ñù‚â•0 := CMB A (p‚ÇÇ / p‚ÇÅ) ^ (p‚ÇÅ‚Åª¬π : ‚Ñù)

/-- Equation (2.0.44). The proof is given between (9.0.34) and (9.0.36).
This is a special case of `hasStrongType_maximalFunction` below, which doesn't have the assumption
`hR` (but uses this result in its proof). -/
theorem hasStrongType_maximalFunction_aux
    [BorelSpace X] [IsFiniteMeasureOnCompacts Œº] [ProperSpace X] [Nonempty X] [Œº.IsOpenPosMeasure]
    {p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} (hùìë : ùìë.Countable) {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R) (hp‚ÇÅ : 1 ‚â§ p‚ÇÅ) (hp‚ÇÅ‚ÇÇ : p‚ÇÅ < p‚ÇÇ) :
    HasStrongType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ maximalFunction Œº ùìë c r p‚ÇÅ u x)
      p‚ÇÇ p‚ÇÇ Œº Œº (C2_0_6 A p‚ÇÅ p‚ÇÇ) := fun v mlpv ‚Ü¶ by
  refine ‚ü®AEStronglyMeasurable.maximalFunction hùìë, ?_‚ü©; dsimp only
  have cp‚ÇÅp : 0 < (p‚ÇÅ : ‚Ñù) := by positivity
  have p‚ÇÅn : p‚ÇÅ ‚â† 0 := by exact_mod_cast cp‚ÇÅp.ne'
  conv_lhs =>
    enter [1, x]
    rw [maximalFunction_eq_MB (by exact zero_le_one.trans hp‚ÇÅ), ‚Üê enorm_eq_self (MB ..)]
  rw [eLpNorm_enorm_rpow _ (by positivity), ENNReal.ofReal_inv_of_pos cp‚ÇÅp,
    ENNReal.ofReal_coe_nnreal, ‚Üê div_eq_mul_inv, ‚Üê ENNReal.coe_div p‚ÇÅn]
  calc
    _ ‚â§ (CMB A (p‚ÇÇ / p‚ÇÅ) * eLpNorm (fun y ‚Ü¶ ‚Äñv y‚Äñ ^ (p‚ÇÅ : ‚Ñù)) (p‚ÇÇ / p‚ÇÅ) Œº) ^ p‚ÇÅ.toReal‚Åª¬π := by
      apply ENNReal.rpow_le_rpow _ (by positivity)
      convert (hasStrongType_MB hùìë hR (Œº := Œº) _ (fun x ‚Ü¶ ‚Äñv x‚Äñ ^ (p‚ÇÅ : ‚Ñù)) _).2
      ¬∑ rw [ENNReal.coe_div p‚ÇÅn]
      ¬∑ rwa [lt_div_iff‚ÇÄ, one_mul]; exact cp‚ÇÅp
      ¬∑ rw [ENNReal.coe_div p‚ÇÅn]; exact mlpv.norm_rpow_div p‚ÇÅ
    _ = _ := by
      rw [ENNReal.mul_rpow_of_nonneg _ _ (by positivity), eLpNorm_norm_rpow _ cp‚ÇÅp,
        ENNReal.ofReal_coe_nnreal, ENNReal.div_mul_cancel (by positivity) (by simp),
        ENNReal.rpow_rpow_inv (by positivity), ‚Üê ENNReal.coe_rpow_of_nonneg _ (by positivity),
        C2_0_6]

def tr {ùìë : Set Œπ} (hùìë : ùìë.Countable) (k : ‚Ñï) : Set Œπ := by
  choose g hg using (Set.countable_iff_exists_injective.mp hùìë)
  exact Subtype.val '' (g ‚Åª¬π' {x : ‚Ñï | x ‚â§ k})

lemma tr_finite {ùìë : Set Œπ} (hùìë : ùìë.Countable) (k : ‚Ñï) :
    (tr hùìë k).Finite := by
  refine Finite.image Subtype.val
    (Finite.preimage (Function.Injective.injOn ?_) (finite_le_nat k))
  exact Classical.choose_spec (Set.countable_iff_exists_injective.mp hùìë)

lemma tr_radius_bound {ùìë : Set Œπ} (hùìë : ùìë.Countable) (k : ‚Ñï) :
    ‚àÉ R, ‚àÄ i ‚àà (tr hùìë k), r i ‚â§ R :=
  Finite.exists_image_le (tr_finite hùìë k) r

def maximalFunction_seq (Œº : Measure X) {ùìë : Set Œπ} (hùìë : ùìë.Countable) (c : Œπ ‚Üí X) (r : Œπ ‚Üí ‚Ñù)
    (q : ‚Ñù) (v : X ‚Üí E) (k : ‚Ñï) (z : X) :
    ‚Ñù‚â•0‚àû :=
  maximalFunction Œº (tr hùìë k) c r q v z

lemma maximalFunction_seq_mono {ùìë : Set Œπ} (hùìë : ùìë.Countable) {p : ‚Ñù‚â•0} (hp : p ‚â• 1) (u : X ‚Üí E) :
  Monotone (maximalFunction_seq Œº hùìë c r p u : ‚Ñï ‚Üí (X ‚Üí ‚Ñù‚â•0‚àû)) := by
  intro m n hmn x
  unfold maximalFunction_seq maximalFunction
  dsimp only
  apply rpow_le_rpow _ (by positivity)
  apply iSup‚ÇÇ_le
  intro i Hi
  apply le_iSup‚ÇÇ (f := fun j _ ‚Ü¶ (ball (c j) (r j)).indicator
      (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c j) (r j), ‚Üë‚Äñu y‚Äñ‚Çä ^ (ofNNReal p).toReal ‚àÇŒº) x)
  obtain ‚ü®w, hw‚ü© := Hi; use w; exact ‚ü®id (Nat.le_trans hw.left hmn), hw.right‚ü©

lemma maximalFunction_seq_eq {ùìë : Set Œπ} (hùìë : ùìë.Countable) {p : ‚Ñù‚â•0} (hp : p ‚â• 1) (u : X ‚Üí E) (x : X) :
    maximalFunction Œº ùìë c r (‚Üëp) u x =
      ‚®Ü k : ‚Ñï, maximalFunction_seq Œº hùìë c r (‚Üëp) u k x := by
  let g := Classical.choose (Set.countable_iff_exists_injective.mp hùìë)
  let ùìë' (k : ‚Ñï) := Subtype.val '' (g ‚Åª¬π' {x : ‚Ñï | x ‚â§ k})
  apply ge_antisymm
  ¬∑ exact iSup_le fun k ‚Ü¶
        rpow_le_rpow (iSup_le_iSup_of_subset (Subtype.coe_image_subset ùìë _)) (by positivity)
  ¬∑ unfold maximalFunction_seq maximalFunction
    have p_pos : p.toReal > 0 := by positivity
    refine (rpow_le_rpow_iff p_pos).mp ?_
    rw [ENNReal.rpow_inv_rpow (by positivity)]
    apply iSup‚ÇÇ_le_iff.mpr
    intro i Hi
    let k‚ÇÄ := g ‚ü®i, Hi‚ü©
    have k‚ÇÄlarge : i ‚àà ùìë' k‚ÇÄ := by
      unfold ùìë'
      simp only [preimage_setOf_eq, mem_image, mem_setOf_eq, Subtype.exists, exists_and_right,
          exists_eq_right]
      use Hi
    calc
    (ball (c i) (r i)).indicator
        (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c i) (r i), ‚Üë‚Äñu y‚Äñ‚Çä ^ p.toReal ‚àÇŒº) x
      ‚â§ (‚®Ü j ‚àà ùìë' k‚ÇÄ, (ball (c j) (r j)).indicator
        (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c j) (r j), ‚Üë‚Äñu y‚Äñ‚Çä ^ p.toReal ‚àÇŒº) x) := by
      apply le_iSup‚ÇÇ (i := i)
          (f := fun j _ ‚Ü¶ (ball (c j) (r j)).indicator
          (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c j) (r j), ‚Üë‚Äñu y‚Äñ‚Çä ^ p.toReal ‚àÇŒº) x) k‚ÇÄlarge
    _ = ((‚®Ü j ‚àà ùìë' k‚ÇÄ, (ball (c j) (r j)).indicator
        (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c j) (r j),
            ‚Üë‚Äñu y‚Äñ‚Çä ^ p.toReal ‚àÇŒº) x)^p.toReal‚Åª¬π ) ^ p.toReal := by
      rw [ENNReal.rpow_inv_rpow]; positivity
    _ ‚â§ _ := by
      gcongr
      apply le_iSup (f := fun k ‚Ü¶ (‚®Ü i ‚àà ùìë' k, (ball (c i) (r i)).indicator
          (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c i) (r i), ‚Üë‚Äñu y‚Äñ‚Çä ^ p.toReal ‚àÇŒº) x) ^ (p.toReal)‚Åª¬π)

/-- `hasStrongType_maximalFunction` minus the assumption `hR`.
A proof for basically this result is given in Chapter 9, everything following after equation
(9.0.36). -/
theorem hasStrongType_maximalFunction
    [BorelSpace X] [IsFiniteMeasureOnCompacts Œº] [ProperSpace X] [Nonempty X] [Œº.IsOpenPosMeasure]
    {p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} (hùìë : ùìë.Countable) (hp‚ÇÅ : 1 ‚â§ p‚ÇÅ) (hp‚ÇÅ‚ÇÇ : p‚ÇÅ < p‚ÇÇ) :
    HasStrongType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ maximalFunction Œº ùìë c r p‚ÇÅ u x)
      p‚ÇÇ p‚ÇÇ Œº Œº (C2_0_6 A p‚ÇÅ p‚ÇÇ) := by
  intro v mlpv
  dsimp only
  constructor; ¬∑ exact AEStronglyMeasurable.maximalFunction hùìë
  have hp‚ÇÇpos : (ofNNReal p‚ÇÇ).toReal > 0 :=
    toReal_pos (coe_ne_zero.mpr (ne_zero_of_lt hp‚ÇÅ‚ÇÇ)) coe_ne_top
  have hp‚ÇÇneq_zero : (ofNNReal p‚ÇÇ).toReal ‚â† 0 := Ne.symm (ne_of_lt hp‚ÇÇpos)
  have hp‚ÇÇinv_pos : (ofNNReal p‚ÇÇ).toReal‚Åª¬π > 0 := inv_pos_of_pos hp‚ÇÇpos
  have hestfin : ‚àÄ k : ‚Ñï, eLpNorm
      (fun x ‚Ü¶ maximalFunction_seq Œº hùìë c r (‚Üëp‚ÇÅ) v k x) (‚Üëp‚ÇÇ) Œº ‚â§
      ‚Üë(C2_0_6 A p‚ÇÅ p‚ÇÇ) * eLpNorm v (‚Üëp‚ÇÇ) Œº := by
    intro k
    obtain ‚ü®R, hR‚ü© := Finite.exists_image_le (tr_finite hùìë k) r
    exact (hasStrongType_maximalFunction_aux (c := c)
        (Finite.countable (tr_finite hùìë k)) hR hp‚ÇÅ hp‚ÇÅ‚ÇÇ v mlpv).2
  unfold eLpNorm
  split_ifs with h‚ÇÄ
  ¬∑ simp
  ¬∑ have h : ENNReal.ofNNReal p‚ÇÇ = ‚ä§ := by assumption
    simp at h
  ¬∑ unfold eLpNorm'
    calc
    _ = (‚à´‚Åª (a : X), (‚®Ü k, maximalFunction_seq Œº hùìë c r (‚Üëp‚ÇÅ) v k a) ^ (ofNNReal p‚ÇÇ).toReal ‚àÇŒº)
        ^ (1 / (ofNNReal p‚ÇÇ).toReal) := by
      congr; ext x; congr; exact maximalFunction_seq_eq hùìë hp‚ÇÅ v x
    _ ‚â§ (‚à´‚Åª (a : X), ‚®Ü k, (maximalFunction_seq Œº hùìë c r (‚Üëp‚ÇÅ) v k a) ^ (ofNNReal p‚ÇÇ).toReal ‚àÇŒº)
        ^ (1 / (ofNNReal p‚ÇÇ).toReal) := by
      gcongr with a
      apply (rpow_le_rpow_iff (z := ((ofNNReal p‚ÇÇ).toReal)‚Åª¬π) (by positivity)).mp
      rw [rpow_rpow_inv (hp‚ÇÇneq_zero)]
      apply iSup_le
      intro i
      rw [‚Üê ENNReal.rpow_rpow_inv (x := maximalFunction_seq _ _ _ _ _ _ _ _) hp‚ÇÇneq_zero]
      gcongr
      apply le_iSup
          (f := fun j ‚Ü¶ (maximalFunction_seq Œº hùìë c r (‚Üëp‚ÇÅ) v j a) ^ (ofNNReal p‚ÇÇ).toReal)
    _ = (‚®Ü k, ‚à´‚Åª (a : X), maximalFunction_seq Œº hùìë c r (‚Üëp‚ÇÅ) v k a ^ (ofNNReal p‚ÇÇ).toReal ‚àÇŒº)
        ^ (1 / (ofNNReal p‚ÇÇ).toReal) := by
      congr 1
      apply lintegral_iSup'
      ¬∑ exact fun k ‚Ü¶
        AEMeasurable.pow_const
          (AEStronglyMeasurable.aemeasurable
            (AEStronglyMeasurable.maximalFunction (Finite.countable (tr_finite hùìë k))))
          (ofNNReal p‚ÇÇ).toReal
      ¬∑ refine ae_of_all Œº fun a ‚¶Ék l‚¶Ñ hkl ‚Ü¶ id (rpow_le_rpow ?_ (le_of_lt hp‚ÇÇpos))
        exact maximalFunction_seq_mono hùìë hp‚ÇÅ v hkl a
    _ ‚â§ _ := by
      apply (rpow_le_rpow_iff hp‚ÇÇpos).mp
      rw [one_div, ENNReal.rpow_inv_rpow hp‚ÇÇneq_zero]
      apply iSup_le
      intro k
      apply (rpow_le_rpow_iff hp‚ÇÇinv_pos).mp
      rw [ENNReal.rpow_rpow_inv hp‚ÇÇneq_zero]
      unfold eLpNorm at hestfin
      split_ifs at hestfin
      unfold eLpNorm' at hestfin
      rw [one_div] at hestfin
      exact hestfin k

lemma lowerSemiContinuous_MB :
    LowerSemicontinuous (MB Œº ùìë c r f) := by
  apply lowerSemicontinuous_iff_isOpen_preimage.mpr
  intro y
  unfold MB maximalFunction
  simp only [rpow_one, inv_one]
  have : ((fun x ‚Ü¶ (‚®Ü i ‚àà ùìë, (ball (c i) (r i)).indicator
      (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c i) (r i), ‚Äñf y‚Äñ‚Çë ‚àÇŒº) x)) ‚Åª¬π' Ioi y) =
      ‚ãÉ i ‚àà ùìë, (ball (c i) (r i)).indicator
      (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c i) (r i), ‚Äñf y‚Äñ‚Çë ‚àÇŒº) ‚Åª¬π' Ioi y := by
    ext x
    simp only [pow_one, mem_preimage, mem_Ioi, mem_iUnion, exists_prop]
    constructor
    ¬∑ intro h
      by_contra h‚ÇÄ
      simp only [not_exists, not_and, not_lt] at h‚ÇÄ
      have := iSup‚ÇÇ_le_iff.mpr h‚ÇÄ
      order
    ¬∑ intro h
      obtain ‚ü®i, ‚ü®hi‚ÇÄ, hi‚ÇÅ‚ü©‚ü© := h
      exact lt_iSup_iff.mpr (by use i; refine lt_iSup_iff.mpr (by use hi‚ÇÄ))
  rw [this]
  refine isOpen_biUnion (fun i hi ‚Ü¶ ?_)
  refine LowerSemicontinuous.isOpen_preimage ?_ y
  refine IsOpen.lowerSemicontinuous_indicator isOpen_ball (zero_le _)

theorem hasWeakType_maximalFunction_equal_exponents‚ÇÄ [BorelSpace X]
    {p : ‚Ñù‚â•0} (hùìë : ùìë.Countable) {R : ‚Ñù} (hR : ‚àÄ i ‚àà ùìë, r i ‚â§ R) (hp : 1 ‚â§ p) :
    HasWeakType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ maximalFunction Œº ùìë c r p u x)
      p p Œº Œº (A ^ ((2 / p : ‚Ñù))) := by
  intro v mlpv
  dsimp only
  constructor; ¬∑ exact AEStronglyMeasurable.maximalFunction hùìë
  have cp : 0 < (p : ‚Ñù) := by positivity
  have p‚ÇÅn : p ‚â† 0 := by exact_mod_cast cp.ne'
  conv_lhs =>
    enter [1, x]
    rw [maximalFunction_eq_MB (by exact zero_le_one.trans hp)]
  have hmb_one : wnorm (MB Œº ùìë c r fun x ‚Ü¶ ‚Äñv x‚Äñ ^ (p : ‚Ñù)) 1 Œº ‚â§ ‚ÜëA ^ 2 * eLpNorm (fun x ‚Ü¶ ‚Äñv x‚Äñ ^ (p : ‚Ñù)) 1 Œº := by
    apply (HasWeakType.MB_one hùìë hR
      (fun x : X ‚Ü¶ ‚Äñv x‚Äñ ^ (p : ‚Ñù)) _).2
    convert MemLp.norm_rpow_div mlpv p
    exact Eq.symm (ENNReal.div_self (coe_ne_zero.mpr p‚ÇÅn) coe_ne_top)
  unfold wnorm wnorm' distribution at hmb_one ‚ä¢
  simp only [one_ne_top, ‚ÜìreduceIte, enorm_eq_self, toReal_one, inv_one, rpow_one, iSup_le_iff,
    coe_ne_top, coe_toReal] at hmb_one ‚ä¢
  intro t
  by_cases ht : t = 0
  ¬∑ rw [ht]; simp
  ¬∑ apply (rpow_le_rpow_iff cp).mp
    rw [ENNReal.mul_rpow_of_nonneg _ _ NNReal.zero_le_coe]
    convert hmb_one (t ^ (p : ‚Ñù))
    ¬∑ exact Eq.symm (coe_rpow_of_ne_zero ht ‚Üëp)
    ¬∑ rw [rpow_inv_rpow (NNReal.coe_ne_zero.mpr p‚ÇÅn)]
      congr; ext x; rw [coe_rpow_of_ne_zero ht ‚Üëp]; exact (lt_rpow_inv_iff cp)
    ¬∑ rw [eLpNorm_norm_rpow v cp, ENNReal.mul_rpow_of_nonneg _ _ NNReal.zero_le_coe,
          div_eq_mul_inv, rpow_mul, rpow_inv_rpow (NNReal.coe_ne_zero.mpr p‚ÇÅn), rpow_two]; simp

theorem hasWeakType_maximalFunction_equal_exponents
    [BorelSpace X] {p : ‚Ñù‚â•0} (hùìë : ùìë.Countable) (hp : 1 ‚â§ p) :
    HasWeakType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ maximalFunction Œº ùìë c r p u x)
      p p Œº Œº (A ^ ((2 / p : ‚Ñù))) := by
  intro v mlpv
  dsimp only
  constructor; ¬∑ exact AEStronglyMeasurable.maximalFunction hùìë
  have p_pos : (p : ‚Ñù) > 0 := NNReal.coe_pos.mpr (Trans.trans zero_lt_one hp)
  have hestfin (k : ‚Ñï) : wnorm
      (fun x ‚Ü¶ maximalFunction_seq Œº hùìë c r p v k x) p Œº ‚â§
      (A ^ (2 / p : ‚Ñù)) * eLpNorm v p Œº := by
    obtain ‚ü®R, hR‚ü© := Finite.exists_image_le (tr_finite hùìë k) r
    exact (hasWeakType_maximalFunction_equal_exponents‚ÇÄ (c := c)
        (Finite.countable (tr_finite hùìë k)) hR hp v mlpv).2
  unfold wnorm wnorm' at hestfin ‚ä¢
  simp only [coe_ne_top, ‚ÜìreduceIte, coe_toReal, iSup_le_iff] at hestfin ‚ä¢
  unfold distribution at hestfin ‚ä¢
  have hunion (t : ‚Ñù‚â•0) :
      {x | (t : ‚Ñù‚â•0‚àû) < ‚Äñ maximalFunction Œº ùìë c r (‚Üëp) v x‚Äñ‚Çë } ‚äÜ
      ‚ãÉ k : ‚Ñï, {x | (t : ‚Ñù‚â•0‚àû) < ‚Äñ maximalFunction Œº (tr hùìë k) c r (‚Üëp) v x‚Äñ‚Çë } := by
    intro x
    simp only [enorm_eq_self, mem_setOf_eq, mem_iUnion]
    intro hx
    by_contra! h‚ÇÄ
    refine (not_le_of_lt (gt_of_ge_of_gt ?_ hx)) (iSup_le h‚ÇÄ)
    rw [maximalFunction_seq_eq _ hp]
    rfl
  let f (k : ‚Ñï) := fun x ‚Ü¶ maximalFunction Œº (tr hùìë k) c r (‚Üëp) v x
  have f_mon : Monotone f := by
    intro a b hab x
    apply rpow_le_rpow _ (by positivity)
    apply iSup‚ÇÇ_le
    intro i Hi
    apply le_iSup‚ÇÇ (f := fun j _ ‚Ü¶ (ball (c j) (r j)).indicator
        (fun x ‚Ü¶ ‚®ç‚Åª (y : X) in ball (c j) (r j), ‚Üë‚Äñv y‚Äñ‚Çä ^ (ofNNReal p).toReal ‚àÇŒº) x)
    obtain ‚ü®w, hw‚ü© := Hi; use w; exact ‚ü®id (Nat.le_trans hw.left hab), hw.right‚ü©
  intro t
  have hm :
      Monotone (fun k ‚Ü¶ {x | (t : ‚Ñù‚â•0‚àû) < ‚Äñ maximalFunction Œº (tr hùìë k) c r (‚Üëp) v x‚Äñ‚Çë }) := by
    unfold f at f_mon
    intro m n hmn
    intro x
    simp only [enorm_eq_self, mem_setOf_eq]
    intro ht
    exact Trans.trans ht (f_mon hmn x)
  apply (rpow_le_rpow_iff p_pos).mp
  rw [ENNReal.mul_rpow_of_nonneg _ _ (by positivity)]
  rw [rpow_inv_rpow (ne_of_gt p_pos)]
  by_cases ht : t = 0; ¬∑ rw [ht]; simp [(zero_rpow_of_pos p_pos)]
  have htp : (t : ‚Ñù‚â•0‚àû) ^ (p : ‚Ñù) ‚â† 0 :=
    ne_of_gt (rpow_pos (coe_pos.mpr (lt_of_le_of_ne' (zero_le t) ht)) coe_ne_top)
  have htp' : (t : ‚Ñù‚â•0‚àû) ^ (p : ‚Ñù) ‚â† ‚ä§ :=
    ne_of_lt ((rpow_lt_top_iff_of_pos p_pos).mpr coe_lt_top)
  refine (mul_le_iff_le_inv htp htp').mpr ?_
  calc
  _ ‚â§_  := measure_mono (hunion t)
  _ ‚â§ _ := by
    have := MeasureTheory.tendsto_measure_iUnion_atTop (Œº := Œº) hm
    refine le_of_tendsto_of_frequently this (Frequently.of_forall (fun x ‚Ü¶ ?_))
    dsimp only [Function.comp_apply]
    refine (mul_le_iff_le_inv htp htp').mp ?_
    rw [‚Üê rpow_inv_rpow (x := Œº _) (ne_of_gt p_pos),
        ‚Üê ENNReal.mul_rpow_of_nonneg _ _ (by positivity)]
    exact (rpow_le_rpow_iff p_pos).mpr (hestfin x t)

def C_weakType_maximalFunction (A p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0) :=
  if p‚ÇÅ = p‚ÇÇ then (ofNNReal A) ^ (2 / p‚ÇÅ : ‚Ñù) else C2_0_6 A p‚ÇÅ p‚ÇÇ

lemma C_weakType_maximalFunction_lt_top {A p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} :
    C_weakType_maximalFunction A p‚ÇÅ p‚ÇÇ < ‚àû := by
  unfold C_weakType_maximalFunction
  split_ifs with hps
  ¬∑ apply rpow_lt_top_of_nonneg (by positivity) (by simp)
  ¬∑ simp

/-- `hasStrongType_maximalFunction` minus the assumption `hR`, but where `p‚ÇÅ = p‚ÇÇ` is possible and
we only conclude a weak-type estimate. -/
theorem hasWeakType_maximalFunction
    [BorelSpace X] [IsFiniteMeasureOnCompacts Œº] [ProperSpace X] [Nonempty X] [Œº.IsOpenPosMeasure]
    {p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} (hùìë : ùìë.Countable) (hp‚ÇÅ : 1 ‚â§ p‚ÇÅ) (hp‚ÇÅ‚ÇÇ : p‚ÇÅ ‚â§ p‚ÇÇ) :
    HasWeakType (fun (u : X ‚Üí E) (x : X) ‚Ü¶ maximalFunction Œº ùìë c r p‚ÇÅ u x)
      p‚ÇÇ p‚ÇÇ Œº Œº (C_weakType_maximalFunction A p‚ÇÅ p‚ÇÇ) := by
  unfold C_weakType_maximalFunction
  split_ifs with hps
  ¬∑ rw [‚Üê hps]
    exact hasWeakType_maximalFunction_equal_exponents (A := A) hùìë hp‚ÇÅ
  ¬∑ apply HasStrongType.hasWeakType (one_le_coe_iff.mpr (le_trans hp‚ÇÅ hp‚ÇÅ‚ÇÇ))
    exact hasStrongType_maximalFunction hùìë hp‚ÇÅ (lt_of_le_of_ne hp‚ÇÅ‚ÇÇ hps)

section GMF

variable [ProperSpace X]

variable (Œº) in
/-- The transformation `M` characterized in Proposition 2.0.6.
`p` is `1` in the blueprint, and `globalMaximalFunction Œº p u = (M (u ^ p)) ^ p‚Åª¬π ` -/
@[nolint unusedArguments]
def globalMaximalFunction [Œº.IsDoubling A] (p : ‚Ñù) (u : X ‚Üí E) (x : X) : ‚Ñù‚â•0‚àû :=
  A ^ 2 * maximalFunction Œº ((covering_separable_space X).choose √óÀ¢ (univ : Set ‚Ñ§))
    (¬∑.1) (fun x ‚Ü¶ 2 ^ (x.2)) p u x

protected theorem MeasureTheory.AEStronglyMeasurable.globalMaximalFunction
    [BorelSpace X] {p : ‚Ñù} {u : X ‚Üí E} : AEStronglyMeasurable (globalMaximalFunction Œº p u) Œº :=
  AEStronglyMeasurable.maximalFunction countable_globalMaximalFunction
    |>.aemeasurable.const_mul _ |>.aestronglyMeasurable

/-- Equation (2.0.45) -/
theorem laverage_le_globalMaximalFunction [IsFiniteMeasureOnCompacts Œº] [Œº.IsOpenPosMeasure]
    {u : X ‚Üí E} {z x : X} {r : ‚Ñù} (h : dist x z < r) :
    ‚®ç‚Åª y, ‚Äñu y‚Äñ‚Çë ‚àÇŒº.restrict (ball z r) ‚â§ globalMaximalFunction Œº 1 u x := by
  rw [globalMaximalFunction, maximalFunction]
  simp only [gt_iff_lt, mem_prod, mem_univ, and_true, ENNReal.rpow_one, inv_one]
  have hr : 0 < r := lt_of_le_of_lt dist_nonneg h
  obtain ‚ü®c, hc, m, h_subset, _, h_subset'‚ü© := exists_ball_subset_ball_two z hr
  calc
    _ ‚â§ (Œº (ball z r))‚Åª¬π * ‚à´‚Åª y in ball c (2 ^ m), ‚Äñu y‚Äñ‚Çë ‚àÇŒº := by
      simp only [laverage, MeasurableSet.univ, Measure.restrict_apply, univ_inter,
        lintegral_smul_measure, smul_eq_mul]
      gcongr
      exact lintegral_mono_set h_subset
    _ ‚â§ A ^ 2 * (Œº (ball c (2 ^ m)))‚Åª¬π * ‚à´‚Åª y in ball c (2 ^ m), ‚Äñu y‚Äñ‚Çë ‚àÇŒº := by
      gcongr
      rw [mul_comm, ‚Üê ENNReal.mul_le_iff_le_inv
        ((measure_ball_pos _ (zpow_pos zero_lt_two _) (Œº := Œº)).ne')
          measure_ball_ne_top, ENNReal.mul_inv_le_iff
            ((measure_ball_pos _ hr (Œº := Œº)).ne') measure_ball_ne_top]
      exact (Œº.mono h_subset').trans <| measure_ball_four_le_same' z r
    _ ‚â§ _ := by
      rw [mul_assoc]
      gcongr
      refine (le_iSup‚ÇÇ (c, m) hc).trans_eq' ?_
      simp [laverage, indicator_of_mem (h_subset h)]

theorem lintegral_ball_le_volume_globalMaximalFunction [IsFiniteMeasureOnCompacts Œº] [Œº.IsOpenPosMeasure]
    {u : X ‚Üí E} {z x : X} {r : ‚Ñù} (h : dist x z < r) :
    ‚à´‚Åª y in (ball z r), ‚Äñu y‚Äñ‚Çë ‚àÇŒº  ‚â§ Œº (ball z r) * globalMaximalFunction Œº 1 u x := by
  have : IsFiniteMeasure (Œº.restrict (ball z r)) := isFiniteMeasure_restrict.mpr measure_ball_ne_top
  rw [‚Üê measure_mul_laverage]
  simp only [MeasurableSet.univ, Measure.restrict_apply, univ_inter]
  gcongr
  exact laverage_le_globalMaximalFunction h

/-- The constant factor in the statement that `M` has strong type. -/
def C2_0_6' (A p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0) : ‚Ñù‚â•0 := A ^ 2 * C2_0_6 A p‚ÇÅ p‚ÇÇ

lemma C2_0_6'_defaultA_one_two_eq {a : ‚Ñï}: C2_0_6' (defaultA a) 1 2 = 2 ^ (3 * a + 3 / (2 : ‚Ñù)) := by
  simp_rw [C2_0_6', C2_0_6, div_one, CMB_defaultA_two_eq, defaultA, Nat.cast_pow, Nat.cast_ofNat,
    NNReal.coe_one, inv_one, NNReal.rpow_one, ‚Üê pow_mul, ‚Üê NNReal.rpow_natCast]
  rw [‚Üê NNReal.rpow_add (by simp)]
  congr 1
  field_simp
  ring

/-- Equation (2.0.46). Easy from `hasStrongType_maximalFunction` -/
theorem hasStrongType_globalMaximalFunction [BorelSpace X] [IsFiniteMeasureOnCompacts Œº]
    [Nonempty X] [Œº.IsOpenPosMeasure] {p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} (hp‚ÇÅ : 1 ‚â§ p‚ÇÅ) (hp‚ÇÅ‚ÇÇ : p‚ÇÅ < p‚ÇÇ) :
    HasStrongType (globalMaximalFunction Œº p‚ÇÅ (E := E))
      p‚ÇÇ p‚ÇÇ Œº Œº (C2_0_6' A p‚ÇÅ p‚ÇÇ) := by
  apply HasStrongType.const_mul (c := C2_0_6 A p‚ÇÅ p‚ÇÇ)
  exact hasStrongType_maximalFunction countable_globalMaximalFunction hp‚ÇÅ hp‚ÇÅ‚ÇÇ

def C_weakType_globalMaximalFunction (A p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0) :=
  A ^ 2 * C_weakType_maximalFunction A p‚ÇÅ p‚ÇÇ

lemma C_weakType_globalMaximalFunction_lt_top {A p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} :
    C_weakType_globalMaximalFunction A p‚ÇÅ p‚ÇÇ < ‚àû :=
  mul_lt_top (by simp) C_weakType_maximalFunction_lt_top

-- the constant here `A ^ 4` can be improved
theorem hasWeakType_globalMaximalFunction [BorelSpace X] [IsFiniteMeasureOnCompacts Œº]
    [Nonempty X] [Œº.IsOpenPosMeasure] {p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} (hp‚ÇÅ : 1 ‚â§ p‚ÇÅ) (hp‚ÇÅ‚ÇÇ : p‚ÇÅ ‚â§ p‚ÇÇ) :
    HasWeakType (globalMaximalFunction Œº p‚ÇÅ (E := E))
      p‚ÇÇ p‚ÇÇ Œº Œº (C_weakType_globalMaximalFunction A p‚ÇÅ p‚ÇÇ) := by
  have : (p‚ÇÇ : ‚Ñù‚â•0‚àû) ‚â† 0 := by
    refine coe_ne_zero.mpr ?_
    have := zero_lt_one (Œ± := ‚Ñù‚â•0)
    order
  convert HasWeakType.const_mul (c := C_weakType_maximalFunction A p‚ÇÅ p‚ÇÇ) (e := A ^ 2) this _
  exact hasWeakType_maximalFunction countable_globalMaximalFunction hp‚ÇÅ hp‚ÇÅ‚ÇÇ

/-- Use `lowerSemiContinuous_MB` -/
lemma lowerSemiContinuous_globalMaximalFunction :
    LowerSemicontinuous (globalMaximalFunction Œº 1 f) := by
  by_cases h : A = 0; ¬∑ unfold globalMaximalFunction; simp_rw [h]; simp [lowerSemicontinuous_const]
  have : globalMaximalFunction Œº 1 f = fun x : X ‚Ü¶
      ofNNReal A ^ 2 * MB Œº ((covering_separable_space X).choose √óÀ¢ (univ : Set ‚Ñ§))
      (fun x ‚Ü¶ x.1) (fun x ‚Ü¶ 2 ^ x.2) (fun x ‚Ü¶ ‚Äñf x‚Äñ ^ (1 : ‚Ñù)) x ^ (1 : ‚Ñù)‚Åª¬π :=
    funext fun x ‚Ü¶ congr_arg (HMul.hMul ((A : ‚Ñù‚â•0‚àû) ^ 2)) (maximalFunction_eq_MB (zero_le_one' ‚Ñù))
  rw [this]
  simp only [gt_iff_lt, Real.rpow_one, inv_one, rpow_one]
  refine lowerSemicontinuous_iff_isOpen_preimage.mpr fun y ‚Ü¶ ?_
  by_cases hy : y = ‚àû; ¬∑ rw [hy]; simp
  have : (fun x : X ‚Ü¶ ofNNReal A ^ 2 * MB Œº ((covering_separable_space X).choose √óÀ¢ (univ : Set ‚Ñ§))
      (fun x ‚Ü¶ x.1) (fun x ‚Ü¶ 2 ^ x.2) (fun x ‚Ü¶ ‚Äñf x‚Äñ) x)‚Åª¬π' Ioi y =
      (fun x : X ‚Ü¶ MB Œº ((covering_separable_space X).choose √óÀ¢ (univ : Set ‚Ñ§)) (fun x ‚Ü¶ x.1)
      (fun x ‚Ü¶ 2 ^ x.2) (fun x ‚Ü¶ ‚Äñf x‚Äñ ) x)‚Åª¬π' Ioi (y / A ^ 2) := by
    ext x
    simp only [gt_iff_lt, Real.rpow_one, mem_preimage, mem_Ioi]
    refine ‚ü®fun h‚ÇÄ ‚Ü¶ div_lt_of_lt_mul' h‚ÇÄ, fun h‚ÇÄ ‚Ü¶ ?_‚ü©; rw [mul_comm]; exact
        (ENNReal.div_lt_iff (Or.inl (ENNReal.pow_ne_zero (coe_ne_zero.mpr h) 2)) (Or.inr hy)).mp h‚ÇÄ
  rw [this]
  exact LowerSemicontinuous.isOpen_preimage lowerSemiContinuous_MB _

theorem globalMaximalFunction_ae_lt_top [BorelSpace X] [IsFiniteMeasureOnCompacts Œº]
    [Nonempty X] [Œº.IsOpenPosMeasure] {p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0} (hp‚ÇÅ : 1 ‚â§ p‚ÇÅ) (hp‚ÇÅ‚ÇÇ : p‚ÇÅ < p‚ÇÇ)
    {u : X ‚Üí E} (hu : MemLp u p‚ÇÇ Œº):
    ‚àÄ·µê x ‚àÇŒº, globalMaximalFunction Œº p‚ÇÅ u x < ‚àû := by
  simp_rw [lt_top_iff_ne_top]
  conv => arg 1; intro x; rw [‚Üê enorm_eq_self (x := globalMaximalFunction Œº p‚ÇÅ u x)]
  exact MemWLp.ae_ne_top (HasWeakType.memWLp (hasWeakType_globalMaximalFunction hp‚ÇÅ hp‚ÇÅ‚ÇÇ.le) hu
    C_weakType_globalMaximalFunction_lt_top)

theorem globalMaximalFunction_lt_top {p : ‚Ñù‚â•0} (hp‚ÇÅ : 1 ‚â§ p)
    {u : X ‚Üí E} (hu : MemLp u ‚ä§ Œº) {x : X} :
    globalMaximalFunction Œº p u x < ‚àû := by
  unfold globalMaximalFunction
  rw [maximalFunction_eq_MB (by simp)]
  apply mul_lt_top (by simp) (rpow_lt_top_of_nonneg (by simp) (lt_top_iff_ne_top.mp _))
  have : MemLp (fun x ‚Ü¶ ‚Äñu x‚Äñ ^ p.toReal) ‚ä§ Œº := by
    have rw1 : p.toReal = (p : ‚Ñù‚â•0‚àû).toReal := by simp
    have rw2 : (‚ä§ : ‚Ñù‚â•0‚àû) = ‚ä§ / p := by simp
    rw [rw1, rw2, memLp_norm_rpow_iff hu.aestronglyMeasurable (by positivity) (by simp)]
    exact hu
  exact lt_of_le_of_lt MB_le_eLpNormEssSup (this.eLpNormEssSup_lt_top)

end GMF
