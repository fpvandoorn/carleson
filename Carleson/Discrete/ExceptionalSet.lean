import Carleson.Discrete.Defs
import Carleson.HardyLittlewood

open MeasureTheory Measure NNReal Metric Set
open scoped ENNReal
open Classical -- We use quite some `Finset.filter`
noncomputable section

open scoped ShortVariables
variable {X : Type*} {a : ‚Ñï} {q : ‚Ñù} {K : X ‚Üí X ‚Üí ‚ÑÇ} {œÉ‚ÇÅ œÉ‚ÇÇ : X ‚Üí ‚Ñ§} {F G : Set X}
  [MetricSpace X] [ProofData a q K œÉ‚ÇÅ œÉ‚ÇÇ F G]

variable (X) in
/-- The constant in Lemma 5.2.9, with value `D ^ (1 - Œ∫ * Z * (n + 1))` -/
def C5_2_9 [ProofData a q K œÉ‚ÇÅ œÉ‚ÇÇ F G] (n : ‚Ñï) : ‚Ñù‚â•0 := D ^ (1 - Œ∫ * Z * (n + 1))

/-- A rearrangement for Lemma 5.2.9 that does not require the tile structure. -/
lemma third_exception_rearrangement :
    (‚àë' n, ‚àë' k, if k ‚â§ n then ‚àë' (j : ‚Ñï),
      C5_2_9 X n * 2 ^ (9 * a - j : ‚Ñ§) * 2 ^ (n + k + 3) * volume G else 0) =
    ‚àë' k, 2 ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G *
      ‚àë' n, if k ‚â§ n then (2 * D ^ (-Œ∫ * Z) : ‚Ñù‚â•0‚àû) ^ (n - k : ‚Ñù) else 0 := by
  calc
    _ = ‚àë' n, ‚àë' k, if k ‚â§ n then C5_2_9 X n * 2 ^ (9 * a) * 2 ^ (n + k + 3) * volume G *
        ‚àë' (j : ‚Ñï), 2 ^ (-j : ‚Ñ§) else 0 := by
      congr!; rw [‚Üê ENNReal.tsum_mul_left]; congr! 2 with j
      rw [‚Üê mul_rotate (2 ^ (-j : ‚Ñ§)), ‚Üê mul_assoc (2 ^ (-j : ‚Ñ§)), ‚Üê mul_assoc (2 ^ (-j : ‚Ñ§)),
        mul_rotate (2 ^ (-j : ‚Ñ§)), mul_assoc _ _ (2 ^ (-j : ‚Ñ§))]; congr
      rw [sub_eq_add_neg, ENNReal.zpow_add two_ne_zero (by simp)]; congr 1; norm_cast
    _ = ‚àë' k, ‚àë' n, if k ‚â§ n then
        C5_2_9 X n * 2 ^ (9 * a) * 2 ^ (n + k + 3) * volume G * 2 else 0 := by
      rw [ENNReal.tsum_comm]; congr!; exact ENNReal.sum_geometric_two_pow_neg_one
    _ = ‚àë' k, 2 ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G *
        ‚àë' n, if k ‚â§ n then (2 : ‚Ñù‚â•0‚àû) ^ (n - k : ‚Ñù) * D ^ (-Œ∫ * Z * (n - k)) else 0 := by
      congr! 2 with k; rw [‚Üê ENNReal.tsum_mul_left]
      congr! 2 with n; rw [mul_ite, mul_zero]; congr 1
      have c1 : (C5_2_9 X n : ‚Ñù‚â•0‚àû) = D ^ (1 - Œ∫ * Z * (k + 1)) * D ^ (-Œ∫ * Z * (n - k)) := by
        rw [C5_2_9, ENNReal.coe_rpow_of_ne_zero (by rw [defaultD]; positivity),
          ENNReal.coe_natCast,
          ‚Üê ENNReal.rpow_add _ _ (by rw [defaultD]; positivity) (by rw [defaultD]; simp)]
        congr; ring
      have c2 : (2 : ‚Ñù‚â•0‚àû) ^ (n + k + 3) = 2 ^ (2 * k + 3) * 2 ^ (n - k : ‚Ñù) := by
        rw [show (2 : ‚Ñù‚â•0‚àû) ^ (2 * k + 3) = 2 ^ (2 * k + 3 : ‚Ñù) by norm_cast,
          show (2 : ‚Ñù‚â•0‚àû) ^ (n + k + 3) = 2 ^ (n + k + 3 : ‚Ñù) by norm_cast,
          ‚Üê ENNReal.rpow_add _ _ two_ne_zero (by simp)]
        congr 1; ring
      rw [c1, c2]; ring
    _ = _ := by congr!; rw [ENNReal.rpow_mul, ENNReal.mul_rpow_of_ne_top (by simp) (by simp)]

variable [TileStructure Q D Œ∫ S o] {k n j l : ‚Ñï} {p p' u u' : ùîì X} {x : X}

/-! ## Section 5.2 and Lemma 5.1.1 -/

section first_exception

open ENNReal

/-- Lemma 5.2.1 -/
lemma first_exception' : volume (G‚ÇÅ : Set X) ‚â§ 2 ^ (- 5 : ‚Ñ§) * volume G := by
  -- Handle trivial cases
  by_cases hF : volume F = 0
  ¬∑ simp [G‚ÇÅ_empty hF]
  by_cases hG : volume G = 0
  ¬∑ exact (G‚ÇÅ_empty' hG ‚ñ∏ OuterMeasureClass.measure_empty volume) ‚ñ∏ zero_le _
  -- Define constant `K` and prove 0 < K < ‚ä§
  let K := 2 ^ (2 * a + 5) * volume F / volume G
  have vol_G_ne_top : volume G ‚â† ‚ä§ :=
    lt_of_le_of_lt (measure_mono (ProofData.G_subset)) measure_ball_lt_top |>.ne
  have K0 : K > 0 := by
    refine ENNReal.div_pos (ne_of_gt ?_) vol_G_ne_top
    exact mul_pos_iff.2 ‚ü®ENNReal.pow_pos two_pos _, measure_pos_of_superset subset_rfl hF‚ü©
  have K_ne_top : K ‚â† ‚ä§ := by
    simp only [K]
    refine (div_lt_top (mul_ne_top (pow_ne_top two_ne_top) ?_) hG).ne
    exact (measure_mono (ProofData.F_subset)).trans_lt measure_ball_lt_top |>.ne
  -- Define function `r : ùîì X ‚Üí ‚Ñù`, with garbage value `0` for `p ‚àâ highDensityTiles`
  have : ‚àÄ p ‚àà highDensityTiles, ‚àÉ r ‚â• 4 * (D : ‚Ñù) ^ ùî∞ p,
      volume (F ‚à© (ball (ùî† p) r)) ‚â• K * volume (ball (ùî† p) r) := by
    intro p hp
    simp_rw [highDensityTiles, mem_setOf_eq, dens‚ÇÇ, lt_iSup_iff, mem_singleton_iff] at hp
    rcases hp with ‚ü®p, rfl, r, hr, h‚ü©
    use r, hr
    refine ENNReal.lt_div_iff_mul_lt ?_ (Or.inl (measure_ball_ne_top (ùî† p) r)) |>.mp h |>.le
    have r0 : r > 0 := lt_of_lt_of_le (by have := defaultD_pos a; positivity) hr
    exact Or.inl <| (measure_ball_pos volume (ùî† p) r0).ne.symm
  let r (p : ùîì X) := dite (p ‚àà highDensityTiles) (fun hp ‚Ü¶ choose (this p hp)) (fun _ ‚Ü¶ 0)
  have hr {p : ùîì X} (hp : p ‚àà highDensityTiles) := choose_spec (this p hp)
  -- Show that balls with centers in `highDensityTiles` covers `G‚ÇÅ`.
  let ùìë : Finset (ùîì X) := highDensityTiles.toFinset
  have : (G‚ÇÅ : Set X) ‚äÜ ‚ãÉ p ‚àà ùìë, (ball (ùî† p) (r p)) := by
    refine fun x hx ‚Ü¶ mem_iUnion.2 ?_
    simp only [G‚ÇÅ, mem_iUnion, exists_prop] at hx
    rcases hx with ‚ü®p, hp, xp‚ü©
    use p
    simp only [mem_iUnion, exists_prop, ùìë, mem_toFinset]
    refine ‚ü®hp, ?_‚ü©
    suffices (ùìò p : Set X) ‚äÜ ball (ùî† p) (r p) from this xp
    apply Grid_subset_ball.trans ‚àò ball_subset_ball
    convert (hr hp).1.le
    simp [r, hp]
  apply (OuterMeasureClass.measure_mono volume this).trans
  -- Apply `measure_biUnion_le_lintegral` to `u := F.indicator 1` to bound the volume of ‚ãÉ ùìë.
  let u := F.indicator (1 : X ‚Üí ‚Ñù‚â•0‚àû)
  have h2u : ‚àÄ p ‚àà ùìë, K * volume (Metric.ball (ùî† p) (r p)) ‚â§
      ‚à´‚Åª (x : X) in ball (ùî† p) (r p), u x := by
    intro p h
    simp_rw [ùìë, mem_toFinset] at h
    simpa [u, lintegral_indicator, Measure.restrict_apply, measurableSet_F, r, h] using (hr h).2.le
  have ineq := ùìë.measure_biUnion_le_lintegral (A := defaultA a) K u h2u
  simp only [u, lintegral_indicator, measurableSet_F, Pi.one_apply, lintegral_const,
    MeasurableSet.univ, Measure.restrict_apply, univ_inter, one_mul] at ineq
  rw [‚Üê mul_le_mul_left K0.ne.symm K_ne_top]
  apply ineq.trans_eq
  -- Prove that the desired bound for the volume of ‚ãÉ ùìë is equal to the bound proven above.
  simp_rw [defaultA, Nat.cast_pow, Nat.cast_ofNat, ENNReal.coe_pow, coe_ofNat, K]
  have : (volume G)‚Åª¬π * (2 ^ (2 * a + 5) * volume F) * (2 ^ (-5 : ‚Ñ§) * volume G) =
      (2 ^ (2 * a + 5) * 2 ^ (-5 : ‚Ñ§)) * volume F * ((volume G)‚Åª¬π * volume G) := by ring
  rw [ENNReal.div_eq_inv_mul, ‚Üê mul_one (_ * _), this]
  congr
  ¬∑ have h : (2 : ‚Ñù‚â•0‚àû) ^ (2 * a + 5) = (2 : ‚Ñù‚â•0‚àû) ^ (2 * a + 5 : ‚Ñ§) := by norm_cast
    rw [h, ‚Üê ENNReal.zpow_add (NeZero.ne 2) two_ne_top, add_neg_cancel_right, ‚Üê pow_mul, mul_comm 2]
    norm_cast
  ¬∑ exact ENNReal.inv_mul_cancel hG vol_G_ne_top |>.symm

lemma first_exception : volume (G‚ÇÅ : Set X) ‚â§ 2 ^ (- 4 : ‚Ñ§) * volume G := by
  calc volume G‚ÇÅ ‚â§ 2 ^ (-5 : ‚Ñ§) * volume G := first_exception'
    _ ‚â§ 2 ^ (-4 : ‚Ñ§) * volume G := by gcongr <;> norm_num

end first_exception

/-- Lemma 5.2.2 -/
lemma dense_cover (k : ‚Ñï) : volume (‚ãÉ i ‚àà ùìí (X := X) k, (i : Set X)) ‚â§ 2 ^ (k + 1) * volume G := by
  let M : Finset (Grid X) :=
    { j | 2 ^ (-(k + 1 : ‚Ñï) : ‚Ñ§) * volume (j : Set X) < volume (G ‚à© j) }
  have s‚ÇÅ : ‚ãÉ i ‚àà ùìí (X := X) k, (i : Set X) ‚äÜ ‚ãÉ i ‚àà M, ‚Üëi := by
    simp_rw [ùìí]; intro q mq; rw [mem_iUnion‚ÇÇ] at mq ‚ä¢; obtain ‚ü®i, hi, mi‚ü© := mq
    rw [auxùìí, mem_diff, mem_setOf] at hi; obtain ‚ü®j, hj, mj‚ü© := hi.1
    use j, ?_, mem_of_mem_of_subset mi hj.1
    simpa [M] using mj
  let M' := Grid.maxCubes M
  have s‚ÇÇ : ‚ãÉ i ‚àà M, (i : Set X) ‚äÜ ‚ãÉ i ‚àà M', ‚Üëi := iUnion‚ÇÇ_mono' fun i mi ‚Ü¶ by
    obtain ‚ü®j, mj, hj‚ü© := Grid.exists_maximal_supercube mi; use j, mj, hj.1
  calc
    _ ‚â§ volume (‚ãÉ i ‚àà M', (i : Set X)) := measure_mono (s‚ÇÅ.trans s‚ÇÇ)
    _ ‚â§ ‚àë i ‚àà M', volume (i : Set X) := measure_biUnion_finset_le M' _
    _ ‚â§ 2 ^ (k + 1) * ‚àë j ‚àà M', volume (G ‚à© j) := by
      rw [Finset.mul_sum]; refine Finset.sum_le_sum fun i hi ‚Ü¶ ?_
      replace hi : i ‚àà M := Finset.mem_of_subset (Finset.filter_subset _ M) hi
      simp_rw [M, Finset.mem_filter, Finset.mem_univ, true_and] at hi
      rw [‚Üê ENNReal.rpow_intCast, show (-(k + 1 : ‚Ñï) : ‚Ñ§) = (-(k + 1) : ‚Ñù) by simp,
        mul_comm, ‚Üê ENNReal.lt_div_iff_mul_lt (by simp) (by simp), ENNReal.div_eq_inv_mul,
        ‚Üê ENNReal.rpow_neg, neg_neg] at hi
      exact_mod_cast hi.le
    _ = 2 ^ (k + 1) * volume (‚ãÉ j ‚àà M', G ‚à© j) := by
      congr; refine (measure_biUnion_finset (fun _ mi _ mj hn ‚Ü¶ ?_) (fun _ _ ‚Ü¶ ?_)).symm
      ¬∑ exact ((Grid.maxCubes_pairwiseDisjoint mi mj hn).inter_right' G).inter_left' G
      ¬∑ exact measurableSet_G.inter coeGrid_measurable
    _ ‚â§ _ := mul_le_mul_left' (measure_mono (iUnion‚ÇÇ_subset fun _ _ ‚Ü¶ inter_subset_left)) _

/-- Lemma 5.2.3 -/
lemma pairwiseDisjoint_E1 : (ùîê (X := X) k n).PairwiseDisjoint E‚ÇÅ := fun p mp p' mp' h ‚Ü¶ by
  change Disjoint _ _
  contrapose! h
  have hùìò := (Disjoint.mono (E‚ÇÅ_subset p) (E‚ÇÅ_subset p')).mt h
  wlog hs : s (ùìò p') ‚â§ s (ùìò p) generalizing p p'
  ¬∑ rw [disjoint_comm] at h hùìò; rw [not_le] at hs; rw [this p' mp' p mp h hùìò hs.le]
  obtain ‚ü®x, ‚ü®-, mxp‚ü©, ‚ü®-, mxp'‚ü©‚ü© := not_disjoint_iff.mp h
  rw [mem_preimage] at mxp mxp'
  have lùìò := Grid.le_def.mpr ‚ü®(fundamental_dyadic hs).resolve_right (disjoint_comm.not.mpr hùìò), hs‚ü©
  have sŒ© := (relative_fundamental_dyadic lùìò).resolve_left <| not_disjoint_iff.mpr ‚ü®_, mxp', mxp‚ü©
  rw [ùîê, mem_setOf] at mp mp'
  exact mp'.eq_of_ge mp.prop ‚ü®lùìò, sŒ©‚ü©

/-- Lemma 5.2.4 -/
lemma dyadic_union (hx : x ‚àà setA l k n) : ‚àÉ i : Grid X, x ‚àà i ‚àß (i : Set X) ‚äÜ setA l k n := by
  let M : Finset (ùîì X) := { p | p ‚àà ùîê k n ‚àß x ‚àà ùìò p }
  simp_rw [setA, mem_setOf, stackSize, indicator_apply, Pi.one_apply, Finset.sum_boole, Nat.cast_id,
    Finset.filter_filter] at hx ‚ä¢
  obtain ‚ü®b, memb, minb‚ü© := M.exists_min_image ùî∞ (Finset.card_pos.mp (zero_le'.trans_lt hx))
  simp_rw [M, Finset.mem_filter, Finset.mem_univ, true_and] at memb minb
  use ùìò b, memb.2; intro c mc; rw [mem_setOf]
  refine hx.trans_le (Finset.card_le_card fun y hy ‚Ü¶ ?_)
  simp_rw [Finset.mem_filter, Finset.mem_univ, true_and] at hy ‚ä¢
  exact ‚ü®hy.1, mem_of_mem_of_subset mc (le_of_mem_of_mem (minb y hy) memb.2 hy.2).1‚ü©

lemma iUnion_MsetA_eq_setA : ‚ãÉ i ‚àà MsetA (X := X) l k n, ‚Üëi = setA (X := X) l k n := by
  ext x
  simp_rw [mem_iUnion‚ÇÇ, MsetA, Finset.mem_filter, Finset.mem_univ, true_and]
  constructor <;> intro mx
  ¬∑ obtain ‚ü®j, mj, lj‚ü© := mx; exact mem_of_mem_of_subset lj mj
  ¬∑ obtain ‚ü®j, mj, lj‚ü© := dyadic_union mx; use j, lj, mj

/-- Equation (5.2.7) in the proof of Lemma 5.2.5. -/
lemma john_nirenberg_aux1 {L : Grid X} (mL : L ‚àà Grid.maxCubes (MsetA l k n))
    (mx : x ‚àà setA (l + 1) k n) (mx‚ÇÇ : x ‚àà L) : 2 ^ (n + 1) ‚â§
    stackSize { q ‚àà ùîê (X := X) k n | ùìò q ‚â§ L} x := by
  -- LHS of equation (5.2.6) is strictly greater than `(l + 1) * 2 ^ (n + 1)`
  rw [setA, mem_setOf, ‚Üê stackSize_setOf_add_stackSize_setOf_not (P := fun p' ‚Ü¶ ùìò p' ‚â§ L)] at mx
  -- Rewrite second sum of RHS of (5.2.6) so that it sums over tiles `q` satisfying `L < ùìò q`
  nth_rw 2 [‚Üê stackSize_setOf_add_stackSize_setOf_not (P := fun p' ‚Ü¶ Disjoint (ùìò p' : Set X) L)]
    at mx
  simp_rw [mem_setOf_eq, and_assoc] at mx
  have mid0 : stackSize { p' ‚àà ùîê k n | ¬¨ùìò p' ‚â§ L ‚àß Disjoint (ùìò p' : Set X) L} x = 0 := by
    simp_rw [stackSize, Finset.sum_eq_zero_iff, indicator_apply_eq_zero,
      show ¬¨(1 : X ‚Üí ‚Ñï) x = 0 by simp, imp_false, Finset.mem_filter, Finset.mem_univ, true_and]
    rintro y ‚ü®-, -, dj2‚ü©
    exact disjoint_right.mp dj2 mx‚ÇÇ
  rw [mid0, zero_add] at mx
  have req :
      { p' | p' ‚àà ùîê k n ‚àß ¬¨ùìò p' ‚â§ L ‚àß ¬¨Disjoint (ùìò p' : Set X) L } =
      { p' | p' ‚àà ùîê k n ‚àß L < ùìò p' } := by
    ext q
    simp_rw [mem_setOf_eq, and_congr_right_iff]
    refine fun _ ‚Ü¶ ‚ü®fun h ‚Ü¶ ?_, ?_‚ü©
    ¬∑ apply lt_of_le_of_ne <| (le_or_ge_or_disjoint.resolve_left h.1).resolve_right h.2
      by_contra k; subst k; simp at h
    ¬∑ rw [Grid.lt_def, Grid.le_def, not_and_or, not_le]
      exact fun h ‚Ü¶ ‚ü®Or.inr h.2, not_disjoint_iff.mpr ‚ü®x, mem_of_mem_of_subset mx‚ÇÇ h.1, mx‚ÇÇ‚ü©‚ü©
  rw [req] at mx
  -- The new second sum of RHS is at most `l * 2 ^ (n + 1)`
  set Q‚ÇÅ := { q ‚àà ùîê (X := X) k n | ùìò q ‚â§ L }
  set Q‚ÇÇ := { q ‚àà ùîê (X := X) k n | L < ùìò q }
  have Ql : stackSize Q‚ÇÇ x ‚â§ l * 2 ^ (n + 1) := by
    by_cases h : IsMax L
    ¬∑ rw [Grid.isMax_iff] at h
      have : Q‚ÇÇ = ‚àÖ := by
        ext y; simp_rw [Q‚ÇÇ, mem_setOf_eq, Set.not_mem_empty, iff_false, not_and, h, Grid.lt_def,
          not_and_or, not_lt]
        exact fun _ ‚Ü¶ Or.inr (Grid.le_topCube).2
      simp [stackSize, this]
    have Lslq : ‚àÄ q ‚àà Q‚ÇÇ, L.succ ‚â§ ùìò q := fun q mq ‚Ü¶ Grid.succ_le_of_lt mq.2
    have Lout : ¬¨(L.succ : Set X) ‚äÜ setA (X := X) l k n := by
      by_contra! hs
      rw [Grid.maxCubes, Finset.mem_filter] at mL
      apply absurd _ h
      exact Grid.max_of_le_succ
        (mL.2 L.succ (Finset.mem_filter.mpr ‚ü®Finset.mem_univ _, hs‚ü©) Grid.le_succ).symm.le
    rw [not_subset_iff_exists_mem_not_mem] at Lout
    obtain ‚ü®x', mx', nx'‚ü© := Lout
    calc
      _ = stackSize Q‚ÇÇ x' := by
        refine stackSize_congr fun q mq ‚Ü¶ ?_
        simp_rw [mem_of_mem_of_subset mx‚ÇÇ (Grid.le_succ.trans (Lslq q mq)).1,
          mem_of_mem_of_subset mx' (Lslq q mq).1]
      _ ‚â§ stackSize (ùîê (X := X) k n) x' := by
        refine stackSize_mono <| sep_subset ..
      _ ‚â§ l * 2 ^ (n + 1) := by rwa [setA, mem_setOf_eq, not_lt] at nx'
  -- so the (unchanged) first sum of RHS is at least `2 ^ (n + 1)`
  rw [add_one_mul] at mx; omega

/-- Equation (5.2.11) in the proof of Lemma 5.2.5. -/
lemma john_nirenberg_aux2 {L : Grid X} (mL : L ‚àà Grid.maxCubes (MsetA l k n)) :
    2 * volume (setA (X := X) (l + 1) k n ‚à© L) ‚â§ volume (L : Set X) := by
  let Q‚ÇÅ : Finset (ùîì X) := { q | q ‚àà ùîê (X := X) k n ‚àß ùìò q ‚â§ L }
  have Q‚ÇÅm : ‚àÄ i ‚àà Q‚ÇÅ, Measurable ((ùìò i : Set X).indicator (1 : X ‚Üí ‚Ñù‚â•0‚àû)) := fun _ _ ‚Ü¶
    measurable_one.indicator coeGrid_measurable
  have e528 : ‚àë q ‚àà Q‚ÇÅ, volume (E‚ÇÅ q) ‚â§ volume (L : Set X) :=
    calc
      _ = volume (‚ãÉ q ‚àà Q‚ÇÅ, E‚ÇÅ q) := by
        refine (measure_biUnion_finset (fun p mp q mq hn ‚Ü¶ ?_) (fun _ _ ‚Ü¶ ?_)).symm
        ¬∑ simp_rw [Finset.mem_coe, Q‚ÇÅ, Finset.mem_filter] at mp mq
          exact pairwiseDisjoint_E1 mp.2.1 mq.2.1 hn
        ¬∑ exact (coeGrid_measurable.inter measurableSet_G).inter
            (SimpleFunc.measurableSet_preimage ..)
      _ ‚â§ volume (‚ãÉ q ‚àà Q‚ÇÅ, (ùìò q : Set X)) := measure_mono (iUnion‚ÇÇ_mono fun q _ ‚Ü¶ E‚ÇÅ_subset q)
      _ ‚â§ _ := by
        apply measure_mono (iUnion‚ÇÇ_subset fun q mq ‚Ü¶ ?_)
        simp_rw [Q‚ÇÅ, Finset.mem_filter] at mq; exact mq.2.2.1
  have e529 : ‚àë q ‚àà Q‚ÇÅ, volume (ùìò q : Set X) ‚â§ 2 ^ n * volume (L : Set X) :=
    calc
      _ ‚â§ ‚àë q ‚àà Q‚ÇÅ, 2 ^ n * volume (E‚ÇÅ q) := by
        refine Finset.sum_le_sum fun q mq ‚Ü¶ ?_
        simp_rw [Q‚ÇÅ, Finset.mem_filter, ùîê, mem_setOf, maximal_iff, auxùîê, mem_setOf] at mq
        replace mq := mq.2.1.1.2
        rw [‚Üê ENNReal.rpow_intCast, show (-(n : ‚Ñï) : ‚Ñ§) = (-n : ‚Ñù) by simp, mul_comm,
          ‚Üê ENNReal.lt_div_iff_mul_lt (by simp) (by simp), ENNReal.div_eq_inv_mul,
          ‚Üê ENNReal.rpow_neg, neg_neg] at mq
        exact_mod_cast mq.le
      _ ‚â§ _ := by rw [‚Üê Finset.mul_sum]; exact mul_le_mul_left' e528 _
  rw [‚Üê ENNReal.mul_le_mul_left (a := 2 ^ n) (by simp) (by simp), ‚Üê mul_assoc, ‚Üê pow_succ]
  calc
    _ = ‚à´‚Åª x in setA (X := X) (l + 1) k n ‚à© L, 2 ^ (n + 1) := (setLIntegral_const _ _).symm
    _ ‚â§ ‚à´‚Åª x in setA (X := X) (l + 1) k n ‚à© L, ‚àë q ‚àà Q‚ÇÅ, (ùìò q : Set X).indicator 1 x := by
      refine setLIntegral_mono (Finset.measurable_sum Q‚ÇÅ Q‚ÇÅm) fun x ‚ü®mx, mx‚ÇÇ‚ü© ‚Ü¶ ?_
      have : 2 ^ (n + 1) ‚â§ ‚àë q ‚àà Q‚ÇÅ, (ùìò q : Set X).indicator 1 x := by
        convert john_nirenberg_aux1 mL mx mx‚ÇÇ
        simp_rw [stackSize, Q‚ÇÅ, mem_setOf_eq]
        congr
      have lcast : (2 : ‚Ñù‚â•0‚àû) ^ (n + 1) = ((2 ^ (n + 1) : ‚Ñï) : ‚Ñù).toNNReal := by
        rw [toNNReal_coe_nat, ENNReal.coe_natCast]; norm_cast
      have rcast : ‚àë q ‚àà Q‚ÇÅ, (ùìò q : Set X).indicator (1 : X ‚Üí ‚Ñù‚â•0‚àû) x =
          (((‚àë q ‚àà Q‚ÇÅ, (ùìò q : Set X).indicator (1 : X ‚Üí ‚Ñï) x) : ‚Ñï) : ‚Ñù).toNNReal := by
        rw [toNNReal_coe_nat, ENNReal.coe_natCast, Nat.cast_sum]; congr!; simp [indicator]
      rw [lcast, rcast, ENNReal.coe_le_coe]
      exact Real.toNNReal_le_toNNReal (Nat.cast_le.mpr this)
    _ ‚â§ ‚à´‚Åª x, ‚àë q ‚àà Q‚ÇÅ, (ùìò q : Set X).indicator 1 x := setLIntegral_le_lintegral _ _
    _ = ‚àë q ‚àà Q‚ÇÅ, ‚à´‚Åª x, (ùìò q : Set X).indicator 1 x := lintegral_finset_sum _ Q‚ÇÅm
    _ = ‚àë q ‚àà Q‚ÇÅ, volume (ùìò q : Set X) := by
      congr!; exact lintegral_indicator_one coeGrid_measurable
    _ ‚â§ _ := e529

/-- Lemma 5.2.5 -/
lemma john_nirenberg : volume (setA (X := X) l k n) ‚â§ 2 ^ (k + 1 - l : ‚Ñ§) * volume G := by
  induction l with
  | zero =>
    calc
      _ ‚â§ volume (‚ãÉ i ‚àà ùìí (X := X) k, (i : Set X)) := measure_mono setA_subset_iUnion_ùìí
      _ ‚â§ _ := by
        rw [‚Üê ENNReal.rpow_intCast, show (k + 1 - (0 : ‚Ñï) : ‚Ñ§) = (k + 1 : ‚Ñù) by simp]
        exact_mod_cast dense_cover k
  | succ l ih =>
    suffices 2 * volume (setA (X := X) (l + 1) k n) ‚â§ volume (setA (X := X) l k n) by
      rw [‚Üê ENNReal.mul_le_mul_left (a := 2) (by simp) (by simp), ‚Üê mul_assoc]; apply this.trans
      convert ih using 2; nth_rw 1 [‚Üê zpow_one 2, ‚Üê ENNReal.zpow_add (by simp) (by simp)]
      congr 1; omega
    calc
      _ = 2 * ‚àë L ‚àà Grid.maxCubes (MsetA (X := X) l k n),
          volume (setA (X := X) (l + 1) k n ‚à© L) := by
        congr; rw [‚Üê measure_biUnion_finset]
        ¬∑ congr with x; constructor <;> intro h
          ¬∑ obtain ‚ü®L', mL'‚ü© := dyadic_union h
            have := mem_of_mem_of_subset mL'.1 (mL'.2.trans setA_subset_setA)
            rw [‚Üê iUnion_MsetA_eq_setA, mem_iUnion‚ÇÇ] at this
            obtain ‚ü®M, mM, lM‚ü© := this
            obtain ‚ü®L, mL, lL‚ü© := Grid.exists_maximal_supercube mM
            rw [mem_iUnion‚ÇÇ]; use L, mL
            exact ‚ü®mem_of_mem_of_subset mL'.1 mL'.2, mem_of_mem_of_subset lM lL.1‚ü©
          ¬∑ rw [mem_iUnion‚ÇÇ] at h; obtain ‚ü®i, _, mi‚ÇÇ‚ü© := h; exact mem_of_mem_inter_left mi‚ÇÇ
        ¬∑ exact fun i mi j mj hn ‚Ü¶
            ((Grid.maxCubes_pairwiseDisjoint mi mj hn).inter_left' _).inter_right' _
        ¬∑ exact fun _ _ ‚Ü¶ measurable_setA.inter coeGrid_measurable
      _ ‚â§ ‚àë L ‚àà Grid.maxCubes (MsetA (X := X) l k n), volume (L : Set X) := by
        rw [Finset.mul_sum]; exact Finset.sum_le_sum fun L mL ‚Ü¶ john_nirenberg_aux2 mL
      _ = _ := by
        rw [‚Üê measure_biUnion_finset Grid.maxCubes_pairwiseDisjoint (fun _ _ ‚Ü¶ coeGrid_measurable)]
        congr with x; constructor <;> intro h
        ¬∑ rw [mem_iUnion‚ÇÇ] at h; obtain ‚ü®i, mi‚ÇÅ, mi‚ÇÇ‚ü© := h
          simp only [Grid.maxCubes, Finset.mem_filter, MsetA, Finset.mem_univ, true_and] at mi‚ÇÅ
          exact mem_of_mem_of_subset mi‚ÇÇ mi‚ÇÅ.1
        ¬∑ obtain ‚ü®L', mL'‚ü© := dyadic_union h
          have := mem_of_mem_of_subset mL'.1 mL'.2
          rw [‚Üê iUnion_MsetA_eq_setA, mem_iUnion‚ÇÇ] at this
          obtain ‚ü®M, mM, lM‚ü© := this
          obtain ‚ü®L, mL, lL‚ü© := Grid.exists_maximal_supercube mM
          rw [mem_iUnion‚ÇÇ]; use L, mL, mem_of_mem_of_subset lM lL.1

/-- Lemma 5.2.6 -/
lemma second_exception : volume (G‚ÇÇ (X := X)) ‚â§ 2 ^ (-2 : ‚Ñ§) * volume G :=
  calc
    _ ‚â§ ‚àë' (n : ‚Ñï), volume (‚ãÉ (k ‚â§ n), setA (X := X) (2 * n + 6) k n) := measure_iUnion_le _
    _ = ‚àë' (n : ‚Ñï), volume (‚ãÉ (k : ‚Ñï), if k ‚â§ n then setA (X := X) (2 * n + 6) k n else ‚àÖ) := by
      congr!; exact iUnion_eq_if _
    _ ‚â§ ‚àë' (n : ‚Ñï) (k : ‚Ñï), volume (if k ‚â§ n then setA (X := X) (2 * n + 6) k n else ‚àÖ) := by
      gcongr; exact measure_iUnion_le _
    _ = ‚àë' (k : ‚Ñï) (n : ‚Ñï), if k ‚â§ n then volume (setA (X := X) (2 * n + 6) k n) else 0 := by
      rw [ENNReal.tsum_comm]; congr!; split_ifs <;> simp
    _ ‚â§ ‚àë' (k : ‚Ñï) (n : ‚Ñï), if k ‚â§ n then 2 ^ (k - 5 - 2 * n : ‚Ñ§) * volume G else 0 := by
      gcongr; split_ifs
      ¬∑ convert john_nirenberg using 3; omega
      ¬∑ rfl
    _ = ‚àë' (k : ‚Ñï), 2 ^ (-k - 5 : ‚Ñ§) * volume G * ‚àë' (n' : ‚Ñï), 2 ^ (- 2 * n' : ‚Ñ§) := by
      congr with k -- n' = n - k - 1; n = n' + k + 1
      have rearr : ‚àÄ n : ‚Ñï, (k - 5 - 2 * n : ‚Ñ§) = (-k - 5 + (-2 * (n - k)) : ‚Ñ§) := by omega
      conv_lhs =>
        enter [1, n]
        rw [rearr, ENNReal.zpow_add (by simp) (by simp), ‚Üê mul_rotate,
          ‚Üê mul_zero (volume G * 2 ^ (-k - 5 : ‚Ñ§)), ‚Üê mul_ite]
      rw [ENNReal.tsum_mul_left, mul_comm (volume G)]; congr 1
      exact tsum_geometric_ite_eq_tsum_geometric
    _ ‚â§ ‚àë' (k : ‚Ñï), 2 ^ (-k - 5 : ‚Ñ§) * volume G * 2 ^ (2 : ‚Ñ§) := by
      gcongr
      rw [ENNReal.sum_geometric_two_pow_neg_two, zpow_two]; norm_num
      rw [‚Üê ENNReal.coe_ofNat, ‚Üê Real.toNNReal_ofNat, ENNReal.coe_le_coe]; norm_num
    _ = 2 ^ (-4 : ‚Ñ§) * volume G * 2 ^ (2 : ‚Ñ§) := by
      simp_rw [mul_assoc, ENNReal.tsum_mul_right]; congr
      conv_lhs => enter [1, k]; rw [sub_eq_add_neg, ENNReal.zpow_add (by simp) (by simp)]
      nth_rw 1 [ENNReal.tsum_mul_right, ENNReal.sum_geometric_two_pow_neg_one,
        ‚Üê zpow_one 2, ‚Üê ENNReal.zpow_add] <;> simp
    _ = _ := by rw [‚Üê mul_rotate, ‚Üê ENNReal.zpow_add] <;> simp

section TopTiles

/-- The volume of a "layer" in the key function of Lemma 5.2.7. -/
def layervol (k n : ‚Ñï) (t : ‚Ñù) : ‚Ñù‚â•0‚àû :=
  volume {x | t ‚â§ ‚àë m ‚àà {p | p ‚àà ùîê (X := X) k n },
    (ùìò m : Set X).indicator (1 : X ‚Üí ‚Ñù) x}

lemma indicator_sum_eq_natCast {s : Finset (ùîì X)} :
    ‚àë m ‚àà s, (ùìò m : Set X).indicator (1 : X ‚Üí ‚Ñù) x =
    Nat.cast (‚àë m ‚àà s, (ùìò m : Set X).indicator (1 : X ‚Üí ‚Ñï) x) := by
  push_cast; congr!; simp [indicator]

lemma layervol_eq_zero_of_lt {t : ‚Ñù} (ht : (ùîê (X := X) k n).toFinset.card < t) :
    layervol (X := X) k n t = 0 := by
  rw [layervol, measure_zero_iff_ae_nmem]
  refine ae_of_all volume fun x ‚Ü¶ ?_; rw [mem_setOf, not_le]
  calc
    _ ‚â§ ((ùîê (X := X) k n).toFinset.card : ‚Ñù) := by
      simp_rw [indicator_sum_eq_natCast, Nat.cast_le, indicator_apply, Pi.one_apply,
        Finset.sum_boole, Nat.cast_id, filter_mem_univ_eq_toFinset]
      exact Finset.card_le_card (Finset.filter_subset ..)
    _ < _ := ht

lemma lintegral_Ioc_layervol_one {l : ‚Ñï} :
    ‚à´‚Åª t in Ioc (l : ‚Ñù) (l + 1), layervol (X := X) k n t = layervol (X := X) k n (l + 1) :=
  calc
    _ = ‚à´‚Åª t in Ioc (l : ‚Ñù) (l + 1), layervol (X := X) k n (l + 1) := by
      refine setLIntegral_congr_fun measurableSet_Ioc (ae_of_all volume fun t mt ‚Ü¶ ?_)
      unfold layervol; congr with x; simp_rw [mem_setOf]; constructor <;> intro h
      ¬∑ rw [indicator_sum_eq_natCast, ‚Üê Nat.cast_one, ‚Üê Nat.cast_add, Nat.cast_le]
        rw [indicator_sum_eq_natCast, ‚Üê Nat.ceil_le] at h; convert h; symm
        rwa [Nat.ceil_eq_iff (by omega), add_tsub_cancel_right, Nat.cast_add, Nat.cast_one]
      ¬∑ exact mt.2.trans h
    _ = layervol k n (l + 1) * volume (Ioc (l : ‚Ñù) (l + 1)) := setLIntegral_const ..
    _ = _ := by rw [Real.volume_Ioc, add_sub_cancel_left, ENNReal.ofReal_one, mul_one]

lemma antitone_layervol : Antitone fun t ‚Ü¶ layervol (X := X) k n t := fun i j h ‚Ü¶ by
  unfold layervol; exact measure_mono fun x hx ‚Ü¶ h.trans hx

lemma lintegral_Ioc_layervol_le {a b : ‚Ñï} : ‚à´‚Åª t in Ioc (a : ‚Ñù) b, layervol (X := X) k n t ‚â§
    (b - a : ‚Ñï) * layervol (X := X) k n (a + 1) := by
  calc
    _ = ‚àë l ‚àà Finset.Ico a b, ‚à´‚Åª t in Ioc (l : ‚Ñù) (l + 1), layervol (X := X) k n t := by
      nth_rw 1 [‚Üê mul_one (a : ‚Ñù), ‚Üê mul_one (b : ‚Ñù)]
      convert lintegral_Ioc_partition zero_le_one using 4; simp
    _ = ‚àë l ‚àà Finset.Ico a b, layervol (X := X) k n (l + 1) := by
      congr! 2; exact lintegral_Ioc_layervol_one
    _ ‚â§ ‚àë l ‚àà Finset.Ico a b, layervol (X := X) k n (a + 1) :=
      Finset.sum_le_sum fun l ml ‚Ü¶ antitone_layervol (by simp_all)
    _ = _ := by rw [Finset.sum_const, Nat.card_Ico, nsmul_eq_mul]

lemma top_tiles_aux : ‚àë m ‚àà { p | p ‚àà ùîê (X := X) k n }, volume (ùìò m : Set X) =
    ‚à´‚Åª t in Ioc 0 ((ùîê (X := X) k n).toFinset.card * 2 ^ (n + 1) : ‚Ñù), layervol (X := X) k n t := by
  set M := ùîê (X := X) k n
  set Mc := M.toFinset.card
  calc
    _ = ‚àë m ‚àà { p | p ‚àà M }, ‚à´‚Åª x, (ùìò m : Set X).indicator 1 x := by
      congr! with m; exact (lintegral_indicator_one coeGrid_measurable).symm
    _ = ‚à´‚Åª x, ‚àë m ‚àà { p | p ‚àà M }, (ùìò m : Set X).indicator 1 x :=
      (lintegral_finset_sum _ fun _ _ ‚Ü¶ measurable_one.indicator coeGrid_measurable).symm
    _ = ‚à´‚Åª x, ENNReal.ofReal (‚àë m ‚àà { p | p ‚àà M }, (ùìò m : Set X).indicator 1 x) := by
      congr! 2 with x; rw [ENNReal.ofReal_sum_of_nonneg]
      ¬∑ congr!; unfold indicator; split_ifs <;> simp
      ¬∑ exact fun _ _ ‚Ü¶ indicator_nonneg (fun _ _ ‚Ü¶ by simp) _
    _ = ‚à´‚Åª t in Ioi 0, layervol k n t := by
      apply lintegral_eq_lintegral_meas_le
      ¬∑ exact ae_of_all volume fun _ ‚Ü¶
          Finset.sum_nonneg' fun _ ‚Ü¶ indicator_nonneg (fun _ _ ‚Ü¶ by simp) _
      ¬∑ exact Measurable.aemeasurable <|
          Finset.measurable_sum _ (fun _ _ ‚Ü¶ measurable_one.indicator coeGrid_measurable)
    _ = _ := by
      have nn : 0 ‚â§ (Mc * 2 ^ (n + 1) : ‚Ñù) := by positivity
      rw [‚Üê Ioc_union_Ioi_eq_Ioi nn, lintegral_union measurableSet_Ioi Ioc_disjoint_Ioi_same]
      nth_rw 3 [‚Üê add_zero (lintegral ..)]; congr 1
      have cgr : ‚à´‚Åª (t : ‚Ñù) in Ioi (Mc * 2 ^ (n + 1) : ‚Ñù), layervol (X := X) k n t =
          ‚à´‚Åª _ in Ioi (Mc * 2 ^ (n + 1) : ‚Ñù), 0 := by
        refine setLIntegral_congr_fun measurableSet_Ioi (ae_of_all volume fun t mt ‚Ü¶
          layervol_eq_zero_of_lt (lt_of_le_of_lt ?_ mt))
        exact_mod_cast Nat.le_mul_of_pos_right Mc (by positivity)
      rw [cgr, lintegral_zero]

/-- Lemma 5.2.7 -/
lemma top_tiles : ‚àë m ‚àà { p | p ‚àà ùîê (X := X) k n }, volume (ùìò m : Set X) ‚â§
    2 ^ (n + k + 3) * volume G := by
  set M := ùîê (X := X) k n
  let Mc := M.toFinset.card
  calc
    _ = ‚à´‚Åª t in Ioc 0 (Mc * 2 ^ (n + 1) : ‚Ñù), layervol (X := X) k n t := top_tiles_aux
    _ = ‚àë l ‚àà Finset.range Mc,
        ‚à´‚Åª t in Ioc ((l : ‚Ñù) * 2 ^ (n + 1)) ((l + 1 : ‚Ñï) * 2 ^ (n + 1)),
          layervol (X := X) k n t := by
      rw [Finset.range_eq_Ico, show (0 : ‚Ñù) = (0 : ‚Ñï) * 2 ^ (n + 1) by simp]
      exact lintegral_Ioc_partition (by positivity)
    _ ‚â§ ‚àë l ‚àà Finset.range Mc,
        (((l + 1) * 2 ^ (n + 1) - l * 2 ^ (n + 1) : ‚Ñï)) *
          layervol (X := X) k n ((l * 2 ^ (n + 1) : ‚Ñï) + 1) := by
      convert Finset.sum_le_sum fun _ _ ‚Ü¶ lintegral_Ioc_layervol_le <;> simp
    _ = 2 ^ (n + 1) * ‚àë l ‚àà Finset.range Mc, layervol (X := X) k n (l * 2 ^ (n + 1) + 1 : ‚Ñï) := by
      rw [Finset.mul_sum]; congr! 2
      ¬∑ rw [‚Üê Nat.mul_sub_right_distrib]; simp
      ¬∑ congr; simp
    _ = 2 ^ (n + 1) * ‚àë l ‚àà Finset.range Mc, volume (setA (X := X) l k n) := by
      unfold layervol setA stackSize; congr! 3; ext x
      rw [mem_setOf, mem_setOf, indicator_sum_eq_natCast, Nat.cast_le]
      exact Nat.add_one_le_iff
    _ ‚â§ 2 ^ (n + 1) * ‚àë l ‚àà Finset.range Mc, 2 ^ (k + 1 - l : ‚Ñ§) * volume G :=
      mul_le_mul_left' (Finset.sum_le_sum fun _ _ ‚Ü¶ john_nirenberg) _
    _ ‚â§ 2 ^ (n + 1) * ‚àë' (l : ‚Ñï), 2 ^ (k + 1 - l : ‚Ñ§) * volume G :=
      mul_le_mul_left' (ENNReal.sum_le_tsum _) _
    _ = 2 ^ (n + 1) * (volume G * 2 ^ (k + 1) * 2) := by
      conv_lhs =>
        enter [2, 1, l]
        rw [sub_eq_add_neg, ENNReal.zpow_add (by simp) (by simp), ‚Üê mul_rotate]
      rw [ENNReal.tsum_mul_left]; congr 3
      ¬∑ norm_cast
      ¬∑ exact ENNReal.sum_geometric_two_pow_neg_one
    _ = _ := by
      nth_rw 3 [‚Üê pow_one 2]
      rw [mul_rotate, ‚Üê pow_add, ‚Üê mul_assoc, ‚Üê pow_add,
        show n + 1 + (k + 1 + 1) = n + k + 3 by omega]

end TopTiles

section ùîò
-- Definition of function `ùîò(m)` used in the proof of Lemma 5.2.8, and some properties of `ùîò(m)`

open Finset

variable (k) (n) (j) (x)
private def ùîò (m : ùîì X) := (ùîò‚ÇÅ k n j).toFinset.filter (fun u ‚Ü¶ x ‚àà ùìò u ‚àß smul 100 u ‚â§ smul 1 m)

-- Ball that covers the image of `ùí¨`. Radius chosen for convenience with `BallsCoverBalls.pow_mul`
private def big_ball (m : ùîì X) (u : ùîì X) := ball_(u) (ùí¨ m) (2 ^ 9 * 0.2)

variable {k} {n} {j} {x}
variable {x : X} {m u u' u'' : ùîì X}
variable (hu : u ‚àà ùîò k n j x m) (hu' : u' ‚àà ùîò k n j x m) (hu'' : u'' ‚àà ùîò k n j x m)

include hu in
private lemma x_mem_ùìòu : x ‚àà (ùìò u) := by
  simp only [ùîò, mem_filter] at hu
  exact hu.2.1

include hu in
private lemma ùí¨m_mem_ball : ùí¨ m ‚àà ball_(u) (ùí¨ u) 100 := by
  simp only [ùîò, mem_filter, smul] at hu
  exact hu.2.2.2 (by simp)

include hu hu' in
private lemma ùìò_not_lt_ùìò : ¬¨ùìò u < ùìò u' := by
  intro h
  rw [Grid.lt_def] at h
  have ùí¨m_mem_inter := mem_inter (ùí¨m_mem_ball hu) (ùí¨m_mem_ball hu')
  simp only [ùîò, ùîò‚ÇÅ, Grid.lt_def, and_imp, toFinset_setOf, mem_filter] at hu
  exact not_disjoint_iff_nonempty_inter.2 (nonempty_of_mem ùí¨m_mem_inter) <| hu.1.2.2
    u' (mem_toFinset.mp (mem_filter.mp hu').1).1 h.1 h.2

include hu hu' in
private lemma ùìò_eq_ùìò : ùìò u = ùìò u' :=
  have not_disj := Set.not_disjoint_iff.mpr ‚ü®x, ‚ü®x_mem_ùìòu hu, x_mem_ùìòu hu'‚ü©‚ü©
  le_or_ge_or_disjoint.elim (fun h ‚Ü¶ (h.lt_or_eq).resolve_left (ùìò_not_lt_ùìò hu hu'))
    (fun h ‚Ü¶ ((h.resolve_right not_disj).lt_or_eq.resolve_left (ùìò_not_lt_ùìò hu' hu)).symm)

include hu hu' in
private lemma ball_eq_ball : ball_(u) = ball_(u') := by
  rw [ùî†, ùî∞, ùìò_eq_ùìò hu hu']

include hu hu' hu'' in
private lemma disjoint_balls (h : u' ‚â† u'') :
    Disjoint (ball_(u) (ùí¨ u') 0.2) (ball_(u) (ùí¨ u'') 0.2) := by
  nth_rewrite 1 [ball_eq_ball hu hu', ball_eq_ball hu hu'']
  convert cball_disjoint h (ùìò_eq_ùìò hu' hu'') using 2 <;> norm_num

include hu hu' in
private lemma mem_big_ball : ùí¨ u' ‚àà big_ball m u := by
  have : ùí¨ m ‚àà ball_(u) (ùí¨ u') 100 := ball_eq_ball hu hu' ‚ñ∏ ùí¨m_mem_ball hu'
  rw [@mem_ball_comm] at this
  simp only [big_ball, mem_ball] at this ‚ä¢
  exact this.trans (by norm_num)

include hu in
private lemma subset_big_ball (f : Œò X) (hf : f ‚àà (ùîò k n j x m).image ùí¨) : f ‚àà big_ball m u := by
  simp_rw [Finset.mem_image] at hf
  rcases hf with ‚ü®u', hu', rfl‚ü©
  exact mem_big_ball hu hu'

variable (m) (u : ùîì X) in
private lemma balls_cover_big_ball : CoveredByBalls (big_ball m u) (defaultA a ^ 9) 0.2 :=
  BallsCoverBalls.pow_mul (fun _ ‚Ü¶ CompatibleFunctions.ballsCoverBalls) (ùí¨ m)

private lemma ùí¨_injOn_ùîòm : InjOn ùí¨ (ùîò k n j x m).toSet :=
  fun _ hu _ hu' h ‚Ü¶ ùí¨_inj h (ùìò_eq_ùìò hu hu')

private lemma card_ùîòm_le : (ùîò k n j x m).card ‚â§ (defaultA a) ^ 9 := by
  by_cases h : ùîò k n j x m = ‚àÖ
  ¬∑ simp [h]
  have ‚ü®u, hu‚ü© := Finset.nonempty_of_ne_empty h
  let pm := instPseudoMetricSpaceWithFunctionDistance (x := ùî† u) (r := (D ^ ùî∞ u / 4))
  have ‚ü®ùìë, ùìë_card_le, ùìë_cover‚ü© := balls_cover_big_ball m u
  let ùìï (f : Œò X) := ((ùîò k n j x m).image ùí¨).filter (¬∑ ‚àà @ball _ pm f 0.2)
  -- `ùí¨` is 1-1, `ùìë.biUnion ùìï` covers `(ùîò k n j x m).image ùí¨`, and each `ùìï f` has cardinality
  -- ‚â§ 1, so `(ùîò k n j x m).card = ((ùîò k n j x m).image ùí¨).card ‚â§ (ùìë.biUnion ùìï).card ‚â§ ùìë.card`
  have ùí¨ùîò_eq_union: (ùîò k n j x m).image ùí¨ = ùìë.biUnion ùìï := by
    ext f
    simp only [ùìï, Finset.mem_biUnion, mem_filter]
    refine ‚ü®fun hf ‚Ü¶ ?_, fun ‚ü®_, _, h, _‚ü© ‚Ü¶ h‚ü©
    obtain ‚ü®g, hg‚ü© : ‚àÉ g ‚àà ùìë, f ‚àà @ball _ pm g 0.2 := by
      simpa only [mem_iUnion, exists_prop] using ùìë_cover (subset_big_ball hu f hf)
    exact ‚ü®g, hg.1, hf, hg.2‚ü©
  have card_le_one : ‚àÄ f ‚àà ùìë, (ùìï f).card ‚â§ 1 := by
    refine fun f _ ‚Ü¶ card_le_one.mpr (fun g‚ÇÅ hg‚ÇÅ g‚ÇÇ hg‚ÇÇ ‚Ü¶ ?_)
    by_contra! h
    simp only [mem_filter, ùìï, Finset.mem_image] at hg‚ÇÅ hg‚ÇÇ
    rcases hg‚ÇÅ.1 with ‚ü®u‚ÇÅ, hu‚ÇÅ, rfl‚ü©
    rcases hg‚ÇÇ.1 with ‚ü®u‚ÇÇ, hu‚ÇÇ, rfl‚ü©
    apply Set.not_disjoint_iff.mpr ‚ü®f, mem_ball_comm.mp hg‚ÇÅ.2, mem_ball_comm.mp hg‚ÇÇ.2‚ü©
    exact disjoint_balls hu hu‚ÇÅ hu‚ÇÇ (ne_of_apply_ne ùí¨ h)
  rw [‚Üê card_image_iff.mpr ùí¨_injOn_ùîòm, ùí¨ùîò_eq_union]
  exact (mul_one ùìë.card ‚ñ∏ card_biUnion_le_card_mul ùìë ùìï 1 card_le_one).trans ùìë_card_le

variable (k n j) (x) in
private def ùîê' (u : ùîì X) := (ùîê k n).toFinset.filter (fun m ‚Ü¶ smul 100 u ‚â§ smul 1 m)

-- Interchange the summations in the proof of Lemma 5.2.8
private lemma interchange :
    ((ùîò‚ÇÅ k n j).toFinset.filter (x ‚àà ùìò ¬∑)).sum (fun u ‚Ü¶ (ùîê' k n u).sum
    (fun m ‚Ü¶ (ùìò m : Set X).indicator (1 : X ‚Üí ‚Ñù) x)) =
    (ùîê k n).toFinset.sum (fun m ‚Ü¶ (ùîò k n j x m).sum
    (fun _ ‚Ü¶ (ùìò m : Set X).indicator (1 : X ‚Üí ‚Ñù) x)) :=
  Finset.sum_comm' fun u m ‚Ü¶ by simp only [ùîê', ùîò, Finset.mem_filter]; tauto

end ùîò

-- Inequality (5.2.20) in the proof of Lemma 5.2.8
private lemma indicator_le : ‚àÄ u ‚àà (ùîò‚ÇÅ k n j).toFinset.filter (x ‚àà ùìò ¬∑),
    (ùìò u : Set X).indicator 1 x ‚â§ (2 : ‚Ñù) ^ (-j : ‚Ñ§) * stackSize (ùîê' k n u) x := by
  intro u hu
  by_cases hx : x ‚àà (ùìò u : Set X); swap
  ¬∑ simp [hx]
  suffices (2 : ‚Ñù) ^ (j : ‚Ñ§) ‚â§ stackSize (ùîê' k n u) x by calc
    _ ‚â§ (2 : ‚Ñù) ^ (-j : ‚Ñ§) * (2 : ‚Ñù) ^ (j : ‚Ñ§)       := by simp [hx]
    _ ‚â§ (2 : ‚Ñù) ^ (-j : ‚Ñ§) * stackSize (ùîê' k n u) x := by gcongr
  norm_cast
  simp only [ùîò‚ÇÅ, Finset.mem_filter, toFinset_setOf] at hu
  apply le_of_le_of_eq hu.1.2.1.1.2
  simp only [Finset.coe_filter, mem_toFinset, ùîê', Finset.card_eq_sum_ones]
  refine Finset.sum_congr rfl (fun m hm ‚Ü¶ ?_)
  simp only [TileLike.le_def, smul_fst, Finset.mem_filter] at hm
  simp [hm.2.2.1.1 hx]

open Finset in
/-- Lemma 5.2.8 -/
lemma tree_count :
    stackSize (ùîò‚ÇÅ k n j) x ‚â§ (2 : ‚Ñù) ^ (9 * a - j : ‚Ñ§) * stackSize (ùîê k n) x := by
  -- When calculating the LHS, we need only sum over those `u` for which `x ‚àà ùìò u`.
  have : ‚àë u ‚àà univ.filter (¬∑ ‚àà ùîò‚ÇÅ (X := X) k n j), (ùìò u : Set X).indicator (1 : X ‚Üí ‚Ñù) x =
      ‚àë u ‚àà (ùîò‚ÇÅ k n j).toFinset.filter (x ‚àà ùìò ¬∑), (ùìò u : Set X).indicator (1 : X ‚Üí ‚Ñù) x := by
    rw [filter_mem_univ_eq_toFinset (ùîò‚ÇÅ k n j), sum_filter]
    exact sum_congr rfl <|
      fun u _ ‚Ü¶ _root_.by_cases (p := x ‚àà ùìò u) (fun hx ‚Ü¶ by simp [hx]) (fun hx ‚Ü¶ by simpa [hx])
  rw [stackSize_real, this]
  -- Use inequality (5.2.20) to bound the LHS by a double sum, then interchange the sums.
  apply le_trans (sum_le_sum indicator_le)
  simp_rw [‚Üê mul_sum, stackSize_real, mem_coe, filter_univ_mem, interchange, sum_const]
  -- Replace the cardinality of `ùîò` with the upper bound proven in `card_ùîòm_le`, and simplify.
  apply le_of_le_of_eq <| (mul_le_mul_left (zpow_pos two_pos _)).mpr <| sum_le_sum <|
    fun _ _ ‚Ü¶ smul_le_smul_of_nonneg_right card_ùîòm_le <| Set.indicator_apply_nonneg (by simp)
  simp_rw [‚Üê smul_sum, nsmul_eq_mul, ‚Üê mul_assoc, filter_mem_univ_eq_toFinset (ùîê k n), defaultA]
  rw [sub_eq_add_neg, zpow_add‚ÇÄ two_ne_zero, ‚Üê pow_mul, mul_comm 9, mul_comm (2 ^ _)]
  norm_cast


/-- Lemma 5.2.9 -/
lemma boundary_exception {u : ùîì X} (hu : u ‚àà ùîò‚ÇÅ k n l) :
    volume (‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X)) ‚â§ C5_2_9 X n * volume (ùìò u : Set X) := by
  by_cases  h_ùìõ_n_u_non_empty : Set.Nonempty (ùìõ (X := X) n u)
  ¬∑ set X_u := { x ‚àà GridStructure.coeGrid (ùìò u) | EMetric.infEdist x (GridStructure.coeGrid (ùìò u))·∂ú ‚â§ 12 * (D ^ (ùî∞ u - Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0‚àû)} with h_X_u -- 5.2.25

    calc volume (‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X))
      _ ‚â§ volume X_u := by
          have i_subset_X_u : ‚àÄ i ‚àà ùìõ (X := X) n u, GridStructure.coeGrid i ‚äÜ X_u := by
            intro i ‚ü®‚ü®i_subset_I_u, _‚ü©, s_i_eq_stuff, I_not_contain_8_ball‚ü© ipt hipt
            refine ‚ü®i_subset_I_u hipt, ?_‚ü©
            rw [show ùî∞ u - Z * (n + 1) - 1 = s i by norm_cast; linarith]

            obtain ‚ü®bpt, hbpt, h_bpt_not_in_I_u‚ü© : ‚àÉ b ‚àà ball (c i) (8 * ‚ÜëD ^ s i), b ‚àâ ‚Üë(ùìò u) := not_subset.mp I_not_contain_8_ball

            -- triangle inequality between ipt, bpt, c i
            have ipt_bpt_triangle_ineq : dist ipt bpt ‚â§ (12 * D ^ s i : ‚Ñù) :=
              calc dist ipt bpt
                _ ‚â§ dist ipt (c i) + dist (c i) bpt := dist_triangle ipt (c i) bpt
                _ ‚â§ 4 * D ^ s i + dist (c i) bpt := by
                  have dist_ipt_c_i_le : dist ipt (c i) < 4 * D ^ s i := by
                    have ipt_in_ball_4 : ipt ‚àà ball (c i) (4 * D ^ s i) := Grid_subset_ball hipt
                    simp_all only [le_eq_subset, ball, mem_setOf_eq, Grid.mem_def]
                  rel [dist_ipt_c_i_le]
                _ ‚â§ 4 * D ^ s i + dist bpt (c i) := by rw [dist_comm]
                _ ‚â§ 4 * D ^ s i + 8 * D ^ s i := by
                    have dist_bpt_c_i_le : dist bpt (c i) < 8 * D ^ s i := by 
                      simp_all only [le_eq_subset, ball, mem_setOf_eq, Grid.mem_def]
                    rel [dist_bpt_c_i_le]
                _ ‚â§ 12 * D ^ s i := by linarith

            -- show the the triangle inequality implies distance between ipt and (ùìò u)·∂ú <= 12 * D ^ s i
            calc EMetric.infEdist ipt (GridStructure.coeGrid (ùìò u))·∂ú
              _ ‚â§ edist ipt bpt := EMetric.infEdist_le_edist_of_mem <| Set.mem_compl h_bpt_not_in_I_u
              _ ‚â§ ENNReal.ofReal (12 * D ^ s i) := by
                rw [edist_dist]
                exact ENNReal.ofReal_le_ofReal ipt_bpt_triangle_ineq
              _ ‚â§ ENNReal.ofNNReal (12 * D ^ s i) := le_of_eq <|
                congr_arg (ENNReal.ofNNReal) <| NNReal.coe_injective <| by
                    simpa using zpow_nonneg (by simp [one_le_D]) (s i)
              _ ‚â§ 12 * (D ^ (s i : ‚Ñ§) :  ‚Ñù‚â•0‚àû) := by
                  push_cast
                  rw [ENNReal.coe_zpow]
                  ¬∑ push_cast
                    rfl
                  ¬∑ simp [one_le_D]

          rw [show ‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X) = ‚ãÉ i : ùìõ (X := X) n u, (i : Set X) by simp]
          exact measure_mono <| Set.iUnion_subset_iff.mpr <| by simp [i_subset_X_u]
      _ ‚â§ 2 * (12 * D ^ (- Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0) ^ Œ∫ * volume (ùìò u : Set X) := by
          have small_boundary_observation : ‚àÄ i ‚àà ùìõ (X := X) n u, volume X_u ‚â§ 2 * (12 * D ^ (- Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0) ^ Œ∫ * volume (ùìò u : Set X) := by
            intro i ‚ü®_, s_i_eq_stuff, _‚ü©
            -- choose t for small boundary property
            set t := 12 * (D ^ (- Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0) with ht

            -- algebra useful in multiple steps of the proof
            have D_pow_algebra : 12 * (D ^ (- Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0)  * (D ^ (ùî∞ u : ‚Ñ§) : ‚Ñù‚â•0) = 12 * (D ^ ( ùî∞ u - Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0) := by
              have : 12 * (D ^ (- Z * (n + 1) - 1 : ‚Ñ§) : ‚Ñù‚â•0)  * (D ^ (ùî∞ u : ‚Ñ§) : ‚Ñù‚â•0) = 12 * (D ^ (- Z * (n + 1) - 1 + ùî∞ u : ‚Ñ§) : ‚Ñù‚â•0) := by
                rw [zpow_add‚ÇÄ (show (D : ‚Ñù‚â•0) ‚â† 0 by norm_num) _ _]
                ring
              rw [this]
              rw [show - Z * (n + 1) - 1 + ùî∞ u = ùî∞ u - Z * (n + 1) - 1 by linarith]

            -- small boundary property assumption for ùìò u
            have small_boundary_h : D ^ ((- S - s (ùìò u)) : ‚Ñ§) ‚â§ t := by
              have one_le_nnreal_D : 1 ‚â§ (D : ‚Ñù‚â•0) := by
                have h1 : 1 ‚â§ (D : ‚Ñù) := one_le_D
                assumption_mod_cast
              have small_boundary_h_intermediate : D ^ (- S : ‚Ñ§) ‚â§ t * D ^ (ùî∞ u: ‚Ñ§) := by
                rw [ht, D_pow_algebra,
                    show ùî∞ u - Z * (n + 1) - 1 = s i by rw [‚Üê s_i_eq_stuff]; norm_cast; linarith]
                have bound_i_neg_S : -S ‚â§ s i := (mem_Icc.mp (range_s_subset ‚ü®i, rfl‚ü©)).1
                exact le_mul_of_one_le_of_le (by simp) <| zpow_le_zpow_right‚ÇÄ (one_le_nnreal_D) bound_i_neg_S
              apply (mul_inv_le_iff‚ÇÄ <| by positivity).mpr at small_boundary_h_intermediate
              rw [‚Üê NNReal.rpow_neg_one] at small_boundary_h_intermediate
              have : (D ^ (ùî∞ u : ‚Ñ§) : ‚Ñù‚â•0) ^ (-1 : ‚Ñù) = (D ^ (ùî∞ u * (-1)) : ‚Ñù‚â•0) := by 
                rw [show (D ^ (ùî∞ u : ‚Ñ§) : ‚Ñù‚â•0) = (D ^ (ùî∞ u : ‚Ñù) : ‚Ñù‚â•0) by norm_cast, ‚Üê NNReal.rpow_mul]
                norm_cast
              rwa [this, mul_neg_one, ‚Üê zpow_add‚ÇÄ (show (D : ‚Ñù‚â•0) ‚â† 0 by norm_num),
                   show ùî∞ u = s (ùìò u) from rfl, add_comm,
                   neg_add_eq_sub] at small_boundary_h_intermediate
            
            have small_b := GridStructure.small_boundary small_boundary_h

            have X_u_in_terms_of_t : X_u = { x ‚àà GridStructure.coeGrid (ùìò u) | EMetric.infEdist x (GridStructure.coeGrid (ùìò u))·∂ú ‚â§ ((t * D ^ (s (ùìò u))):‚Ñù‚â•0‚àû)} := by
              rw [ht, show s (ùìò u) = ùî∞ u from rfl,
                  show (D ^ ùî∞ u : ‚Ñù‚â•0‚àû) = (D ^ ùî∞ u : ‚Ñù‚â•0) by simp]
              rw_mod_cast [D_pow_algebra, h_X_u]
              have : 12 * (D ^ (ùî∞ u - (Z * (n + 1) : ‚Ñ§) - 1) : ‚Ñù‚â•0‚àû) = ((12 * (D ^ (ùî∞ u - (Z * (n + 1)) - 1) : ‚Ñù‚â•0)) : ‚Ñù‚â•0‚àû) := by 
                simp
              rw_mod_cast [this]
            rw [show s (ùìò u) = GridStructure.s (ùìò u) from rfl] at X_u_in_terms_of_t
            rw [‚Üê X_u_in_terms_of_t, measureReal_def, measureReal_def] at small_b
            rw [‚Üê ENNReal.toReal_le_toReal] -- this requires showing everything is finite
            ¬∑ rw [ENNReal.toReal_mul]
              have : (2 * (t ^ Œ∫ : ‚Ñù‚â•0‚àû)).toReal = 2 * t ^ Œ∫  := by 
                norm_cast
                rw [ENNReal.toReal_mul, ‚Üê ENNReal.toReal_rpow]
                rfl
              rwa [this]
            ¬∑ apply LT.lt.ne
              rw [h_X_u]
              apply lt_of_le_of_lt <| volume.mono inter_subset_left
              simp [volume_coeGrid_lt_top]
            ¬∑ apply LT.lt.ne
              have t_k_lt_top : 2 * (t : ‚Ñù‚â•0‚àû) ^ Œ∫ < ‚ä§ := by
                rw [ht]
                exact WithTop.mul_lt_top (by apply WithTop.coe_lt_top) <| 
                  (ENNReal.rpow_lt_top_of_nonneg Œ∫_nonneg) (lt_top_iff_ne_top.mp (by apply WithTop.coe_lt_top))
              exact WithTop.mul_lt_top t_k_lt_top volume_coeGrid_lt_top

          obtain ‚ü®i, hi‚ü© := h_ùìõ_n_u_non_empty
          exact small_boundary_observation i hi

      _ ‚â§ C5_2_9 X n * volume (ùìò u : Set X) := by -- choosing the right k and D
        have coeff_lt :  2 * (12 * D ^ (-Z * (n + 1) - 1 : ‚Ñù)) ^ Œ∫ ‚â§ (D ^ (1 - Œ∫ * Z * (n + 1)) : ‚Ñù‚â•0) := by 
          have twelve_le_D : 12 ‚â§ D := by 
            have : 4 ‚â§ a := (show ProofData a q K œÉ‚ÇÅ œÉ‚ÇÇ F G by infer_instance).four_le_a
            have : 2 ^ (100) ‚â§ 2^ (100 * a ^2) := (Nat.pow_le_pow_iff_right (by nlinarith)).mpr <| by nlinarith
            simp only [defaultD, ge_iff_le]
            nlinarith
          have two_time_twelve_over_D_to_the_k_le_D : 2 * (12 / D) ^ Œ∫ ‚â§ (D : ‚Ñù‚â•0) := by 
            have two_le_D : 2 ‚â§ D := by linarith
            have : 2 * (12 / D) ^ Œ∫ ‚â§ (2 : ‚Ñù‚â•0) := by
              apply (MulLECancellable.mul_le_iff_le_one_right ?_).mpr
              apply NNReal.rpow_le_one
              apply div_le_one_of_le‚ÇÄ <| by norm_cast
              simp only [zero_le]
              apply Œ∫_nonneg
              simp [MulLECancellable]
            exact this.trans <| by norm_cast
          have two_times_twelve_k_D_minus_k_le_D : 2 * 12 ^ Œ∫ * D ^ (-Œ∫) ‚â§ (D : ‚Ñù‚â•0) := by 
            rwa [‚Üê inv_mul_eq_div, NNReal.mul_rpow, NNReal.inv_rpow,
                ‚Üê NNReal.rpow_neg, mul_comm _ (12 ^ Œ∫), ‚Üê mul_assoc] at two_time_twelve_over_D_to_the_k_le_D
          have mul_by_D_to_the_k_Z : 2 * 12 ^ Œ∫ * D ^ (-1*Œ∫)  * D ^ (-1* Œ∫  * Z * (n + 1)) ‚â§ (D : ‚Ñù‚â•0) * D ^ (-Œ∫ * Z * (n + 1)) := by
            have : 2 * 12 ^ Œ∫ * D ^ (-Œ∫) * D ^ (-Œ∫ * Z * (n + 1)) ‚â§ (D : ‚Ñù‚â•0) * D ^ (-Œ∫ * Z * (n + 1)) := 
              mul_le_mul_of_nonneg_right two_times_twelve_k_D_minus_k_le_D (by positivity)
            rwa [‚Üê neg_eq_neg_one_mul]
          have rearrange_exponents : 2 * (12 : ‚Ñù‚â•0) ^ Œ∫ * (D ^ (-(1 : ‚Ñù))) ^ Œ∫ * (D ^ (-(1 : ‚Ñù) * Z * (n + 1)) : ‚Ñù‚â•0) ^ Œ∫ ‚â§ (D : ‚Ñù‚â•0) ^ (1 : ‚Ñù) * D ^ (-Œ∫ * Z * (n + 1)) := by
            have : (-1* Œ∫  * Z * (n + 1) : ‚Ñù) = (-1 * Z * (n + 1)) * Œ∫ := by ring
            rw [this, NNReal.rpow_mul, NNReal.rpow_mul] at mul_by_D_to_the_k_Z
            rwa [NNReal.rpow_one]
          rwa [mul_assoc, ‚Üê NNReal.mul_rpow, mul_assoc, ‚Üê NNReal.mul_rpow,
              ‚Üê NNReal.rpow_add (by positivity), ‚Üê NNReal.rpow_add (by positivity), add_comm,
              ‚Üê neg_eq_neg_one_mul, ‚Üê Ring.sub_eq_add_neg,
              show  1 + -Œ∫ * Z * (n + 1) = 1 - Œ∫ * Z * (n + 1) by ring] at rearrange_exponents
        rw [C5_2_9]
        apply ENNReal.coe_le_coe.mpr at coeff_lt
        norm_cast
        have : 12 * (D ^ (-Z * (n + 1) - 1: ‚Ñ§ ) : ‚Ñù‚â•0) ‚â† 0 := by 
          simp only [defaultD, Nat.cast_pow, Nat.cast_ofNat, defaultZ, neg_mul, ne_eq, mul_eq_zero, OfNat.ofNat_ne_zero, false_or]
          positivity
        rw [‚Üê ENNReal.coe_rpow_of_ne_zero (by exact this)] -- why do I need this with exact_mod_cast?
        exact_mod_cast mul_le_mul_right' coeff_lt (volume (ùìò u : Set X))
  ¬∑ have : volume (‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X)) = 0 := by 
      have h1 : volume (‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X)) ‚â§ ‚àë' i : ùìõ (X := X) n u, volume (i : Set X) := measure_biUnion_le _ (ùìõ n u).to_countable _
      have h2 : ‚àë' i : ùìõ (X := X) n u, volume (i : Set X) = 0 := by
        have : ùìõ (X := X) n u = ‚àÖ := Set.not_nonempty_iff_eq_empty'.mp <| by 
          rw [Set.Nonempty] at h_ùìõ_n_u_non_empty
          simp [h_ùìõ_n_u_non_empty]
        simp [this]
      exact (le_of_le_of_eq h1 h2).antisymm (by simp)
    simp [this]

lemma third_exception_aux :
    volume (‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X)) ‚â§
    C5_2_9 X n * 2 ^ (9 * a - j : ‚Ñ§) * 2 ^ (n + k + 3) * volume G :=
  calc
    _ ‚â§ volume (‚ãÉ u ‚àà ùîò‚ÇÅ (X := X) k n j, ‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X)) := by
      refine measure_mono (iUnion‚ÇÇ_subset fun p mp ‚Ü¶ ?_)
      obtain ‚ü®u, mu, hu‚ü© := mp.2; exact subset_iUnion‚ÇÇ_of_subset u mu hu
    _ ‚â§ ‚àë' u : ùîò‚ÇÅ (X := X) k n j, volume (‚ãÉ i ‚àà ùìõ (X := X) n u, (i : Set X)) :=
      measure_biUnion_le _ (ùîò‚ÇÅ k n j).to_countable _
    _ ‚â§ ‚àë' u : ùîò‚ÇÅ (X := X) k n j, C5_2_9 X n * volume (ùìò u.1 : Set X) :=
      ENNReal.tsum_le_tsum fun x ‚Ü¶ boundary_exception x.2
    _ = C5_2_9 X n * ‚àë u ‚àà { p | p ‚àà ùîò‚ÇÅ (X := X) k n j }, volume (ùìò u : Set X) := by
      rw [filter_mem_univ_eq_toFinset, ENNReal.tsum_mul_left]; congr
      rw [tsum_fintype]; convert (Finset.sum_subtype _ (fun u ‚Ü¶ mem_toFinset) _).symm; rfl
    _ ‚â§ C5_2_9 X n * 2 ^ (9 * a - j : ‚Ñ§) *
        ‚àë m ‚àà { p | p ‚àà ùîê (X := X) k n }, volume (ùìò m : Set X) := by
      rw [mul_assoc]; refine mul_le_mul_left' ?_ _
      simp_rw [‚Üê lintegral_indicator_one coeGrid_measurable,
        ‚Üê lintegral_finset_sum _ fun _ _ ‚Ü¶ measurable_one.indicator coeGrid_measurable]
      have c1 : ‚àÄ C : Set (ùîì X),
          ‚à´‚Åª x, ‚àë u ‚àà { p | p ‚àà C }, (ùìò u : Set X).indicator 1 x =
          ‚à´‚Åª x, stackSize C x := fun C ‚Ü¶ by
        refine lintegral_congr fun _ ‚Ü¶ ?_; rw [stackSize, Nat.cast_sum]; congr!
        simp_rw [indicator]; split_ifs <;> simp
      rw [c1, c1, ‚Üê lintegral_const_mul _ stackSize_measurable]
      refine lintegral_mono fun x ‚Ü¶ ?_
      simp_rw [‚Üê ENNReal.coe_natCast, show (2 : ‚Ñù‚â•0‚àû) = (2 : ‚Ñù‚â•0) by rfl,
        ‚Üê ENNReal.coe_zpow two_ne_zero, ‚Üê ENNReal.coe_mul, ENNReal.coe_le_coe,
        ‚Üê toNNReal_coe_nat]
      have c2 : (2 : ‚Ñù‚â•0) ^ (9 * a - j : ‚Ñ§) = ((2 : ‚Ñù) ^ (9 * a - j : ‚Ñ§)).toNNReal := by
        refine ((fun h ‚Ü¶ (Real.toNNReal_eq_iff_eq_coe h).mpr) ?_ rfl).symm
        positivity
      rw [c2, ‚Üê Real.toNNReal_mul (by positivity)]
      refine Real.toNNReal_le_toNNReal tree_count
    _ ‚â§ _ := by rw [mul_assoc _ _ (volume G)]; gcongr; exact top_tiles

/-- Lemma 5.2.10 -/
lemma third_exception : volume (G‚ÇÉ (X := X)) ‚â§ 2 ^ (-4 : ‚Ñ§) * volume G := by
  calc
    _ ‚â§ ‚àë' n, volume (‚ãÉ k, ‚ãÉ (_ : k ‚â§ n), ‚ãÉ j, ‚ãÉ (_ : j ‚â§ 2 * n + 3),
        ‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X)) := measure_iUnion_le _
    _ ‚â§ ‚àë' n, ‚àë' k, volume (‚ãÉ (_ : k ‚â§ n), ‚ãÉ j, ‚ãÉ (_ : j ‚â§ 2 * n + 3),
        ‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X)) := by gcongr; exact measure_iUnion_le _
    _ = ‚àë' n, ‚àë' k, volume (if k ‚â§ n then ‚ãÉ j, ‚ãÉ (_ : j ‚â§ 2 * n + 3),
        ‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X) else ‚àÖ) := by congr!; exact iUnion_eq_if _
    _ = ‚àë' n, ‚àë' k, if k ‚â§ n then volume (‚ãÉ j, ‚ãÉ (_ : j ‚â§ 2 * n + 3),
        ‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X)) else 0 := by congr!; split_ifs <;> simp
    _ ‚â§ ‚àë' n, ‚àë' k, if k ‚â§ n then ‚àë' j, volume (‚ãÉ (_ : j ‚â§ 2 * n + 3),
        ‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X)) else 0 := by
      gcongr; split_ifs
      ¬∑ exact measure_iUnion_le _
      ¬∑ exact le_rfl
    _ ‚â§ ‚àë' n, ‚àë' k, if k ‚â§ n then ‚àë' j, volume (‚ãÉ p ‚àà ùîè‚ÇÑ (X := X) k n j, (ùìò p : Set X)) else 0 := by
      gcongr; split_ifs
      ¬∑ gcongr; exact iUnion_subset fun _ _ ‚Ü¶ id
      ¬∑ exact le_rfl
    _ ‚â§ ‚àë' n, ‚àë' k, if k ‚â§ n then ‚àë' (j : ‚Ñï),
        C5_2_9 X n * 2 ^ (9 * a - j : ‚Ñ§) * 2 ^ (n + k + 3) * volume G else 0 := by
      gcongr; split_ifs
      ¬∑ gcongr; exact third_exception_aux
      ¬∑ exact le_rfl
    _ = ‚àë' k, 2 ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G *
        ‚àë' n, if k ‚â§ n then (2 * D ^ (-Œ∫ * Z) : ‚Ñù‚â•0‚àû) ^ (n - k : ‚Ñù) else 0 :=
      third_exception_rearrangement
    _ ‚â§ ‚àë' k, 2 ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G *
        ‚àë' n, if k ‚â§ n then 2‚Åª¬π ^ (n - k : ‚Ñù) else 0 := by
      gcongr with k n; split_ifs with hnk
      ¬∑ refine ENNReal.rpow_le_rpow ?_ (by simpa using hnk)
        calc
          _ ‚â§ 2 * (2 : ‚Ñù‚â•0‚àû) ^ (-100 : ‚Ñù) := mul_le_mul_left' (DŒ∫Z_le_two_rpow_100 (X := X)) 2
          _ ‚â§ _ := by
            nth_rw 1 [‚Üê ENNReal.rpow_one 2, ‚Üê ENNReal.rpow_add _ _ (by simp) (by simp),
              ‚Üê ENNReal.rpow_neg_one 2]
            exact ENNReal.rpow_le_rpow_of_exponent_le one_le_two (by norm_num)
      ¬∑ exact le_rfl
    _ = ‚àë' k, 2 ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G *
        ‚àë' (n : ‚Ñï), 2 ^ (-(1 : ‚Ñï) * n : ‚Ñ§) := by
      congr! 3 with k; convert tsum_geometric_ite_eq_tsum_geometric with n hnk
      rw [‚Üê ENNReal.rpow_neg_one, ‚Üê ENNReal.rpow_mul]; norm_cast
    _ = ‚àë' k, 2 ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G * 2 := by
      congr!; simpa using ENNReal.sum_geometric_two_pow_neg_one
    _ = 2 ^ (9 * a + 5) * D ^ (1 - Œ∫ * Z) * volume G *
        ‚àë' (k : ‚Ñï), (2 : ‚Ñù‚â•0‚àû) ^ (2 * k) * D ^ (-Œ∫ * Z * k) := by
      rw [‚Üê ENNReal.tsum_mul_left]; congr with k
      have lhsr :
          (2 : ‚Ñù‚â•0‚àû) ^ (9 * a + 4 + 2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G * 2 =
          2 ^ (9 * a + 5) * 2 ^ (2 * k) * D ^ (1 - Œ∫ * Z * (k + 1)) * volume G := by ring
      have rhsr :
          (2 : ‚Ñù‚â•0‚àû) ^ (9 * a + 5) * D ^ (1 - Œ∫ * Z) * volume G * (2 ^ (2 * k) * D ^ (-Œ∫ * Z * k)) =
          2 ^ (9 * a + 5) * 2 ^ (2 * k) * (D ^ (1 - Œ∫ * Z) * D ^ (-Œ∫ * Z * k)) * volume G := by
        ring
      rw [lhsr, rhsr]; congr
      rw [‚Üê ENNReal.rpow_add _ _ (by rw [defaultD]; simp) (by rw [defaultD]; simp)]
      congr; ring
    _ = 2 ^ (9 * a + 5) * D ^ (1 - Œ∫ * Z) * volume G *
        ‚àë' k, ((2 : ‚Ñù‚â•0‚àû) ^ 2 * D ^ (-Œ∫ * Z)) ^ k := by
      congr! with k
      rw [ENNReal.rpow_mul, ‚Üê ENNReal.rpow_natCast, Nat.cast_mul, ENNReal.rpow_mul 2,
        ‚Üê ENNReal.mul_rpow_of_ne_top (by simp) (by simp), ENNReal.rpow_natCast]
      congr 2; norm_cast
    _ ‚â§ 2 ^ (9 * a + 5) * D ^ (1 - Œ∫ * Z) * volume G * ‚àë' k, 2‚Åª¬π ^ k := by
      gcongr
      calc
        _ ‚â§ 2 ^ 2 * (2 : ‚Ñù‚â•0‚àû) ^ (-100 : ‚Ñù) := mul_le_mul_left' (DŒ∫Z_le_two_rpow_100 (X := X)) _
        _ ‚â§ _ := by
          nth_rw 1 [‚Üê ENNReal.rpow_natCast, ‚Üê ENNReal.rpow_add _ _ (by simp) (by simp),
            ‚Üê ENNReal.rpow_neg_one 2]
          exact ENNReal.rpow_le_rpow_of_exponent_le one_le_two (by norm_num)
    _ = 2 ^ (9 * a + 5) * D ^ (1 - Œ∫ * Z) * volume G * 2 := by
      congr; convert ENNReal.sum_geometric_two_pow_neg_one with k
      rw [‚Üê ENNReal.rpow_intCast, show (-k : ‚Ñ§) = (-k : ‚Ñù) by norm_cast, ENNReal.rpow_neg,
        ‚Üê ENNReal.inv_pow, ENNReal.rpow_natCast]
    _ ‚â§ 2 ^ (9 * a + 5) * D ^ (-1 : ‚Ñù) * volume G * 2 := by
      gcongr
      ¬∑ exact_mod_cast one_le_D
      ¬∑ linarith [two_le_Œ∫Z (X := X)]
    _ = 2 ^ (9 * a + 6 - 100 * a ^ 2 : ‚Ñ§) * volume G := by
      rw [‚Üê mul_rotate, ‚Üê mul_assoc, ‚Üê pow_succ', defaultD, Nat.cast_pow,
        show ((2 : ‚Ñï) : ‚Ñù‚â•0‚àû) = 2 by rfl, ‚Üê ENNReal.rpow_natCast, ‚Üê ENNReal.rpow_natCast,
        ‚Üê ENNReal.rpow_mul, ‚Üê ENNReal.rpow_add _ _ (by simp) (by simp), ‚Üê ENNReal.rpow_intCast]
      congr 2; norm_num; ring
    _ ‚â§ _ := mul_le_mul_right' (ENNReal.zpow_le_of_le one_le_two (by nlinarith [four_le_a X])) _

/-- Lemma 5.1.1 -/
lemma exceptional_set : volume (G' : Set X) ‚â§ 2 ^ (-1 : ‚Ñ§) * volume G :=
  calc volume G'
    _ ‚â§ volume G‚ÇÅ + volume G‚ÇÇ + volume G‚ÇÉ :=
      le_add_of_le_add_right (measure_union_le _ G‚ÇÉ) (measure_union_le _ _)
    _ ‚â§ 2 ^ (- 4 : ‚Ñ§) * volume G + 2 ^ (- 2 : ‚Ñ§) * volume G + 2 ^ (- 4 : ‚Ñ§) * volume G :=
      add_le_add_three first_exception second_exception third_exception
    _ = ((2 : ‚Ñù‚â•0‚àû) * 2 ^ (-4 : ‚Ñ§) + 2 ^ (- 2 : ‚Ñ§)) * volume G := by ring
    _ ‚â§ 2 ^ (- 1 : ‚Ñ§) * volume G := by
      gcongr
      change ((2 : ‚Ñù‚â•0) : ‚Ñù‚â•0‚àû) * (2 : ‚Ñù‚â•0) ^ (-4 : ‚Ñ§) + (2 : ‚Ñù‚â•0) ^ (-2 : ‚Ñ§) ‚â§
        (2 : ‚Ñù‚â•0) ^ (-1 : ‚Ñ§)
      repeat rw [‚Üê ENNReal.coe_zpow (show (2 : ‚Ñù‚â•0) ‚â† 0 by norm_num)]
      rw_mod_cast [‚Üê NNReal.coe_le_coe]; norm_num
