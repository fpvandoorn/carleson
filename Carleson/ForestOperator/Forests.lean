import Carleson.ForestOperator.LargeSeparation
import Carleson.ForestOperator.RemainingTiles

open ShortVariables TileStructure
variable {X : Type*} {a : â„•} {q : â„} {K : X â†’ X â†’ â„‚} {Ïƒâ‚ Ïƒâ‚‚ : X â†’ â„¤} {F G : Set X}
  [MetricSpace X] [ProofData a q K Ïƒâ‚ Ïƒâ‚‚ F G] [TileStructure Q D Îº S o]
  {n j j' : â„•} {t : Forest X n} {u uâ‚ uâ‚‚ p : ğ”“ X} {x x' : X} {ğ”– : Set (ğ”“ X)}
  {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ : X â†’ â„‚} {I J J' L : Grid X}
variable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace â„ E']

noncomputable section

open Set MeasureTheory Metric Function Complex Bornology TileStructure Classical Filter
open scoped NNReal ENNReal ComplexConjugate

namespace TileStructure.Forest

/-! ## Lemmas 7.4.4 -/

/-- The constant used in `correlation_separated_trees`.
Has value `2 ^ (550 * a ^ 3 - 3 * n)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
irreducible_def C7_4_4 (a n : â„•) : â„â‰¥0 := 2 ^ (550 * (a : â„) ^ 3 - 3 * n)

lemma correlation_separated_trees_of_subset (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, adjointCarlesonSum (t uâ‚) gâ‚ x * conj (adjointCarlesonSum (t uâ‚‚) gâ‚‚ x)â€–â‚Š â‰¤
    C7_4_4 a n *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚ gâ‚) Â· |>.toReal) 2 volume *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚‚ gâ‚‚) Â· |>.toReal) 2 volume := by
  sorry

/-- Lemma 7.4.4. -/
lemma correlation_separated_trees (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, adjointCarlesonSum (t uâ‚) gâ‚ x * conj (adjointCarlesonSum (t uâ‚‚) gâ‚‚ x)â€–â‚Š â‰¤
    C7_4_4 a n *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚ gâ‚) Â· |>.toReal) 2 volume *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚‚ gâ‚‚) Â· |>.toReal) 2 volume := by
  sorry


/-! ## Section 7.7 -/

/-- The row-decomposition of a tree, defined in the proof of Lemma 7.7.1.
The indexing is off-by-one compared to the blueprint. -/
def rowDecomp (t : Forest X n) (j : â„•) : Row X n := sorry

/-- Part of Lemma 7.7.1 -/
@[simp]
lemma biUnion_rowDecomp : â‹ƒ j < 2 ^ n, t.rowDecomp j = (t : Set (ğ”“ X)) := by
  sorry

/-- Part of Lemma 7.7.1 -/
lemma pairwiseDisjoint_rowDecomp :
    (Iio (2 ^ n)).PairwiseDisjoint (rowDecomp t Â· : â„• â†’ Set (ğ”“ X)) := by
  sorry

@[simp] lemma rowDecomp_apply : t.rowDecomp j u = t u := by
  sorry

/-- The constant used in `row_bound`.
Has value `2 ^ (156 * a ^ 3 - n / 2)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
irreducible_def C7_7_2_1 (a n : â„•) : â„â‰¥0 := 2 ^ (156 * (a : â„) ^ 3 - n / 2)

/-- The constant used in `indicator_row_bound`.
Has value `2 ^ (257 * a ^ 3 - n / 2)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
irreducible_def C7_7_2_2 (a n : â„•) : â„â‰¥0 := 2 ^ (257 * (a : â„) ^ 3 - n / 2)

/-- Part of Lemma 7.7.2. -/
lemma row_bound (hj : j < 2 ^ n) (hf : BoundedCompactSupport f) :
    eLpNorm (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j}, adjointCarlesonSum (t u) f) 2 volume â‰¤
    C7_7_2_1 a n * eLpNorm f 2 volume := by
  sorry

/-- Part of Lemma 7.7.2. -/
lemma indicator_row_bound (hj : j < 2 ^ n) (hf : BoundedCompactSupport f) :
    eLpNorm (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j}, F.indicator <| adjointCarlesonSum (t u) f) 2 volume â‰¤
    C7_7_2_2 a n * densâ‚‚ (â‹ƒ u âˆˆ t, t u) ^ (2 : â„)â»Â¹ * eLpNorm f 2 volume := by
  sorry

/-- The constant used in `row_correlation`.
Has value `2 ^ (862 * a ^ 3 - 3 * n)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
irreducible_def C7_7_3 (a n : â„•) : â„â‰¥0 := 2 ^ (862 * (a : â„) ^ 3 - 2 * n)

/-- Lemma 7.7.3. -/
lemma row_correlation (hjj' : j < j') (hj' : j' < 2 ^ n)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j}, adjointCarlesonSum (t u) fâ‚ x) *
    (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j'}, adjointCarlesonSum (t u) fâ‚‚ x)â€–â‚Š â‰¤
    C7_7_3 a n * eLpNorm fâ‚ 2 volume * eLpNorm fâ‚‚ 2 volume := by
  sorry

variable (t) in
/-- The definition of `Eâ±¼` defined above Lemma 7.7.4. -/
def rowSupport (j : â„•) : Set X := â‹ƒ (u âˆˆ rowDecomp t j) (p âˆˆ t u), E p

/-- Lemma 7.7.4 -/
lemma pairwiseDisjoint_rowSupport :
    (Iio (2 ^ n)).PairwiseDisjoint (rowSupport t) := by
  sorry

end TileStructure.Forest

/-! ## Proposition 2.0.4 -/

/-- The constant used in `forest_operator`.
Has value `2 ^ (432 * a ^ 3 - (q - 1) / q * n)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
irreducible_def C2_0_4 (a q : â„) (n : â„•) : â„â‰¥0 := 2 ^ (432 * a ^ 3 - (q - 1) / q * n)

theorem forest_operator {n : â„•} (ğ”‰ : Forest X n) {f g : X â†’ â„‚}
    (hf : Measurable f) (h2f : âˆ€ x, â€–f xâ€– â‰¤ F.indicator 1 x) (hg : Measurable g)
    (h2g : IsBounded (support g)) :
    â€–âˆ« x, conj (g x) * âˆ‘ u âˆˆ { p | p âˆˆ ğ”‰ }, carlesonSum (ğ”‰ u) f xâ€–â‚Š â‰¤
    C2_0_4 a q n * (densâ‚‚ (â‹ƒ u âˆˆ ğ”‰, ğ”‰ u)) ^ (qâ»Â¹ - 2â»Â¹) *
    eLpNorm f 2 volume * eLpNorm g 2 volume := by
  sorry

lemma ennnorm_integral_starRingEnd_mul_eq_lintegral_ennnorm
    {ğ•œ : Type*} [RCLike ğ•œ] {Î± : Type*} [MeasurableSpace Î±] {Î¼ : Measure Î±} {f : Î± â†’ ğ•œ}
    (hf : Integrable f Î¼) :
    âˆ«â» x, â€–f xâ€–â‚Š âˆ‚Î¼ = â€–âˆ« x, starRingEnd ğ•œ (f x / â€–f xâ€–) * f x âˆ‚Î¼â€–â‚Š := by
  have A x : starRingEnd ğ•œ (f x / â€–f xâ€–) * f x = â€–f xâ€– := by
    simp only [div_eq_inv_mul, map_mul, map_invâ‚€, RCLike.conj_ofReal, mul_assoc, RCLike.conj_mul]
    norm_cast
    rcases eq_or_ne (â€–f xâ€–) 0 with hx | hx
    Â· simp [hx]
    Â· rw [pow_two, inv_mul_cancel_leftâ‚€ hx]
  simp_rw [A, integral_ofReal, nnnorm_algebraMap']
  rw [lintegral_coe_eq_integral]; swap
  Â· simpa only [coe_nnnorm] using hf.norm
  simp only [coe_nnnorm, ENNReal.ofReal, ENNReal.coe_inj]
  have : |âˆ« (a : Î±), â€–f aâ€– âˆ‚Î¼| = âˆ« (a : Î±), â€–f aâ€– âˆ‚Î¼ := by
    apply abs_eq_self.2
    exact integral_nonneg (fun x â†¦ by positivity)
  conv_lhs => rw [â† this]
  simp only [Real.norm_eq_abs, Real.toNNReal_abs]
  rfl

/-- Verion of the forest operator theorem, but controlling the integral of the norm instead of
the integral of the function muliplied by another function. -/
theorem forest_operator' {n : â„•} (ğ”‰ : Forest X n) {f : X â†’ â„‚} {A : Set X}
    (hf : Measurable f) (h2f : âˆ€ x, â€–f xâ€– â‰¤ F.indicator 1 x) (hA : MeasurableSet A)
    (h'A : IsBounded A) :
    âˆ«â» x in A, â€–âˆ‘ u âˆˆ { p | p âˆˆ ğ”‰ }, carlesonSum (ğ”‰ u) f xâ€–â‚Š â‰¤
    C2_0_4 a q n * (densâ‚‚ (â‹ƒ u âˆˆ ğ”‰, ğ”‰ u)) ^ (qâ»Â¹ - 2â»Â¹) *
    eLpNorm f 2 volume * (volume A) ^ (1/2 : â„) := by
  /- This follows from the other version by taking for the test function `g` the argument of
  the sum to be controlled. -/
  rw [ennnorm_integral_starRingEnd_mul_eq_lintegral_ennnorm]; swap
  Â· apply BoundedCompactSupport.integrable
    apply BoundedCompactSupport.finset_sum (fun i hi â†¦ ?_)
    apply BoundedCompactSupport.carlesonSum
    have : BoundedCompactSupport (F.indicator 1 : X â†’ â„) := by
      apply BoundedCompactSupport.indicator_of_isBounded_range _ stronglyMeasurable_one _
        measurableSet_F
      Â· exact isBounded_range_iff_forall_norm_le.2 âŸ¨1, fun x â†¦ by simpâŸ©
      Â· exact PreProofData.isBounded_F
    apply BoundedCompactSupport.mono this hf.stronglyMeasurable h2f
  rw [â† integral_indicator hA]
  simp_rw [indicator_mul_left, â† comp_def,
    Set.indicator_comp_of_zero (g := starRingEnd â„‚) (by simp)]
  apply (forest_operator ğ”‰ hf h2f ?_ ?_).trans; rotate_left
  Â· apply Measurable.indicator _ hA
    fun_prop
  Â· apply h'A.subset support_indicator_subset
  gcongr
  Â· have := (q_mem_Ioc (X := X)).2
    simp only [sub_nonneg, ge_iff_le, inv_le_invâ‚€ zero_lt_two (q_pos X)]
    exact (q_mem_Ioc (X := X)).2
  Â· exact le_rfl
  calc
  _ â‰¤ eLpNorm (A.indicator (fun x â†¦ 1) : X â†’ â„) 2 volume := by
    apply eLpNorm_mono (fun x â†¦ ?_)
    simp only [indicator, norm_eq_abs, coe_algebraMap, Pi.one_apply, Real.norm_eq_abs]
    split_ifs
    Â· have A (x : â„) : x / x â‰¤ 1 := by
        rcases eq_or_ne x 0 with rfl | hx
        Â· simp
        Â· simp [hx]
      simpa using A _
    Â· simp
  _ â‰¤ _ := by
    rw [eLpNorm_indicator_const]
    Â· simp
    Â· exact hA
    Â· norm_num
    Â· norm_num
