import Carleson.ForestOperator.PointwiseEstimate
import Carleson.ToMathlib.MeasureTheory.Integral.MeanInequalities

noncomputable section

open Set MeasureTheory Metric Function Complex Bornology TileStructure Filter
open scoped NNReal ENNReal ComplexConjugate

open ShortVariables
variable {X : Type*} {a : ‚Ñï} {q : ‚Ñù} {K : X ‚Üí X ‚Üí ‚ÑÇ} {œÉ‚ÇÅ œÉ‚ÇÇ : X ‚Üí ‚Ñ§} {F G : Set X}
  [MetricSpace X] [ProofData a q K œÉ‚ÇÅ œÉ‚ÇÇ F G] {f : X ‚Üí ‚ÑÇ}

lemma integrableOn_K_mul_f {x' : X} (hf : BoundedCompactSupport f volume) {r : ‚Ñù‚â•0‚àû} (hr : 0 < r) :
    IntegrableOn (fun y ‚Ü¶ K x' y * f y) (EAnnulus.ci x' r) := by
  by_cases supp_f : (support f).Nonempty; swap
  ¬∑ simp [Function.support_eq_empty_iff.mp <| Set.not_nonempty_iff_eq_empty.mp supp_f]
  by_cases r_top : r = ‚ä§
  ¬∑ simp [r_top]
  have ‚ü®x'', hx''‚ü© := supp_f
  have ‚ü®C, hC‚ü© := Metric.isBounded_iff.mp hf.isBoundedSupport
  have : support (fun y ‚Ü¶ f y * K x' y) ‚äÜ closedBall x' (dist x' x'' + C) := by
    intro y hy
    have : y ‚àà support f := by contrapose! hy; simp [hy]
    exact mem_closedBall'.mp <| (dist_triangle x' x'' y).trans <| add_le_add_left (hC hx'' this) _
  simp_rw [mul_comm (K x' _), IntegrableOn, ‚Üê integrableOn_iff_integrable_of_support_subset this]
  apply hf.restrict.restrict.integrable_mul
  rw [Measure.restrict_restrict measurableSet_closedBall, inter_comm, ‚Üê IntegrableOn]
  convert integrableOn_K_Icc (K := K) (R := dist x' x'' + C) (r.toReal_pos hr.ne.symm r_top) using 1
  ext y
  simp [edist_dist, dist_comm y, EAnnulus.ci, ENNReal.le_ofReal_iff_toReal_le r_top dist_nonneg]

-- Truncated version of `K` used in proof of `nontangential_pointwise_bound`
private def K' (b : ‚Ñ§) (c : ‚Ñ§) (x y : X) := ‚àë i ‚àà (Icc b c).toFinset, Ks i x y

namespace K'

private lemma eq_K (b : ‚Ñ§) (c : ‚Ñ§) (x y : X)
    (h : dist x y ‚àà Icc ((D : ‚Ñù) ^ (b - 1) / 2) (D ^ c / 4)) : K' b c x y = K x y := by
  have hxy : dist x y > 0 := lt_of_lt_of_le (div_pos (defaultD_pow_pos a (b - 1)) two_pos) h.1
  simp_rw [K', Ks, ‚Üê Finset.mul_sum, ‚Üê Complex.ofReal_sum]
  rw [‚Üê finsum_eq_sum_of_support_subset, finsum_œà (one_lt_realD X) hxy, ofReal_one, mul_one]
  rw [toFinset_Icc, Finset.coe_Icc]
  exact support_œàS_subset_Icc (one_lt_realD X) h

private lemma integrableOn_mul_f {x' : X} (hf : BoundedCompactSupport f) {r : ‚Ñù‚â•0‚àû} (hr : 0 < r)
    (s‚ÇÅ s‚ÇÇ : ‚Ñ§) : IntegrableOn (fun y ‚Ü¶ K' s‚ÇÅ s‚ÇÇ x' y * f y) (EAnnulus.ci x' r) := by
  simp_rw [K', Ks, mul_comm (K x' _) (œà _), ‚Üê Finset.sum_mul, mul_assoc]
  apply Integrable.bdd_mul (integrableOn_K_mul_f hf hr)
  ¬∑ refine (Finset.aestronglyMeasurable_sum _ (fun i hi ‚Ü¶ ?_)).restrict
    apply continuous_ofReal.comp_aestronglyMeasurable ‚àò continuous_œà.comp_aestronglyMeasurable
    exact (continuous_const.dist continuous_id').aestronglyMeasurable.const_mul _
  ¬∑ refine ‚ü®(s‚ÇÇ + 1 - s‚ÇÅ).toNat, fun _ ‚Ü¶ le_trans (norm_sum_le ..) ?_‚ü©
    simp_rw [norm_real]
    exact le_of_le_of_eq (Finset.sum_le_sum fun _ _ ‚Ü¶ abs_œà_le_one _ _) (by simp)

private lemma support_subset (b : ‚Ñ§) (c : ‚Ñ§) (x : X) :
    support (K' b c x) ‚äÜ Annulus.cc x (D ^ (b - 1) / 4) (D ^ c / 2) := by
  refine subset_trans ?_ (Annulus.oo_subset_cc (le_refl _) (le_refl _))
  intro y hy
  rw [mem_support] at hy
  simp only [Annulus.oo, mem_Ioo, mem_setOf_eq]
  contrapose! hy
  refine Finset.sum_eq_zero (fun s hs ‚Ü¶ ?_)
  rw [toFinset_Icc] at hs
  suffices ((D : ‚Ñù) ^ s)‚Åª¬π * dist x y ‚àâ support œà by simp [Ks, notMem_support.mp this, -defaultD]
  rw [support_œà (one_lt_realD X), mem_Ioo, not_and_or]
  rcases lt_or_ge ((D : ‚Ñù) ^ (b - 1) / 4) (dist x y) with h | h
  ¬∑ push_neg; right
    calc
      _ ‚â• ((D : ‚Ñù) ^ c)‚Åª¬π * (D ^ c / 2) := by
        gcongr
        ¬∑ exact defaultD_pow_pos a s
        ¬∑ exact one_le_realD _
        ¬∑ exact (Finset.mem_Icc.mp hs).2
        ¬∑ exact hy h
      _ = _ := by field_simp
  ¬∑ push_neg; left
    calc
      _ ‚â§ ((D : ‚Ñù) ^ b)‚Åª¬π * (D ^ (b - 1) / 4) := by
        refine mul_le_mul ?_ h dist_nonneg ?_
        ¬∑ apply inv_anti‚ÇÄ (defaultD_pow_pos a b)
          exact zpow_right_mono‚ÇÄ (one_le_realD _) (Finset.mem_Icc.mp hs).1
        ¬∑ exact inv_nonneg.mpr (defaultD_pow_pos a b).le
      _ = _ := by rw [zpow_sub‚ÇÄ (realD_pos a).ne.symm]; field_simp; apply mul_comm

private lemma enorm_le_enorm_K (a : ‚Ñ§) (b : ‚Ñ§) (x y : X) : ‚ÄñK' a b x y‚Äñ‚Çë ‚â§ ‚ÄñK x y‚Äñ‚Çë := by
  unfold K' Ks
  by_cases hxy : 0 = dist x y
  ¬∑ simp [‚Üê hxy, psi_zero]
  rw [‚Üê mul_one ‚ÄñK x y‚Äñ‚Çë, ‚Üê Finset.mul_sum, enorm_mul]
  apply mul_le_mul_left'
  rw [enorm_eq_nnnorm]
  norm_cast
  apply le_trans <| nnnorm_sum_le _ _
  simp_rw [‚Üê norm_toNNReal, Real.norm_eq_abs, ‚Üê Real.toNNReal_sum_of_nonneg fun _ _ ‚Ü¶ abs_nonneg _,
    Real.toNNReal_le_one, abs_eq_self.mpr <| zero_le_œà _ _]
  exact sum_œà_le (one_lt_realD X) _ <| lt_of_le_of_ne dist_nonneg hxy

end K'

-- Bound needed for proof of `nontangential_pointwise_bound`, splitting the annulus between radii
-- `r‚ÇÅ` and `r‚ÇÑ` into annuli between `r‚ÇÅ` and `r‚ÇÇ`, between `r‚ÇÇ` and `r‚ÇÉ`, and between `r‚ÇÉ` and
-- `r‚ÇÑ`. Note that we assume only `r‚ÇÅ ‚â§ r‚ÇÇ` and `r‚ÇÉ ‚â§ r‚ÇÑ`.
private lemma annulus_integral_bound {x : X} {g : X ‚Üí ‚ÑÇ} {r‚ÇÅ r‚ÇÇ r‚ÇÉ r‚ÇÑ : ‚Ñù} (h‚ÇÅ‚ÇÇ : r‚ÇÅ ‚â§ r‚ÇÇ)
    (h‚ÇÉ‚ÇÑ : r‚ÇÉ ‚â§ r‚ÇÑ) (hg : IntegrableOn g (Annulus.cc x r‚ÇÅ r‚ÇÑ)) :
    ‚Äñ‚à´ y in Annulus.cc x r‚ÇÅ r‚ÇÑ, g y‚Äñ‚Çë ‚â§ ‚Äñ‚à´ y in Annulus.oc x r‚ÇÇ r‚ÇÉ, g y‚Äñ‚Çë +
    ((‚à´‚Åª y in Annulus.cc x r‚ÇÅ r‚ÇÇ, ‚Äñg y‚Äñ‚Çë) + ‚à´‚Åª y in Annulus.cc x r‚ÇÉ r‚ÇÑ, ‚Äñg y‚Äñ‚Çë) :=
  calc
    _ = ‚Äñ(‚à´ y in Annulus.cc x r‚ÇÅ r‚ÇÑ ‚à© Annulus.oc x r‚ÇÇ r‚ÇÉ, g y) +
        ‚à´ y in Annulus.cc x r‚ÇÅ r‚ÇÑ ‚à© (Annulus.oc x r‚ÇÇ r‚ÇÉ)·∂ú, g y‚Äñ‚Çë := by
      congr 1
      rw [‚Üê setIntegral_union (disjoint_left.mpr (fun _ h‚ÇÅ h‚ÇÇ ‚Ü¶ h‚ÇÇ.2 h‚ÇÅ.2)) (by measurability),
        inter_union_compl] <;> exact hg.mono_set inter_subset_left
  _ ‚â§ ‚Äñ‚à´ y in Annulus.cc x r‚ÇÅ r‚ÇÑ ‚à© Annulus.oc x r‚ÇÇ r‚ÇÉ, g y‚Äñ‚Çë +
      ‚Äñ‚à´ y in Annulus.cc x r‚ÇÅ r‚ÇÑ ‚à© (Annulus.oc x r‚ÇÇ r‚ÇÉ)·∂ú, g y‚Äñ‚Çë := enorm_add_le _ _
  _ ‚â§ ‚Äñ‚à´ y in Annulus.oc x r‚ÇÇ r‚ÇÉ, g y‚Äñ‚Çë + ((‚à´‚Åª y in Annulus.cc x r‚ÇÅ r‚ÇÇ, ‚Äñg y‚Äñ‚Çë) +
      ‚à´‚Åª y in Annulus.oc x r‚ÇÉ r‚ÇÑ, ‚Äñg y‚Äñ‚Çë) := by
    gcongr
    ¬∑ rw [inter_eq_self_of_subset_right <| Annulus.oc_subset_cc h‚ÇÅ‚ÇÇ h‚ÇÉ‚ÇÑ]
    ¬∑ calc
        _ ‚â§ _ := enorm_integral_le_lintegral_enorm _
        _ ‚â§ ‚à´‚Åª y in Annulus.cc x r‚ÇÅ r‚ÇÇ ‚à™ Annulus.oc x r‚ÇÉ r‚ÇÑ, ‚Äñg y‚Äñ‚Çë := by
          refine lintegral_mono_set (fun y ‚Ü¶ ?_)
          simp only [Annulus.cc, mem_Icc, Annulus.oc, mem_Ioc, mem_inter_iff, mem_setOf_eq,
            mem_compl_iff, not_and, not_le, mem_union, and_imp]
          intro hr‚ÇÅ hr‚ÇÑ hr‚ÇÇ‚ÇÉ
          by_cases hr‚ÇÇ : r‚ÇÇ < dist x y
          ¬∑ exact Or.inr ‚ü®hr‚ÇÇ‚ÇÉ hr‚ÇÇ, hr‚ÇÑ‚ü©
          ¬∑ exact Or.inl ‚ü®hr‚ÇÅ, le_of_not_gt hr‚ÇÇ‚ü©
        _ ‚â§ _ := lintegral_union_le _ _ _
  _ ‚â§ _ := by gcongr; exact lintegral_mono_set (Annulus.oc_subset_cc le_rfl le_rfl)

open ShortVariables TileStructure
variable {X : Type*} {a : ‚Ñï} {q : ‚Ñù} {K : X ‚Üí X ‚Üí ‚ÑÇ} {œÉ‚ÇÅ œÉ‚ÇÇ : X ‚Üí ‚Ñ§} {F G : Set X}
  [MetricSpace X] [ProofData a q K œÉ‚ÇÅ œÉ‚ÇÇ F G] [TileStructure Q D Œ∫ S o]
  {n j j' : ‚Ñï} {t : Forest X n} {u u‚ÇÅ u‚ÇÇ p : ùîì X} {x x' : X} {ùîñ : Set (ùîì X)}
  {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : X ‚Üí ‚ÑÇ} {I J J' L : Grid X}
variable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']

namespace TileStructure.Forest

lemma eLpNorm_MB_le {ùïú : Type*} [RCLike ùïú] {f : X ‚Üí ùïú} (hf : BoundedCompactSupport f) :
    eLpNorm (MB volume ùìë cùìë rùìë f ¬∑) 2 volume ‚â§ CMB (defaultA a : ‚Ñù‚â•0) 2 * eLpNorm f 2 volume :=
  hasStrongType_MB_finite ùìë_finite one_lt_two f (hf.memLp 2) |>.2

/-! ## Section 7.2 and Lemma 7.2.1 -/

/-- The constant used in `nontangential_operator_bound`.
Has value `2 ^ (102 * a ^ 3)` in the blueprint. -/
irreducible_def C7_2_2 (a : ‚Ñï) : ‚Ñù‚â•0 := 2 ^ ((ùïî + 2) * a ^ 3)

-- Bound for (7.2.3) in the proof of `nontangential_pointwise_bound`
omit [TileStructure Q D Œ∫ S o] in
private lemma nontangential_integral_bound‚ÇÅ
    (hf : BoundedCompactSupport f) {Œ∏ : Œò X} {x x' : X} {R‚ÇÅ R‚ÇÇ : ‚Ñù}
    (hR‚ÇÅ : dist x x' < R‚ÇÅ) (hR‚ÇÇ : ENNReal.ofReal R‚ÇÇ < upperRadius Q Œ∏ x') :
    ‚Äñ‚à´ y in Annulus.oc x' R‚ÇÅ R‚ÇÇ, K x' y * f y‚Äñ‚Çë ‚â§
    2 * linearizedNontangentialOperator Q Œ∏ K f x := by
  rcases le_or_gt R‚ÇÇ R‚ÇÅ with lR‚ÇÇ | lR‚ÇÇ
  ¬∑ rw [Annulus.oc_eq_empty lR‚ÇÇ, setIntegral_empty, enorm_zero]; exact zero_le _
  have pR‚ÇÅ : 0 < R‚ÇÅ := dist_nonneg.trans_lt hR‚ÇÅ
  have pR‚ÇÇ : 0 < R‚ÇÇ := pR‚ÇÅ.trans lR‚ÇÇ
  choose R‚ÇÉ hR‚ÇÉ using exists_between hR‚ÇÇ
  have fR‚ÇÉ : R‚ÇÉ ‚â† ‚ä§ := ne_top_of_lt hR‚ÇÉ.2
  have h2R‚ÇÉ : R‚ÇÇ < R‚ÇÉ.toReal := ENNReal.ofReal_lt_iff_lt_toReal pR‚ÇÇ.le fR‚ÇÉ |>.mp hR‚ÇÉ.1
  calc
    _ = ‚Äñ‚à´ y in EAnnulus.oc x' (ENNReal.ofReal R‚ÇÅ) (ENNReal.ofReal R‚ÇÇ), K x' y * f y‚Äñ‚Çë := by
      congr; unfold Annulus.oc EAnnulus.oc; ext y
      simp_rw [mem_setOf_eq, mem_Ioc, edist_dist, ENNReal.ofReal_le_ofReal_iff pR‚ÇÇ.le,
        ENNReal.ofReal_lt_ofReal_iff_of_nonneg pR‚ÇÅ.le]
    _ = ‚Äñ(‚à´ y in EAnnulus.oo x' (ENNReal.ofReal R‚ÇÅ) R‚ÇÉ, K x' y * f y) -
        ‚à´ y in EAnnulus.oo x' (ENNReal.ofReal R‚ÇÇ) R‚ÇÉ, K x' y * f y‚Äñ‚Çë := by
      congr; rw [eq_sub_iff_add_eq, ‚Üê setIntegral_union]; rotate_left
      ¬∑ rw [disjoint_left]; intro y my
        rw [EAnnulus.oc, mem_setOf_eq, mem_Ioc] at my
        rw [EAnnulus.oo, mem_setOf_eq, mem_Ioo, not_and_or, not_lt]; exact .inl my.2
      ¬∑ exact EAnnulus.measurableSet_oo
      ¬∑ refine integrableOn_K_mul hf.integrable.restrict x' pR‚ÇÅ fun y my ‚Ü¶ ?_
        simp_rw [EAnnulus.oc, mem_Ioc, mem_setOf_eq, edist_dist] at my
        rw [ENNReal.ofReal_lt_ofReal_iff_of_nonneg pR‚ÇÅ.le] at my
        simp_rw [mem_compl_iff, mem_ball', not_lt]; exact my.1.le
      ¬∑ refine integrableOn_K_mul hf.integrable.restrict x' pR‚ÇÇ fun y my ‚Ü¶ ?_
        rw [EAnnulus.oo, mem_setOf_eq, mem_Ioo, edist_dist,
          ENNReal.ofReal_lt_ofReal_iff_of_nonneg pR‚ÇÇ.le] at my
        simp_rw [mem_compl_iff, mem_ball', not_lt]; exact my.1.le
      rw [EAnnulus.oc_union_oo ((ENNReal.ofReal_le_ofReal_iff pR‚ÇÇ.le).mpr lR‚ÇÇ.le) hR‚ÇÉ.1]
    _ ‚â§ ‚Äñ‚à´ y in EAnnulus.oo x' (ENNReal.ofReal R‚ÇÅ) R‚ÇÉ, K x' y * f y‚Äñ‚Çë +
        ‚Äñ‚à´ y in EAnnulus.oo x' (ENNReal.ofReal R‚ÇÇ) R‚ÇÉ, K x' y * f y‚Äñ‚Çë :=
      enorm_sub_le
    _ ‚â§ _ := by
      rw [two_mul]; gcongr
      ¬∑ refine le_iSup_of_le ?_ (i := R‚ÇÉ.toReal)
        refine le_iSup‚ÇÇ_of_le ?_ (i := R‚ÇÅ) (j := ‚ü®pR‚ÇÅ, lR‚ÇÇ.trans h2R‚ÇÉ‚ü©)
        refine le_iSup‚ÇÇ_of_le ?_  (i := x') (j := (mem_ball'.mpr hR‚ÇÅ))
        simp [hR‚ÇÉ.2.le, fR‚ÇÉ]
      ¬∑ refine le_iSup_of_le ?_ (i := R‚ÇÉ.toReal)
        refine le_iSup‚ÇÇ_of_le ?_ (i := R‚ÇÇ) (j := ‚ü®pR‚ÇÇ, h2R‚ÇÉ‚ü©)
        refine le_iSup‚ÇÇ_of_le ?_  (i := x') (j := (mem_ball'.mpr <| hR‚ÇÅ.trans lR‚ÇÇ))
        simp [hR‚ÇÉ.2.le, fR‚ÇÉ]

-- Bound for (7.2.4) and (7.2.5) in the proof of `nontangential_pointwise_bound`
private lemma nontangential_integral_bound‚ÇÇ (hf : BoundedCompactSupport f) {x x' : X}
    {I : Grid X} (hx : x ‚àà I) (hx' : x' ‚àà I) {R : ‚Ñù} (h : R ‚â§ 8 * D ^ s I) :
    ‚à´‚Åª y in Annulus.cc x' ((D : ‚Ñù) ^ (s I - 1) / 4) R, ‚ÄñK x' y * f y‚Äñ‚Çë ‚â§
    2 ^ (7 * a + (ùïî + 1) * a ^ 3) * MB volume ùìë cùìë rùìë f x := by
  apply (lintegral_mono_set (Annulus.cc_subset_cc (le_refl _) h)).trans
  have ineq : ‚àÄ y ‚àà Annulus.cc x' ((D : ‚Ñù) ^ (s I - 1) / 4) (8 * D ^ s I), ‚ÄñK x' y * f y‚Äñ‚Çë ‚â§
      2 ^ (7 * a + (ùïî + 1) * a ^ 3) / volume (ball (c I) (16 * D ^ s I)) * ‚Äñf y‚Äñ‚Çë := by
    intro y hy; rw [Annulus.cc] at hy; rw [enorm_mul]
    refine mul_le_mul_right' ((enorm_K_le 5 hy.1).trans ?_) ‚Äñf y‚Äñ‚Çë; gcongr
    suffices dist (c I) x' < 16 * D ^ s I from ball_subset_ball' (by linarith)
    rw [‚Üê mem_ball', s]
    refine ball_subset_ball ?_ (Grid_subset_ball hx')
    linarith [defaultD_pow_pos a (GridStructure.s I)]
  apply le_trans <| setLIntegral_mono_ae (hf.aestronglyMeasurable.enorm.const_mul _).restrict
    (.of_forall ineq)
  simp_rw [ENNReal.mul_comm_div, div_eq_mul_inv]
  have := hf.aestronglyMeasurable.enorm
  rw [lintegral_const_mul'' _ (this.mul_const _).restrict, lintegral_mul_const'' _ this.restrict,
    ‚Üê div_eq_mul_inv]
  apply mul_left_mono
  calc
    _ ‚â§ (‚à´‚Åª y in ball (c I) (16 * D ^ s I), ‚Äñf y‚Äñ‚Çë) / volume (ball (c I) (16 * D ^ s I)) := by
      gcongr
      refine lintegral_mono' (Measure.le_iff.mpr (fun T hT ‚Ü¶  ?_)) (le_refl _)
      rw [Measure.restrict_apply hT, Measure.restrict_apply hT]
      refine measure_mono (inter_subset_inter_right T (fun y ‚Ü¶ ?_))
      simp only [Annulus.cc, mem_Icc, mem_setOf_eq, mem_ball, and_imp, dist_comm x']
      intro _ h
      calc dist y (c I)
        _ ‚â§ dist y x' + dist x' (c I) := dist_triangle y x' (c I)
        _ ‚â§ 8 * (D : ‚Ñù) ^ s I + 4 * (D : ‚Ñù) ^ s I :=
          add_le_add h (mem_ball.mp (Grid_subset_ball hx')).le
        _ < 16 * (D : ‚Ñù) ^ s I := by linarith [defaultD_pow_pos a (s I)]
    _ = ‚®ç‚Åª y in ball (c I) (16 * D ^ s I), ‚Äñf y‚Äñ‚Çë ‚àÇvolume := by rw [setLAverage_eq]
    _ ‚â§ MB volume ùìë cùìë rùìë f x := by
      rw [MB_def]
      have : (4, 0, I) ‚àà ùìë := by simp [ùìë]
      refine le_of_eq_of_le ?_ (le_biSup _ this)
      have : x ‚àà ball (c I) (2 ^ 4 * (D : ‚Ñù) ^ s I) := by
        refine (ball_subset_ball ?_) (Grid_subset_ball hx)
        unfold s
        linarith [defaultD_pow_pos a (GridStructure.s I)]
      simp_rw [cùìë, rùìë, Nat.cast_zero, add_zero, indicator_of_mem this, enorm_eq_nnnorm]
      norm_num

-- Pointwise bound needed for Lemma 7.2.2
private lemma nontangential_pointwise_bound (hf : BoundedCompactSupport f) (Œ∏ : Œò X) (x : X) :
    nontangentialMaximalFunction Œ∏ f x ‚â§
    2 * linearizedNontangentialOperator Q Œ∏ K f x +
    2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * MB volume ùìë cùìë rùìë f x := by
  refine iSup‚ÇÇ_le fun I hI ‚Ü¶ iSup‚ÇÇ_le fun x' hx' ‚Ü¶ iSup‚ÇÇ_le fun s‚ÇÇ ms‚ÇÇ ‚Ü¶ iSup_le fun ls‚ÇÇ ‚Ü¶ ?_
  rw [‚Üê integral_finset_sum]; swap
  ¬∑ intro i hi; simp_rw [mul_comm]
    exact hf.integrable_mul (integrable_Ks_x (one_lt_realD X))
  simp_rw [‚Üê Finset.sum_mul]
  have ineq {n : ‚Ñï} (hn : n > 0) : (D : ‚Ñù) ^ (s I - 1) / n < 8 * D ^ s I := by
    rw [zpow_sub‚ÇÄ (realD_pos a).ne.symm, div_div, zpow_one]
    calc (D : ‚Ñù) ^ s I / ((D : ‚Ñù) * n)
      _ ‚â§ D ^ s I / 1 := by gcongr; exact_mod_cast (mul_pos (defaultD_pos a) hn)
      _ < 8 * D ^ s I := by linarith [defaultD_pow_pos a (s I)]
  calc
    _ = ‚Äñ‚à´ y in Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s‚ÇÇ / 2), K' (s I) s‚ÇÇ x' y * f y‚Äñ‚Çë := by
      rw [‚Üê integral_indicator Annulus.measurableSet_cc]
      congr; ext y
      by_cases hy : y ‚àà Annulus.cc x' (D ^ (s I - 1) / 4) (D ^ s‚ÇÇ / 2)
      ¬∑ simp only [K', hy, indicator_of_mem]
      ¬∑ have K'_eq_zero := notMem_support.mp <| notMem_subset (K'.support_subset (s I) s‚ÇÇ x') hy
        rw [‚Üê K', K'_eq_zero, zero_mul, indicator_of_notMem hy]
    _ ‚â§ ‚Äñ‚à´ y in Annulus.oc x' (8 * D ^ s I) (D ^ (s‚ÇÇ - 1) / 4), K' (s I) s‚ÇÇ x' y * f y‚Äñ‚Çë +
        ((‚à´‚Åª y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ s I), ‚ÄñK' (s I) s‚ÇÇ x' y * f y‚Äñ‚Çë) +
        ‚à´‚Åª y in Annulus.cc x' (D ^ (s‚ÇÇ - 1) / 4) (D ^ s‚ÇÇ / 2), ‚ÄñK' (s I) s‚ÇÇ x' y * f y‚Äñ‚Çë) := by
      apply annulus_integral_bound
      ¬∑ exact (ineq four_pos).le
      ¬∑ gcongr
        ¬∑ exact one_le_realD _
        ¬∑ omega
        ¬∑ norm_num
      ¬∑ refine K'.integrableOn_mul_f hf (r := ENNReal.ofReal (D ^ (s I - 1) / 4)) ?_ (s I) s‚ÇÇ
          |>.mono_set ?_
        ¬∑ exact ENNReal.ofReal_pos.mpr <| div_pos (defaultD_pow_pos a (s I - 1)) four_pos
        ¬∑ rw [EAnnulus.ci_eq_annulus]
          exact Annulus.cc_subset_ci (le_refl _)
    _ ‚â§ ‚Äñ‚à´ y in Annulus.oc x' (8 * D ^ s I) (D ^ (s‚ÇÇ - 1) / 4), K x' y * f y‚Äñ‚Çë +
        ((‚à´‚Åª y in Annulus.cc x' (D ^ (s I - 1) / 4) (8 * D ^ s I), ‚ÄñK x' y * f y‚Äñ‚Çë) +
        ‚à´‚Åª y in Annulus.cc x' (D ^ (s‚ÇÇ - 1) / 4) (D ^ s‚ÇÇ / 2), ‚ÄñK x' y * f y‚Äñ‚Çë) := by
      have norm_K'_f_le : ‚àÄ (y : X), ‚ÄñK' (s I) s‚ÇÇ x' y * f y‚Äñ‚Çë ‚â§ ‚ÄñK x' y * f y‚Äñ‚Çë := by
        simp_rw [enorm_mul]
        exact fun y ‚Ü¶ mul_le_mul_of_nonneg_right (K'.enorm_le_enorm_K _ _ _ _) (zero_le _)
      gcongr
      ¬∑ refine (congrArg (‚Äñ¬∑‚Äñ‚Çë) <| setIntegral_congr_fun Annulus.measurableSet_oc fun y hy ‚Ü¶ ?_).le
        apply mul_eq_mul_right_iff.mpr ‚àò Or.inl ‚àò K'.eq_K (s I) s‚ÇÇ x' y
        refine mem_Icc.mpr ‚ü®(lt_trans (ineq two_pos) hy.1).le, hy.2.trans ?_‚ü©
        rw [zpow_sub‚ÇÄ (realD_pos a).ne.symm, div_div, zpow_one]
        have : (D : ‚Ñù) * 4 > 0 := mul_pos (realD_pos a) four_pos
        apply (div_le_div_iff_of_pos_left (defaultD_pow_pos a s‚ÇÇ) this four_pos).mpr
        norm_cast
        linarith [defaultD_pos a]
      ¬∑ exact norm_K'_f_le _
      ¬∑ exact norm_K'_f_le _
    _ ‚â§ 2 * linearizedNontangentialOperator Q Œ∏ K f x +
        (2 ^ (7 * a + (ùïî + 1) * a ^ 3) * MB volume ùìë cùìë rùìë f x +
        2 ^ (7 * a + (ùïî + 1) * a ^ 3) * MB volume ùìë cùìë rùìë f x) := by
      gcongr
      ¬∑ refine nontangential_integral_bound‚ÇÅ hf ?_ ?_
        ¬∑ apply lt_of_le_of_lt (dist_triangle x (c I) x')
          replace hI := mem_ball.mp (Grid_subset_ball hI)
          replace hx' := mem_ball'.mp (Grid_subset_ball hx')
          apply lt_of_lt_of_eq (add_lt_add hI hx')
          unfold s; ring
        ¬∑ refine lt_of_lt_of_le ?_ ls‚ÇÇ
          rw [ENNReal.ofReal_lt_ofReal_iff (defaultD_pow_pos a _), ‚Üê mul_one (_ / _)]
          nth_rw 2 [‚Üê div_mul_cancel‚ÇÄ ((D : ‚Ñù) ^ (s‚ÇÇ - 1)) four_ne_zero]
          gcongr
          ¬∑ unfold defaultD; positivity
          ¬∑ norm_num
      ¬∑ exact nontangential_integral_bound‚ÇÇ hf hI hx' (le_refl _)
      ¬∑ let I‚ÇÇ := cubeOf s‚ÇÇ x
        have hs‚ÇÇ' : s‚ÇÇ ‚àà Icc (-(S : ‚Ñ§)) (S : ‚Ñ§) :=
          Icc_subset_Icc (Set.range_subset_iff.mp range_s_subset I |>.1) (le_refl (S : ‚Ñ§)) ms‚ÇÇ
        have ‚ü®xI‚ÇÇ, hI‚ÇÇ‚ü© := cubeOf_spec hs‚ÇÇ' I hI
        rw [‚Üê hI‚ÇÇ]
        have : s I ‚â§ s I‚ÇÇ := by rw [hI‚ÇÇ]; exact ms‚ÇÇ.1
        have := (fundamental_dyadic this).resolve_right (Set.not_disjoint_iff.mpr ‚ü®x, ‚ü®hI, xI‚ÇÇ‚ü©‚ü©)
        apply nontangential_integral_bound‚ÇÇ hf xI‚ÇÇ (this hx')
        linarith [defaultD_pow_pos a (s (cubeOf s‚ÇÇ x))]
    _ = _ := by rw [‚Üê two_mul, ‚Üê mul_assoc, ‚Üê pow_succ']

lemma le_C7_2_2 (a4 : 4 ‚â§ a) :
    2 * C_Ts a + 2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * CMB (defaultA a) 2 ‚â§ C7_2_2 a := by
  rw [C_Ts, CMB_defaultA_two_eq]
  calc
    _ ‚â§ (2 : ‚Ñù‚â•0) ^ (a ^ 3 + 1) + 2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * 2 ^ (a + 2) := by
      rw [‚Üê pow_succ']; gcongr; rw [‚Üê NNReal.rpow_natCast]; push_cast; gcongr <;> norm_num
    _ ‚â§ 2 ^ ((ùïî + 1) * a ^ 3 + 8 * a + 3) + 2 ^ ((ùïî + 1) * a ^ 3 + 8 * a + 3) := by
      rw [‚Üê pow_add]; gcongr 2 ^ ?_ + 2 ^ ?_
      ¬∑ exact one_le_two
      ¬∑ rw [show a ^ 3 + 1 = 1 * a ^ 3 + 1 by ring, add_assoc]; gcongr
        ¬∑ norm_num
        ¬∑ omega
      ¬∑ exact one_le_two
      ¬∑ ring_nf; rfl
    _ = 2 ^ ((ùïî + 1) * a ^ 3 + 8 * a + 4) := by rw [‚Üê two_mul, ‚Üê pow_succ']
    _ ‚â§ _ := by
      rw [C7_2_2, add_assoc, show (ùïî + 2) * a ^ 3 = (ùïî + 1) * a ^ 3 + a ^ 3 by ring]
      gcongr; ¬∑ exact one_le_two
      calc
        _ ‚â§ 4 * 4 * a := by omega
        _ ‚â§ _ := by rw [pow_three']; gcongr

/-- Lemma 7.2.2. -/
lemma nontangential_operator_bound (hf : BoundedCompactSupport f) (Œ∏ : Œò X) :
    eLpNorm (nontangentialMaximalFunction Œ∏ f) 2 volume ‚â§ C7_2_2 a * eLpNorm f 2 volume := by
  have aemeas_MB : AEMeasurable (MB volume ùìë cùìë rùìë f ¬∑) :=
    (AEStronglyMeasurable.maximalFunction (to_countable ùìë)).aemeasurable
  have ‚ü®hT‚ÇÅ, hT‚ÇÇ‚ü© := BST_T_Q Œ∏ f hf.boundedFiniteSupport
  dsimp only at hT‚ÇÅ hT‚ÇÇ
  calc
    _ ‚â§ eLpNorm (fun x ‚Ü¶ 2 * linearizedNontangentialOperator Q Œ∏ K f x +
        2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * MB volume ùìë cùìë rùìë f x) 2 volume := by
      simp only [eLpNorm, OfNat.ofNat_ne_zero, reduceIte, ENNReal.ofNat_ne_top, eLpNorm']
      gcongr; simp_rw [enorm_eq_self]; exact nontangential_pointwise_bound hf Œ∏ _
    _ ‚â§ eLpNorm (fun x ‚Ü¶ 2 * linearizedNontangentialOperator Q Œ∏ K f x) 2 volume +
        eLpNorm (2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * MB volume ùìë cùìë rùìë f ¬∑) 2 volume := by
      simpa [eLpNorm, eLpNorm'] using
        ENNReal.lintegral_Lp_add_le (hT‚ÇÅ.aemeasurable.const_mul _)
          (aemeas_MB.const_mul _) one_le_two
    _ = eLpNorm (fun x ‚Ü¶ 2 * linearizedNontangentialOperator Q Œ∏ K f x) 2 volume +
        2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * eLpNorm (MB volume ùìë cùìë rùìë f ¬∑) 2 volume := by
      congr
      simp only [eLpNorm, eLpNorm', OfNat.ofNat_ne_zero, reduceIte, ENNReal.ofNat_ne_top]
      exact ENNReal.lintegral_Lp_smul aemeas_MB two_pos ((2 : ‚Ñù‚â•0) ^ (7 * a + (ùïî + 1) * a ^ 3 + 1))
    _ ‚â§ 2 * eLpNorm (linearizedNontangentialOperator Q Œ∏ K f) 2 volume +
        2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * eLpNorm (MB volume ùìë cùìë rùìë f ¬∑) 2 volume := by
      gcongr
      refine eLpNorm_le_mul_eLpNorm_of_ae_le_mul'' 2 hT‚ÇÅ (.of_forall fun x ‚Ü¶ ?_)
      rw [enorm_eq_self, enorm_eq_self]
    _ ‚â§ (2 * C_Ts a + 2 ^ (7 * a + (ùïî + 1) * a ^ 3 + 1) * CMB (defaultA a) 2)
        * eLpNorm f 2 volume := by
      simp only [add_mul, one_mul, Nat.cast_pow, Nat.cast_ofNat, mul_assoc]
      gcongr
      simpa using eLpNorm_MB_le hf
    _ ‚â§ _ := by
      simp_rw [show (2 : ‚Ñù‚â•0‚àû) = (2 : ‚Ñù‚â•0) by rfl, ‚Üê ENNReal.coe_pow, ‚Üê ENNReal.coe_mul,
        ‚Üê ENNReal.coe_add]
      gcongr; exact le_C7_2_2 (four_le_a X)

open scoped Classical in
/-- The set of cubes in Lemma 7.2.4. -/
def kissing (I : Grid X) : Finset (Grid X) :=
  {J | s J = s I ‚àß ¬¨Disjoint (ball (c I) (16 * D ^ s I)) (ball (c J) (16 * D ^ s J))}

lemma subset_of_kissing (h : J ‚àà kissing I) :
    ball (c J) (D ^ s J / 4) ‚äÜ ball (c I) (33 * D ^ s I) := by
  simp_rw [kissing, Finset.mem_filter_univ] at h
  obtain ‚ü®x, xI, xJ‚ü© := not_disjoint_iff.mp h.2
  apply ball_subset_ball'
  calc
    _ ‚â§ D ^ s J / 4 + dist (c J) x + dist x (c I) := by
      rw [add_assoc]; exact add_le_add_left (dist_triangle ..) _
    _ ‚â§ D ^ s J / 4 + 16 * D ^ s J + 16 * D ^ s I := by
      gcongr
      ¬∑ exact (mem_ball'.mp xJ).le
      ¬∑ exact (mem_ball.mp xI).le
    _ ‚â§ _ := by
      rw [h.1, div_eq_mul_inv, mul_comm _ 4‚Åª¬π, ‚Üê distrib_three_right]
      gcongr
      norm_num

lemma volume_le_of_kissing (h : J ‚àà kissing I) :
    volume (ball (c I) (33 * D ^ s I)) ‚â§ 2 ^ (9 * a) * volume (ball (c J) (D ^ s J / 4)) := by
  simp_rw [kissing, Finset.mem_filter_univ] at h
  obtain ‚ü®x, xI, xJ‚ü© := not_disjoint_iff.mp h.2
  have : ball (c I) (33 * D ^ s I) ‚äÜ ball (c J) (128 * D ^ s J) := by
    apply ball_subset_ball'
    calc
      _ ‚â§ 33 * D ^ s I + dist (c I) x + dist x (c J) := by
        rw [add_assoc]; exact add_le_add_left (dist_triangle ..) _
      _ ‚â§ 33 * D ^ s I + 16 * D ^ s I + 16 * D ^ s J := by
        gcongr
        ¬∑ exact (mem_ball'.mp xI).le
        ¬∑ exact (mem_ball.mp xJ).le
      _ ‚â§ _ := by
        rw [h.1, ‚Üê distrib_three_right]
        gcongr; norm_num
  have double := @measure_ball_two_le_same_iterate X _ _ _ volume _ (c J) (D ^ s J / 4) 9
  have A9 : (defaultA a : ‚Ñù‚â•0) ^ 9 = (2 : ‚Ñù‚â•0‚àû) ^ (9 * a) := by
    simp only [defaultA]; norm_cast; ring
  rw [show (2 : ‚Ñù) ^ 9 * (D ^ s J / 4) = 128 * D ^ s J by ring, A9] at double
  exact (measure_mono this).trans double

lemma pairwiseDisjoint_of_kissing :
    (kissing I).toSet.PairwiseDisjoint fun i ‚Ü¶ ball (c i) (D ^ s i / 4) := fun j mj k mk hn ‚Ü¶ by
  apply disjoint_of_subset ball_subset_Grid ball_subset_Grid
  simp_rw [Finset.mem_coe, kissing, Finset.mem_filter] at mj mk
  exact (eq_or_disjoint (mj.2.1.trans mk.2.1.symm)).resolve_left hn

/-- Lemma 7.2.4. -/
lemma boundary_overlap (I : Grid X) : (kissing I).card ‚â§ 2 ^ (9 * a) := by
  have key : (kissing I).card * volume (ball (c I) (33 * D ^ s I)) ‚â§
      2 ^ (9 * a) * volume (ball (c I) (33 * D ^ s I)) := by
    calc
      _ = ‚àë _ ‚àà kissing I, volume (ball (c I) (33 * D ^ s I)) := by
        rw [Finset.sum_const, nsmul_eq_mul]
      _ ‚â§ ‚àë J ‚àà kissing I, 2 ^ (9 * a) * volume (ball (c J) (D ^ s J / 4)) :=
        Finset.sum_le_sum fun _ ‚Ü¶ volume_le_of_kissing
      _ = 2 ^ (9 * a) * volume (‚ãÉ J ‚àà kissing I, ball (c J) (D ^ s J / 4)) := by
        rw [‚Üê Finset.mul_sum]; congr
        exact (measure_biUnion_finset pairwiseDisjoint_of_kissing fun _ _ ‚Ü¶ measurableSet_ball).symm
      _ ‚â§ _ := by gcongr; exact iUnion‚ÇÇ_subset fun _ ‚Ü¶ subset_of_kissing
  have vn0 : volume (ball (c I) (33 * D ^ s I)) ‚â† 0 := by
    refine (measure_ball_pos volume _ ?_).ne'; simp only [defaultD]; positivity
  rw [ENNReal.mul_le_mul_right vn0 measure_ball_ne_top] at key; norm_cast at key

lemma e728_push_toReal (hf : BoundedCompactSupport f) :
    (t.boundaryOperator u f x).toReal = ‚àë I : Grid X,
      (I : Set X).indicator (fun _ ‚Ü¶ ‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal) x := by
  rw [boundaryOperator, ENNReal.toReal_sum]
  ¬∑ congr! with I -
    unfold indicator; split_ifs
    ¬∑ exact ENNReal.toReal_sum fun _ _ ‚Ü¶ (ijIntegral_lt_top hf).ne
    ¬∑ rfl
  ¬∑ have bof := fun x ‚Ü¶ boundaryOperator_lt_top hf (t := t) (u := u) (x := x)
    unfold boundaryOperator at bof
    simp_rw [ENNReal.sum_lt_top] at bof
    exact fun I mI ‚Ü¶ (bof x I mI).ne

lemma e728_rearrange (hf : BoundedCompactSupport f) (hg : BoundedCompactSupport g) :
    ‚à´ x, conj (g x) * (t.boundaryOperator u f x).toReal =
    ‚àë I : Grid X, ((volume (ball (c I) (16 * D ^ s I)))‚Åª¬π.toReal * ‚à´ x in I, conj (g x)) *
      ‚àë J ‚àà ùìô' t u (c I) (s I), (D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë).toReal :=
  calc
    _ = ‚à´ x, conj (g x) * ‚àë I : Grid X,
        (I : Set X).indicator (fun _ ‚Ü¶ ‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal) x := by
      congr with x
      rw [e728_push_toReal hf]
    _ = ‚à´ x, ‚àë I : Grid X, (I : Set X).indicator
        (fun _ ‚Ü¶ conj (g x) * ‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal) x := by
      congr with x; rw [ofReal_sum, Finset.mul_sum]
      congr with I; rw [indicator_const_mul]; congr
      unfold indicator; split_ifs <;> simp
    _ = ‚àë I : Grid X, ‚à´ x, (I : Set X).indicator
        (fun _ ‚Ü¶ conj (g x) * ‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal) x := by
      refine integral_finset_sum _ fun I _ ‚Ü¶ ?_
      change Integrable ((I : Set X).indicator _)
      rw [integrable_indicator_iff coeGrid_measurable]
      dsimp only
      suffices ‚àÉ M, ‚àÄ·µê x, ‚Äñconj (g x) * ‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal‚Äñ ‚â§ M by
        obtain ‚ü®M, hM‚ü© := this
        exact Measure.integrableOn_of_bounded (by finiteness)
          ((continuous_conj.comp_aestronglyMeasurable hg.aestronglyMeasurable).mul_const _)
          (ae_restrict_of_ae hM)
      have gb := hg.memLp_top.ae_norm_le
      set L := eLpNorm g ‚àû volume |>.toReal
      use L * ‚ÄñofReal (‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal)‚Äñ;
      filter_upwards [gb] with x hL
      rw [norm_mul, RCLike.norm_conj]; gcongr
    _ = ‚àë I : Grid X, ‚à´ x in I,
        conj (g x) * ‚àë J ‚àà ùìô' t u (c I) (s I), (ijIntegral f I J).toReal := by
      congr with I; exact integral_indicator coeGrid_measurable
    _ = ‚àë I : Grid X, ‚à´ x in I, conj (g x) * ‚àë J ‚àà ùìô' t u (c I) (s I),
        (D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë).toReal *
          (volume (ball (c I) (16 * D ^ s I)))‚Åª¬π.toReal := by
      congr! with I - x J hJ
      rw [‚Üê ENNReal.toReal_mul, ijIntegral]; congr 1
      rw [mul_assoc, mul_comm _ _‚Åª¬π, ‚Üê mul_assoc]; rfl
    _ = ‚àë I : Grid X, (volume (ball (c I) (16 * D ^ s I)))‚Åª¬π.toReal *
        ‚à´ x in I, (conj (g x) * ‚àë J ‚àà ùìô' t u (c I) (s I),
          (D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë).toReal) := by
      congr with I; rw [‚Üê integral_const_mul]
      congr with x; rw [‚Üê mul_assoc, mul_comm _ (conj _), mul_assoc]
      congr 1; rw [ofReal_sum, ofReal_sum, Finset.mul_sum]
      congr with J; rw [mul_comm, ofReal_mul]
    _ = _ := by simp_rw [integral_mul_const, mul_assoc]

open scoped Classical in
/-- Equation (7.2.8) in the proof of Lemma 7.2.3. -/
lemma e728 (hf : BoundedCompactSupport f) (hg : BoundedCompactSupport g) :
    ‚Äñ‚à´ x, conj (g x) * (t.boundaryOperator u f x).toReal‚Äñ‚Çë ‚â§
    ‚àë J ‚àà ùìô (t u), ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë * MB volume ùìë cùìë rùìë g y *
      ‚àë I : Grid X, if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
        (D : ‚Ñù‚â•0‚àû) ^ ((s J - s I) / (a : ‚Ñù)) else 0 := by
  have nfs := hf.aestronglyMeasurable.enorm
  calc
    _ = ‚Äñ‚àë I : Grid X, ((volume (ball (c I) (16 * D ^ s I)))‚Åª¬π.toReal * ‚à´ x in I, conj (g x)) *
        ‚àë J ‚àà ùìô' t u (c I) (s I), (D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë).toReal‚Äñ‚Çë := by
      rw [e728_rearrange hf hg]
    _ ‚â§ ‚àë I : Grid X, ‚Äñ((volume (ball (c I) (16 * D ^ s I)))‚Åª¬π.toReal * ‚à´ x in I, conj (g x)) *
        ‚àë J ‚àà ùìô' t u (c I) (s I), (D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë).toReal‚Äñ‚Çë := by
      simp_rw [enorm_eq_nnnorm, ‚Üê ENNReal.coe_finset_sum, ENNReal.coe_le_coe]
      apply nnnorm_sum_le
    _ ‚â§ ‚àë I : Grid X, (volume (ball (c I) (16 * D ^ s I)))‚Åª¬π * ‚Äñ‚à´ x in I, conj (g x)‚Äñ‚Çë *
        ‚àë J ‚àà ùìô' t u (c I) (s I), ‚Äñ(D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë).toReal‚Äñ‚Çë := by
      simp_rw [enorm_mul]; gcongr <;> rw [‚Üê ofReal_norm, norm_real, ofReal_norm]
      ¬∑ exact enorm_toReal_le
      ¬∑ simp_rw [enorm_eq_nnnorm, ‚Üê ENNReal.coe_finset_sum, ENNReal.coe_le_coe]
        apply nnnorm_sum_le
    _ ‚â§ ‚àë I : Grid X, ((volume (ball (c I) (16 * D ^ s I)))‚Åª¬π * ‚à´‚Åª x in I, ‚Äñg x‚Äñ‚Çë) *
        ‚àë J ‚àà ùìô' t u (c I) (s I), D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë := by
      gcongr with I
      ¬∑ calc
          _ ‚â§ _ := enorm_integral_le_lintegral_enorm _
          _ = _ := by congr! 2 with x; exact RCLike.enorm_conj _
      ¬∑ exact enorm_toReal_le
    _ ‚â§ ‚àë I : Grid X,
        ((volume (ball (c I) (16 * D ^ s I)))‚Åª¬π * ‚à´‚Åª x in ball (c I) (16 * D ^ s I), ‚Äñg x‚Äñ‚Çë) *
        ‚àë J ‚àà ùìô' t u (c I) (s I), D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë := by
      gcongr with I; refine lintegral_mono_set (Grid_subset_ball.trans <| ball_subset_ball ?_)
      exact mul_le_mul_of_nonneg_right (by norm_num) (by positivity)
    _ = ‚àë I : Grid X, (‚®ç‚Åª x in ball (c I) (16 * D ^ s I), ‚Äñg x‚Äñ‚Çë ‚àÇvolume) *
        ‚àë J ‚àà ùìô' t u (c I) (s I), D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë := by
      congr!; rw [laverage_eq, Measure.restrict_apply .univ, univ_inter, ENNReal.div_eq_inv_mul]
    _ = ‚àë J ‚àà ùìô (t u), ‚àë I : Grid X, if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
        (‚®ç‚Åª x in ball (c I) (16 * D ^ s I), ‚Äñg x‚Äñ‚Çë ‚àÇvolume) *
          D ^ ((s J - s I) / (a : ‚Ñù)) * ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë else 0 := by
      rw [Finset.sum_comm]; congr with I
      simp_rw [Finset.mul_sum, mul_assoc, ‚Üê Finset.sum_filter]
      exact Finset.sum_congr (by ext; simp [ùìô']) fun _ _ ‚Ü¶ rfl
    _ = ‚àë J ‚àà ùìô (t u), ‚àë I : Grid X, ‚à´‚Åª y in J,
        if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
          (‚®ç‚Åª x in ball (c I) (16 * D ^ s I), ‚Äñg x‚Äñ‚Çë ‚àÇvolume) *
            D ^ ((s J - s I) / (a : ‚Ñù)) * ‚Äñf y‚Äñ‚Çë else 0 := by
      congr!; split_ifs
      ¬∑ rw [lintegral_const_mul'' _ nfs.restrict]
      ¬∑ simp
    _ = ‚àë J ‚àà ùìô (t u), ‚à´‚Åª y in J, ‚àë I : Grid X,
        if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
          (‚®ç‚Åª x in ball (c I) (16 * D ^ s I), ‚Äñg x‚Äñ‚Çë ‚àÇvolume) *
            D ^ ((s J - s I) / (a : ‚Ñù)) * ‚Äñf y‚Äñ‚Çë else 0 := by
      congr with J; refine (lintegral_finset_sum' _ fun I _ ‚Ü¶ ?_).symm
      exact (nfs.restrict.const_mul _).ite (.const _) aemeasurable_const
    _ ‚â§ ‚àë J ‚àà ùìô (t u), ‚à´‚Åª y in J, ‚àë I : Grid X,
        if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
          MB volume ùìë cùìë rùìë g y * D ^ ((s J - s I) / (a : ‚Ñù)) * ‚Äñf y‚Äñ‚Çë else 0 := by
      refine Finset.sum_le_sum fun J mJ ‚Ü¶ setLIntegral_mono_ae ?_ ?_
      ¬∑ refine (Finset.aemeasurable_sum _ fun I _ ‚Ü¶ ?_).restrict; split_ifs; swap; ¬∑ simp
        refine (AEMeasurable.mul_const ?_ _).mul nfs
        exact (AEStronglyMeasurable.maximalFunction ùìë.to_countable).aemeasurable
      ¬∑ refine Eventually.of_forall fun y my ‚Ü¶ Finset.sum_le_sum fun I _ ‚Ü¶ ?_
        split_ifs with hIJ; swap; ¬∑ rfl
        refine mul_le_mul_right' (mul_le_mul_right' ?_ _) _
        obtain ‚ü®b, mb, eb‚ü© : ‚àÉ i ‚àà ùìë, ball (cùìë i) (rùìë i) = ball (c I) (16 * D ^ s I) := by
          use (4, 0, I); norm_num [ùìë, cùìë, rùìë]
        rw [MB, maximalFunction]; simp_rw [inv_one, ENNReal.rpow_one]
        exact le_iSup‚ÇÇ_of_le b mb (by rw [indicator_of_mem (eb ‚ñ∏ hIJ.1 my), eb])
    _ = _ := by
      congr! with J - y -; rw [Finset.mul_sum]
      congr with I; rw [mul_ite, mul_zero, ‚Üê mul_rotate]

open scoped Classical in
/-- Bound for the inner sum in Equation (7.2.8). -/
lemma boundary_geometric_series :
    (‚àë I : Grid X, if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
      (D : ‚Ñù‚â•0‚àû) ^ ((s J - s I) / (a : ‚Ñù)) else 0) ‚â§ 2 ^ (9 * a + 1) :=
  calc
    _ = ‚àë k ‚àà Icc (s J) S, ‚àë I : Grid X,
        if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß k = s I then
          (D : ‚Ñù‚â•0‚àû) ^ ((s J - s I) / (a : ‚Ñù)) else 0 := by
      rw [Finset.sum_comm]; congr with I
      by_cases h : (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I)
      ¬∑ simp_rw [h, true_and, ‚Üê Finset.sum_filter]; split_ifs with hs
        ¬∑ have : (Finset.Icc (s J) S).filter (¬∑ = s I) = {s I} := by
            ext k
            rw [Finset.mem_filter, Finset.mem_Icc, Finset.mem_singleton, and_iff_right_iff_imp]
            intro h'; subst h'; exact ‚ü®hs, scale_mem_Icc.2‚ü©
          simp [this]
        ¬∑ have : (Finset.Icc (s J) S).filter (¬∑ = s I) = ‚àÖ := by
            ext k
            simp_rw [Finset.mem_filter, Finset.mem_Icc, Finset.notMem_empty, iff_false, not_and]
            intro; omega
          simp [this]
      ¬∑ simp_rw [h, false_and, ite_false, Finset.sum_const_zero]
    _ = ‚àë kh : Icc (s J) S, ‚àë I : Grid X,
        if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß kh.1 = s I then
          (D : ‚Ñù‚â•0‚àû) ^ ((s J - s I) / (a : ‚Ñù)) else 0 := Finset.sum_subtype _ (fun _ ‚Ü¶ by simp) _
    _ ‚â§ ‚àë kh : Icc (s J) S, ‚àë I : Grid X,
        if I ‚àà kissing (Grid.exists_supercube kh.1 kh.2).choose then
          (D : ‚Ñù‚â•0‚àû) ^ ((s J - kh.1) / (a : ‚Ñù)) else 0 := by
      gcongr with kh _ I
      obtain ‚ü®k, h‚ü© := kh
      set J' := (Grid.exists_supercube k h).choose
      have pJ' : s J' = k ‚àß J ‚â§ J' := (Grid.exists_supercube k h).choose_spec
      by_cases hs : k = s I; swap; ¬∑ simp [hs]
      suffices (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚Üí I ‚àà kissing J' by
        split_ifs; exacts [by simp_all, by tauto, by positivity, by rfl]
      intro mJ; simp_rw [kissing, Finset.mem_filter_univ]
      refine ‚ü®pJ'.1 ‚ñ∏ hs.symm, not_disjoint_iff.mpr ‚ü®c J, ?_, mJ Grid.c_mem_Grid‚ü©‚ü©
      refine (pJ'.2.1.trans Grid_subset_ball |>.trans (ball_subset_ball ?_)) Grid.c_mem_Grid
      change (4 : ‚Ñù) * D ^ s J' ‚â§ 16 * D ^ s J'; gcongr; norm_num
    _ = ‚àë kh : Icc (s J) S, (D : ‚Ñù‚â•0‚àû) ^ ((s J - kh.1) / (a : ‚Ñù)) *
        (kissing (Grid.exists_supercube kh.1 kh.2).choose).card := by
      simp_rw [‚Üê Finset.sum_filter, Finset.sum_const, nsmul_eq_mul, mul_comm (Nat.cast _),
        Finset.filter_univ_mem]
    _ ‚â§ 2 ^ (9 * a) * ‚àë kh : Icc (s J) S, (D : ‚Ñù‚â•0‚àû) ^ ((s J - kh.1) / (a : ‚Ñù)) := by
      conv_rhs => rw [Finset.mul_sum]; enter [2, kh]; rw [mul_comm]
      gcongr
      calc
        _ ‚â§ ((2 ^ (9 * a) : ‚Ñï) : ‚Ñù‚â•0‚àû) := by rw [Nat.cast_le]; apply boundary_overlap
        _ = _ := by norm_cast
    _ = 2 ^ (9 * a) * ‚àë k : Icc 0 (S - s J).toNat, ((D : ‚Ñù‚â•0‚àû) ^ (1 / (a : ‚Ñù))) ^ (-k.1 : ‚Ñ§) := by
      congr 1
      have sjs : s J ‚â§ S := scale_mem_Icc.2
      have ssj : (S - s J).toNat = S - s J := Int.toNat_sub_of_le sjs
      let f : Icc (s J) S ‚Üí Icc 0 (S - s J).toNat := fun ‚ü®k, bk‚ü© ‚Ü¶
        ‚ü®(k - s J).toNat, by rw [mem_Icc] at bk; simp [bk]‚ü©
      have bijf : Bijective f := by
        rw [Fintype.bijective_iff_surjective_and_card]; constructor
        ¬∑ rintro ‚ü®k', bk'‚ü©; use ‚ü®k' + s J, by rw [mem_Icc] at bk' ‚ä¢; omega‚ü©; simp [f]
        ¬∑ simp only [Fintype.card_ofFinset, Int.card_Icc, Nat.card_Icc, tsub_zero]; omega
      refine Fintype.sum_bijective f bijf _ _ fun ‚ü®k, bk‚ü© ‚Ü¶ ?_
      simp only [f, Int.toNat_sub_of_le bk.1, neg_sub, ‚Üê Int.cast_sub]
      rw [‚Üê ENNReal.rpow_intCast, ‚Üê ENNReal.rpow_mul, div_mul_comm, mul_one]
    _ = 2 ^ (9 * a) * ‚àë k ‚àà Icc 0 (S - s J).toNat, ((D : ‚Ñù‚â•0‚àû) ^ (1 / (a : ‚Ñù))) ^ (-k : ‚Ñ§) := by
      congr 1; symm; exact Finset.sum_subtype _ (fun _ ‚Ü¶ by simp) _
    _ ‚â§ 2 ^ (9 * a) * ‚àë k ‚àà Icc 0 (S - s J).toNat, 2 ^ (-k : ‚Ñ§) := by
      gcongr with k
      rw [defaultD, Nat.cast_pow, Nat.cast_ofNat, ‚Üê ENNReal.rpow_natCast, ‚Üê ENNReal.rpow_mul,
        ‚Üê ENNReal.rpow_intCast, ‚Üê ENNReal.rpow_mul, ‚Üê ENNReal.rpow_intCast]
      refine ENNReal.rpow_le_rpow_of_exponent_le one_le_two ?_
      rw [Nat.cast_mul, Nat.cast_pow, Int.cast_neg, Int.cast_natCast, mul_neg,
        neg_le_neg_iff, sq, ‚Üê mul_div_assoc, mul_one, mul_div_assoc, mul_div_cancel_of_imp id]
      norm_cast
      calc k
      _ = 1 * 1 * k := by ring
      _ ‚â§ ùïî * a * k := by
        gcongr
        ¬∑ linarith [seven_le_c]
        ¬∑ linarith [four_le_a X]
    _ ‚â§ 2 ^ (9 * a) * ‚àë' k : ‚Ñï, 2 ^ (-k : ‚Ñ§) := mul_le_mul_left' (ENNReal.sum_le_tsum _) _
    _ ‚â§ 2 ^ (9 * a) * 2 := by rw [ENNReal.sum_geometric_two_pow_neg_one]
    _ = _ := by rw [‚Üê pow_succ]

/-- can be improved to `2 ^ (10 * a + 5 / 2)` -/
irreducible_def C7_2_3 (a : ‚Ñï) : ‚Ñù‚â•0 := 2 ^ (12 * (a : ‚Ñù))

lemma boundary_operator_bound_aux (hf : BoundedCompactSupport f) (hg : BoundedCompactSupport g) :
    ‚Äñ‚à´ x, conj (g x) * (t.boundaryOperator u f x).toReal‚Äñ‚Çë ‚â§
      C7_2_3 a * eLpNorm f 2 volume * eLpNorm g 2 volume := by
  classical
  calc
    _ ‚â§ ‚àë J ‚àà ùìô (t u), ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë * MB volume ùìë cùìë rùìë g y *
        ‚àë I : Grid X, if (J : Set X) ‚äÜ ball (c I) (16 * D ^ s I) ‚àß s J ‚â§ s I then
          (D : ‚Ñù‚â•0‚àû) ^ ((s J - s I) / (a : ‚Ñù)) else 0 := e728 hf hg
    _ ‚â§ ‚àë J ‚àà ùìô (t u), ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë * MB volume ùìë cùìë rùìë g y * 2 ^ (9 * a + 1) := by
      gcongr; exact boundary_geometric_series
    _ = 2 ^ (9 * a + 1) * ‚àë J ‚àà ùìô (t u), ‚à´‚Åª y in J, ‚Äñf y‚Äñ‚Çë * MB volume ùìë cùìë rùìë g y := by
      rw [Finset.mul_sum]; congr! with J mJ
      rw [‚Üê lintegral_const_mul' _ _ (by tauto)]; congr with y; rw [mul_comm]
    _ = 2 ^ (9 * a + 1) * ‚à´‚Åª y in ‚ãÉ I : Grid X, I, ‚Äñf y‚Äñ‚Çë * MB volume ùìë cùìë rùìë g y := by
      rw [‚Üê lintegral_biUnion_finset] <;> simp only [mem_toFinset, coe_toFinset, biUnion_ùìô]
      ¬∑ exact pairwiseDisjoint_ùìô
      ¬∑ exact fun _ _ ‚Ü¶ coeGrid_measurable
    _ ‚â§ 2 ^ (9 * a + 1) * ‚à´‚Åª y, ‚Äñf y‚Äñ‚Çë * MB volume ùìë cùìë rùìë g y := by
      gcongr; exact setLIntegral_le_lintegral _ _
    _ ‚â§ 2 ^ (9 * a + 1) * eLpNorm f 2 volume * eLpNorm (MB volume ùìë cùìë rùìë g) 2 volume := by
      rw [mul_assoc]; gcongr
      exact ENNReal.lintegral_mul_le_eLpNorm_mul_eLqNorm ‚ü®by simpa using ENNReal.inv_two_add_inv_two‚ü©
        hf.aestronglyMeasurable.aemeasurable.enorm
        (AEStronglyMeasurable.maximalFunction ùìë.to_countable).aemeasurable
    _ ‚â§ 2 ^ (9 * a + 1) * eLpNorm f 2 volume * (2 ^ (a + (3 / 2 : ‚Ñù)) * eLpNorm g 2 volume) := by
      have ST : HasStrongType (Œ± := X) (Œ±' := X) (Œµ‚ÇÅ := ‚ÑÇ) (MB volume ùìë cùìë rùìë) 2 2 volume volume
          (CMB (defaultA a) 2) := by
        refine hasStrongType_MB ùìë.to_countable (R := 2 ^ (S + 5) * D ^ (3 * S + 3))
          (fun ‚ü®bs, bi‚ü© mb ‚Ü¶ ?_) (by norm_num)
        simp_rw [ùìë, mem_prod, mem_Iic, mem_univ, and_true] at mb
        obtain ‚ü®mb1, mb2‚ü© := mb
        simp_rw [rùìë, ‚Üê zpow_natCast (n := 3 * S + 3), Nat.cast_add, Nat.cast_mul, Nat.cast_ofNat,
          show 3 * (S : ‚Ñ§) + 3 = S + (2 * S + 3) by ring]
        gcongr
        ¬∑ exact one_le_two
        ¬∑ exact one_le_realD _
        ¬∑ exact scale_mem_Icc.2
        ¬∑ exact_mod_cast mb2
      specialize ST g (hg.memLp 2)
      rw [CMB_defaultA_two_eq, ENNReal.coe_rpow_of_ne_zero two_ne_zero, ENNReal.coe_ofNat] at ST
      exact mul_le_mul_left' ST.2 _
    _ = 2 ^ (9 * a + 1) * 2 ^ (a + (3 / 2 : ‚Ñù)) * eLpNorm f 2 volume * eLpNorm g 2 volume := by ring
    _ ‚â§ _ := by
      refine mul_le_mul_right' (mul_le_mul_right' ?_ _) _
      rw [C7_2_3, ENNReal.coe_rpow_of_ne_zero two_ne_zero, ENNReal.coe_ofNat,
        ‚Üê ENNReal.rpow_natCast, ‚Üê ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top]
      refine ENNReal.rpow_le_rpow_of_exponent_le one_le_two ?_
      rw [Nat.cast_add, Nat.cast_mul, Nat.cast_ofNat, Nat.cast_one,
        show 9 * (a : ‚Ñù) + 1 + (a + 3 / 2) = 10 * (a : ‚Ñù) + 5 / 2 by ring]
      have : 4 ‚â§ (a : ‚Ñù) := by norm_cast; exact four_le_a X
      linarith

/-- Lemma 7.2.3. -/
lemma boundary_operator_bound (hf : BoundedCompactSupport f) :
    eLpNorm (t.boundaryOperator u f) 2 volume ‚â§ C7_2_3 a * eLpNorm f 2 volume := by
  have bcs : BoundedCompactSupport fun x ‚Ü¶ (t.boundaryOperator u f x).toReal := by
    simp_rw [e728_push_toReal hf]
    refine BoundedCompactSupport.finset_sum fun I _ ‚Ü¶ ?_
    refine BoundedCompactSupport.indicator_of_isCompact_closure (memLp_top_const _)
      (Metric.isBounded_ball.subset Grid_subset_ball).isCompact_closure coeGrid_measurable
  have elpn_eq : eLpNorm (fun x ‚Ü¶ (t.boundaryOperator u f x).toReal) 2 volume =
      eLpNorm (t.boundaryOperator u f) 2 volume :=
    eLpNorm_toReal_eq (Eventually.of_forall fun _ ‚Ü¶ (boundaryOperator_lt_top hf).ne)
  by_cases hv : eLpNorm (t.boundaryOperator u f) 2 volume = 0; ¬∑ simp [hv]
  have hv' : eLpNorm (t.boundaryOperator u f) 2 volume < ‚ä§ := elpn_eq ‚ñ∏ (bcs.memLp 2).2
  rw [‚Üê ENNReal.mul_le_mul_right hv hv'.ne, ‚Üê sq, ‚Üê ENNReal.rpow_natCast]
  nth_rw 1 [show ((2 : ‚Ñï) : ‚Ñù) = (2 : ‚Ñù‚â•0) by rfl, show (2 : ‚Ñù‚â•0‚àû) = (2 : ‚Ñù‚â•0) by rfl,
    eLpNorm_nnreal_pow_eq_lintegral two_ne_zero]
  convert boundary_operator_bound_aux (t := t) (u := u) hf bcs.toComplex using 2
  ¬∑ simp_rw [RCLike.conj_mul]; norm_cast
    simp_rw [‚Üê norm_pow, integral_norm_eq_lintegral_enorm
      (bcs.aestronglyMeasurable.aemeasurable.pow_const 2).aestronglyMeasurable, enorm_pow,
      enorm_toReal (boundaryOperator_lt_top hf).ne, enorm_eq_self]
    simp_rw [enorm_eq_nnnorm, coe_algebraMap, nnnorm_real, ‚Üê enorm_eq_nnnorm,
      ‚Üê ENNReal.rpow_natCast, Nat.cast_ofNat]
    refine (enorm_toReal ?_).symm
    replace hv' := ENNReal.pow_lt_top (n := 2) hv'
    rw [‚Üê ENNReal.rpow_natCast, show ((2 : ‚Ñï) : ‚Ñù) = (2 : ‚Ñù‚â•0) by rfl,
      show (2 : ‚Ñù‚â•0‚àû) = (2 : ‚Ñù‚â•0) by rfl, eLpNorm_nnreal_pow_eq_lintegral two_ne_zero,
      show ((2 : ‚Ñù‚â•0) : ‚Ñù) = (2 : ‚Ñï) by rfl] at hv'
    simp_rw [enorm_eq_self] at hv'; exact hv'.ne
  ¬∑ rw [‚Üê elpn_eq, show (2 : ‚Ñù‚â•0‚àû) = (2 : ‚Ñù‚â•0) by rfl]
    simp_rw [eLpNorm_nnreal_eq_lintegral two_ne_zero]; congr!
    simp [enorm_eq_nnnorm, nnnorm_real]

/-- The constant used in `tree_projection_estimate`.
Has value `2 ^ (130 * a ^ 3)` in the blueprint. -/
irreducible_def C7_2_1 (a : ‚Ñï) : ‚Ñù‚â•0 := 2 ^ ((ùïî + 5 + ùïî / 4) * a ^ 3)

-- Auxiliary function used in the proof of Lemma 7.2.1
private def eIùí¨u_mul (u : ùîì X) (f : X ‚Üí ‚ÑÇ) : X ‚Üí ‚ÑÇ := fun y ‚Ü¶ exp (.I * ùí¨ u y) * f y

private lemma boundedCompactSupport_eIùí¨u_mul (u : ùîì X) {f : X ‚Üí ‚ÑÇ} (hf : BoundedCompactSupport f) :
    BoundedCompactSupport (eIùí¨u_mul u f) := by
  apply hf.mul_bdd_left
  apply memLp_top_of_bound (by fun_prop) 1 (.of_forall fun _ ‚Ü¶ ?_)
  rw [mul_comm, norm_exp_ofReal_mul_I]

private lemma norm_eIùí¨u_mul_eq (u : ùîì X) (f : X ‚Üí ‚ÑÇ) (x : X) : ‚ÄñeIùí¨u_mul u f x‚Äñ = ‚Äñf x‚Äñ := by
  simp [eIùí¨u_mul, mul_comm I]

-- The bound for `carlesonSum` from `pointwise_tree_estimate` (Lemma 7.1.3)
variable (t) (u) (f) in
private def cS_bound (x' : X) :=
    C7_1_3 a * (MB volume ùìë cùìë rùìë (approxOnCube (ùìô (t u)) (‚Äñf ¬∑‚Äñ)) x' +
    t.boundaryOperator u (approxOnCube (ùìô (t u)) (‚Äñf ¬∑‚Äñ)) x') +
    nontangentialMaximalFunction (ùí¨ u) (approxOnCube (ùìô (t u)) (eIùí¨u_mul u f)) x'

private lemma aeMeasurable_cS_bound : AEMeasurable (cS_bound t u f) := by
  refine AEMeasurable.add ?_ MeasureTheory.Measurable.nontangentialMaximalFunction.aemeasurable
  apply ((AEStronglyMeasurable.maximalFunction (to_countable ùìë)).aemeasurable.add ?_).const_mul
  exact measurable_boundaryOperator.aemeasurable

-- The natural constant for Lemma 7.2.1 is ‚â§ the simpler constant `C7_2_1` we use instead.
private lemma le_C7_2_1 {a : ‚Ñï} (ha : 4 ‚â§ a) :
    C7_1_3 a * CMB (defaultA a) 2 + C7_1_3 a * C7_2_3 a + C7_2_2 a ‚â§ (C7_2_1 a : ‚Ñù‚â•0‚àû) := calc
  _ ‚â§ (3 : ‚Ñï) ‚Ä¢ (2 : ‚Ñù‚â•0‚àû) ^ ((ùïî + 4 + ùïî / 4) * a ^ 3 + 12 * a) := by
    rw [three'_nsmul]
    gcongr
    ¬∑ rw [C7_1_3_def, CMB_defaultA_two_eq, pow_add]
      simp_rw [ENNReal.coe_pow, ENNReal.coe_rpow_of_ne_zero two_ne_zero, ENNReal.coe_ofNat]
      gcongr; rw [‚Üê ENNReal.rpow_natCast, Nat.cast_mul]
      apply ENNReal.rpow_le_rpow_of_exponent_le one_le_two ?_
      linarith [show 4 ‚â§ (a : ‚Ñù) by exact_mod_cast ha]
    ¬∑ rw [C7_1_3_def, C7_2_3_def]
      norm_cast
      exact le_of_eq (pow_add _ _ _).symm
    ¬∑ rw [C7_2_2_def]
      norm_cast
      gcongr
      ¬∑ norm_num
      simp [add_mul]
      omega
  _ = 3 * 2 ^ (12 * a) * 2 ^ ((ùïî + 4 + ùïî / 4) * a ^ 3) := by rw [add_comm, pow_add]; ring
  _ ‚â§ 2 ^ (a ^ 3) * 2 ^ ((ùïî + 4 + ùïî / 4) * a ^ 3) := by
    apply mul_right_mono; norm_cast
    calc
      _ ‚â§ 2 ^ 2 * 2 ^ (12 * a) := by gcongr; norm_num
      _ = 2 ^ (2 + 12 * a)     := by rw [pow_add]
      _ ‚â§ 2 ^ (a ^ 3)          := pow_le_pow_right‚ÇÄ one_le_two <| calc 2 + 12 * a
        _ ‚â§ a + 12 * a := by apply add_le_add_right; linarith
        _ = 13 * a     := by ring
        _ ‚â§ a ^ 2 * a  := by rw [mul_le_mul_right] <;> nlinarith
        _ = a ^ 3      := rfl
  _ = _ := by rw [C7_2_1_def, ‚Üê pow_add]; norm_cast; ring

-- Main estimate used in the proof of `tree_projection_estimate`
private lemma eLpNorm_two_cS_bound_le : eLpNorm (cS_bound t u f) 2 volume ‚â§
    C7_2_1 a * eLpNorm (approxOnCube (ùìô (t u)) (‚Äñf ¬∑‚Äñ)) 2 volume := by
  let Œº := volume (Œ± := X)
  let aOC := (approxOnCube (ùìô (t u)) (‚Äñf ¬∑‚Äñ))
  let g‚ÇÅ := MB Œº ùìë cùìë rùìë aOC
  let g‚ÇÇ := t.boundaryOperator u (approxOnCube (ùìô (t u)) (‚Äñf ¬∑‚Äñ))
  let g‚ÇÉ := nontangentialMaximalFunction (ùí¨ u) (approxOnCube (ùìô (t u)) (eIùí¨u_mul u f))
  have m‚ÇÅ : AEMeasurable g‚ÇÅ :=
    (MeasureTheory.AEStronglyMeasurable.maximalFunction (to_countable ùìë)).aemeasurable
  have m‚ÇÇ : AEMeasurable g‚ÇÇ := measurable_boundaryOperator.aemeasurable
  calc eLpNorm (cS_bound t u f) 2 Œº
    _ = eLpNorm (C7_1_3 a ‚Ä¢ (g‚ÇÅ + g‚ÇÇ) + g‚ÇÉ) 2 Œº := rfl
    _ ‚â§ eLpNorm (C7_1_3 a ‚Ä¢ (g‚ÇÅ + g‚ÇÇ)) 2 Œº + eLpNorm g‚ÇÉ 2 Œº := by
      simpa [eLpNorm, eLpNorm'] using
        ENNReal.lintegral_Lp_add_le ((m‚ÇÅ.add m‚ÇÇ).const_smul (C7_1_3 a)) (hp1 := one_le_two)
          MeasureTheory.Measurable.nontangentialMaximalFunction.aemeasurable
    _ = C7_1_3 a ‚Ä¢ eLpNorm (g‚ÇÅ + g‚ÇÇ) 2 Œº + eLpNorm g‚ÇÉ 2 Œº := by
      congr
      simpa [eLpNorm, eLpNorm'] using ENNReal.lintegral_Lp_smul (m‚ÇÅ.add m‚ÇÇ) two_pos (C7_1_3 a)
    _ ‚â§ C7_1_3 a ‚Ä¢ (eLpNorm g‚ÇÅ 2 Œº + eLpNorm g‚ÇÇ 2 Œº) + eLpNorm g‚ÇÉ 2 Œº := by
      gcongr
      simpa [eLpNorm, eLpNorm'] using ENNReal.lintegral_Lp_add_le m‚ÇÅ m‚ÇÇ one_le_two
    _ ‚â§ C7_1_3 a ‚Ä¢ ((CMB (defaultA a) 2) * eLpNorm aOC 2 Œº + (C7_2_3 a) * eLpNorm aOC 2 Œº) +
          (C7_2_2 a) * eLpNorm aOC 2 Œº := by
      gcongr
      ¬∑ exact eLpNorm_MB_le boundedCompactSupport_approxOnCube
      ¬∑ apply le_of_le_of_eq <| boundary_operator_bound boundedCompactSupport_approxOnCube
        simp [eLpNorm, eLpNorm', aOC, approxOnCube_ofReal, enorm_eq_nnnorm, Œº]
      ¬∑ apply le_trans <| nontangential_operator_bound boundedCompactSupport_approxOnCube (ùí¨ u)
        refine mul_le_mul_left' (eLpNorm_mono (fun x ‚Ü¶ ?_)) _
        apply le_of_le_of_eq norm_approxOnCube_le_approxOnCube_norm
        rw [Real.norm_of_nonneg <| approxOnCube_nonneg (fun _ ‚Ü¶ norm_nonneg _)]
        simp_rw [norm_eIùí¨u_mul_eq]
    _ = (C7_1_3 a * CMB (defaultA a) 2 + C7_1_3 a * C7_2_3 a + C7_2_2 a) * eLpNorm aOC 2 Œº := by
      rw [ENNReal.smul_def, smul_eq_mul]; ring
    _ ‚â§ _ := mul_le_mul_right' (le_C7_2_1 (four_le_a X)) _

/- TODO: PR next to `Complex.norm_real` -/
@[simp 1100, norm_cast]
 protected lemma Complex.enorm_real (x : ‚Ñù) : ‚Äñ(x : ‚ÑÇ)‚Äñ‚Çë = ‚Äñx‚Äñ‚Çë := by simp [enorm]

/-- Lemma 7.2.1. -/
lemma tree_projection_estimate
    (hf : BoundedCompactSupport f) (hg : BoundedCompactSupport g) (hu : u ‚àà t) :
    ‚Äñ‚à´ x, conj (g x) * carlesonSum (t u) f x‚Äñ‚Çë ‚â§
    C7_2_1 a * eLpNorm (approxOnCube (ùìô (t u)) (‚Äñf ¬∑‚Äñ)) 2 volume *
    eLpNorm (approxOnCube (ùìõ (t u)) (‚Äñg ¬∑‚Äñ)) 2 volume := by
  classical
  set aOC := approxOnCube (ùìõ (t u)) (‚Äñg ¬∑‚Äñ)
  let eaOC (x : X) := ENNReal.ofReal (aOC x)
  have aOC_nonneg {x : X} : 0 ‚â§ aOC x := approxOnCube_nonneg (fun _ ‚Ü¶ norm_nonneg _)
  calc ‚Äñ‚à´ x, conj (g x) * carlesonSum (t u) f x‚Äñ‚Çë
    _ ‚â§ ‚à´‚Åª x, ‚Äñconj (g x) * carlesonSum (t u) f x‚Äñ‚Çë := enorm_integral_le_lintegral_enorm _
    _ = ‚à´‚Åª x in (‚ãÉ p ‚àà t u, ùìò p), ‚Äñg x‚Äñ‚Çë * ‚ÄñcarlesonSum (t u) f x‚Äñ‚Çë := by
      rw [‚Üê lintegral_indicator]; swap
      ¬∑ exact MeasurableSet.biUnion (t u).to_countable (fun _ _ ‚Ü¶ coeGrid_measurable)
      simp_rw [enorm_eq_nnnorm, nnnorm_mul, ENNReal.coe_mul, RCLike.nnnorm_conj]
      refine lintegral_congr (fun x ‚Ü¶ ?_)
      by_cases hx : x ‚àà ‚ãÉ p ‚àà t u, ùìò p
      ¬∑ rw [indicator_of_mem hx]
      ¬∑ simp [indicator_of_notMem hx, notMem_support.mp (hx <| support_carlesonSum_subset ¬∑)]
    _ ‚â§ ‚à´‚Åª x in (‚ãÉ L ‚àà ùìõ (t u), (L : Set X)), ‚Äñg x‚Äñ‚Çë * ‚ÄñcarlesonSum (t u) f x‚Äñ‚Çë := by
      rw [biUnion_ùìõ]
      refine lintegral_mono_set (fun x hx ‚Ü¶ ?_)
      have ‚ü®p, hp‚ü© : ‚àÉ p ‚àà t u, x ‚àà ùìò p := by simpa using hx
      apply mem_iUnion.mpr ‚ü®ùìò p, hp.2‚ü©
    _ = ‚àë L ‚àà ùìõ (t u), ‚à´‚Åª x in L, ‚Äñg x‚Äñ‚Çë * ‚ÄñcarlesonSum (t u) f x‚Äñ‚Çë := by
      simp only [‚Üê mem_toFinset]
      refine lintegral_biUnion_finset ?_ (fun _ _ ‚Ü¶ coeGrid_measurable) _
      rw [coe_toFinset]
      exact pairwiseDisjoint_ùìõ
    _ ‚â§ ‚àë L ‚àà ùìõ (t u), ‚à´‚Åª x in L, ‚Äñg x‚Äñ‚Çë * (‚®Ö x' ‚àà L, ‚ÄñcS_bound t u f x'‚Äñ‚Çë) := by
      gcongr ‚àë L ‚àà ùìõ (t u), ?_ with L hL
      refine setLIntegral_mono_ae (hg.restrict.aestronglyMeasurable.enorm.mul_const _)
        (.of_forall fun x hx ‚Ü¶ ?_)
      gcongr
      refine le_iInf‚ÇÇ fun x' hx' ‚Ü¶ ?_
      simp only [mem_toFinset] at hL
      convert pointwise_tree_estimate hu hL hx hx' (boundedCompactSupport_eIùí¨u_mul u hf) using 1
      ¬∑ congr
        simp_rw [mul_neg, eIùí¨u_mul, ‚Üê mul_assoc, ‚Üê exp_add, neg_add_cancel, exp_zero, one_mul]
      ¬∑ simp only [cS_bound, enorm_eq_self, norm_eIùí¨u_mul_eq u f]
    _ = ‚àë L ‚àà ùìõ (t u), ‚à´‚Åª x in L, eaOC x * (‚®Ö x' ‚àà L, ‚ÄñcS_bound t u f x'‚Äñ‚Çë) := by
      refine Finset.sum_congr rfl (fun L hL ‚Ü¶ ?_)
      rw [lintegral_mul_const'', lintegral_mul_const]; rotate_left
      ¬∑ exact ENNReal.measurable_ofReal.comp (stronglyMeasurable_approxOnCube _ _).measurable
      ¬∑ exact hg.restrict.aestronglyMeasurable.enorm
      rw [lintegral_eq_lintegral_approxOnCube pairwiseDisjoint_ùìõ (mem_toFinset.mp hL) hg]
      simp_rw [eaOC, ‚Üê Real.enorm_eq_ofReal aOC_nonneg, approxOnCube_ofReal, aOC,
        Complex.enorm_real]
    _ ‚â§ ‚àë L ‚àà ùìõ (t u), ‚à´‚Åª x in L, eaOC x * ‚ÄñcS_bound t u f x‚Äñ‚Çë :=
      Finset.sum_le_sum fun L hL ‚Ü¶
        setLIntegral_mono' coeGrid_measurable (fun x hx ‚Ü¶ mul_left_mono (biInf_le _ hx))
    _ = ‚à´‚Åª x in (‚ãÉ L ‚àà ùìõ (t u), (L : Set X)), eaOC x * ‚ÄñcS_bound t u f x‚Äñ‚Çë := by
      rw [‚Üê lintegral_biUnion_finset (hm := fun _ _ ‚Ü¶ coeGrid_measurable)]
      ¬∑ simp only [mem_toFinset]
      ¬∑ simpa only [coe_toFinset] using pairwiseDisjoint_ùìõ (ùîñ := t u)
    _ ‚â§ ‚à´‚Åª (x : X), eaOC x * ‚ÄñcS_bound t u f x‚Äñ‚Çë := by
      nth_rewrite 2 [‚Üê setLIntegral_univ]
      exact lintegral_mono_set (fun _ _ ‚Ü¶ trivial)
    _ ‚â§ eLpNorm eaOC 2 volume * eLpNorm (cS_bound t u f) 2 volume := by
      have isConj : Real.HolderConjugate 2 2 := by constructor <;> norm_num
      have : AEMeasurable eaOC := (stronglyMeasurable_approxOnCube _ _).aemeasurable.ennreal_ofReal
      convert ENNReal.lintegral_mul_le_Lp_mul_Lq volume isConj this aeMeasurable_cS_bound <;>
        simp [eLpNorm, eLpNorm']
    _ = eLpNorm (cS_bound t u f) 2 volume * eLpNorm aOC 2 volume := by
      rw [mul_comm]; congr; ext; exact (Real.enorm_eq_ofReal aOC_nonneg).symm
    _ ‚â§ _ := mul_right_mono eLpNorm_two_cS_bound_le

end TileStructure.Forest
