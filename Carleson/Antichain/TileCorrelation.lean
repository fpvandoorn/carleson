import Carleson.Calculations
import Carleson.HolderVanDerCorput
import Carleson.Operators
import Carleson.ToMathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap

/-!
# 6.2. Proof of the Tile Correlation Lemma

This file contains the proofs of lemmas 6.2.1, 6.2.2, 6.2.3 and 6.1.5 from the blueprint.

## Main definitions
- `Tile.correlation` : the function `œÜ` defined in Lemma 6.2.1.

## Main results
- `Tile.mem_ball_of_correlation_ne_zero` and `Tile.correlation_kernel_bound`: Lemma 6.2.1.
- `Tile.range_support`: Lemma 6.2.2.
- `Tile.uncertainty` : Lemma 6.2.3.
- `Tile.correlation_le` and `Tile.correlation_zero_of_ne_subset`: Lemma 6.1.5.
-/

macro_rules | `(tactic |gcongr_discharger) => `(tactic | with_reducible assumption)

noncomputable section

open scoped ComplexConjugate ENNReal NNReal ShortVariables

open Complex Function MeasureTheory Measure Metric Set

namespace Tile

variable {X : Type*} {a : ‚Ñï} {q : ‚Ñù} {K : X ‚Üí X ‚Üí ‚ÑÇ} {œÉ‚ÇÅ œÉ‚ÇÇ : X ‚Üí ‚Ñ§} {F G : Set X} [MetricSpace X]
  [ProofData a q K œÉ‚ÇÅ œÉ‚ÇÇ F G]

/-- Def 6.2.1 (from Lemma 6.2.1), denoted by `œÜ(y)` in the blueprint. -/
def correlation (s‚ÇÅ s‚ÇÇ : ‚Ñ§) (x‚ÇÅ x‚ÇÇ y : X) : ‚ÑÇ := conj (Ks s‚ÇÅ x‚ÇÅ y) * Ks s‚ÇÇ x‚ÇÇ y

@[fun_prop]
lemma measurable_correlation : Measurable (correlation (X := X)) := by fun_prop

/-- First part of Lemma 6.2.1 (eq. 6.2.2). -/
lemma mem_ball_of_correlation_ne_zero {s‚ÇÅ s‚ÇÇ : ‚Ñ§} {x‚ÇÅ x‚ÇÇ y : X}
    (hy : correlation s‚ÇÅ s‚ÇÇ x‚ÇÅ x‚ÇÇ y ‚â† 0) : y ‚àà ball x‚ÇÅ (D ^ s‚ÇÅ) := by
  have hKs : Ks s‚ÇÅ x‚ÇÅ y ‚â† 0 := by
    simp only [correlation, ne_eq, mul_eq_zero, map_eq_zero, not_or] at hy
    exact hy.1
  rw [mem_ball, dist_comm]
  exact (dist_mem_Icc_of_Ks_ne_zero hKs).2.trans_lt (half_lt_self_iff.mpr (defaultD_pow_pos a s‚ÇÅ))

/-- The constant from lemma 6.2.1.
Has value `2 ^ (231 * a ^ 3)` in the blueprint. -/
def C6_2_1 (a : ‚Ñï) : ‚Ñù‚â•0 := 2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3)

private lemma aux_6_2_3 (s‚ÇÅ s‚ÇÇ : ‚Ñ§) (x‚ÇÅ x‚ÇÇ y y' : X) :
    ‚ÄñKs s‚ÇÇ x‚ÇÇ y‚Äñ‚Çë * ‚ÄñKs s‚ÇÅ x‚ÇÅ y - Ks s‚ÇÅ x‚ÇÅ y'‚Äñ‚Çë ‚â§ C2_1_3 a / volume (ball x‚ÇÇ (D ^ s‚ÇÇ)) *
    (D2_1_3 a / volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) * (edist y y' ^ œÑ / (D ^ s‚ÇÅ) ^ œÑ)) := by
  apply mul_le_mul' enorm_Ks_le
  convert enorm_Ks_sub_Ks_le
  rw [‚Üê ENNReal.div_rpow_of_nonneg _ _ (œÑ_nonneg X), defaultœÑ]

/-- Ineq. (6.2.5) ‚â§ (6.2.9) from the proof of Lemma 6.2.1. -/
private lemma e625 {s‚ÇÅ s‚ÇÇ : ‚Ñ§} {x‚ÇÅ x‚ÇÇ y y' : X} (hy' : y ‚â† y') (hs : s‚ÇÅ ‚â§ s‚ÇÇ) :
    (2 * D ^ s‚ÇÅ) ^ œÑ *
    (‚Äñcorrelation s‚ÇÅ s‚ÇÇ x‚ÇÅ x‚ÇÇ y - correlation s‚ÇÅ s‚ÇÇ x‚ÇÅ x‚ÇÇ y'‚Äñ‚Çë / edist y y' ^ œÑ) ‚â§
    2 ^ ((2 * ùïî + 5 + ùïî / 4) * a ^ 3) /
    (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) * volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) := by
  rw [mul_comm]
  refine ENNReal.mul_le_of_le_div ?_
  rw [ENNReal.div_le_iff_le_mul (.inl _) (.inl _)]; rotate_left
  ¬∑ rw [‚Üê ENNReal.inv_ne_top, ‚Üê ENNReal.rpow_neg]
    exact ENNReal.rpow_ne_top_of_nonneg' (edist_pos.mpr hy') (edist_ne_top y y')
  ¬∑ exact ENNReal.rpow_ne_top_of_nonneg (œÑ_nonneg X) (edist_ne_top y y')
  calc
    _ = ‚Äñconj (Ks s‚ÇÅ x‚ÇÅ y) * Ks s‚ÇÇ x‚ÇÇ y - conj (Ks s‚ÇÅ x‚ÇÅ y') * Ks s‚ÇÇ x‚ÇÇ y +
        (conj (Ks s‚ÇÅ x‚ÇÅ y') * Ks s‚ÇÇ x‚ÇÇ y - conj (Ks s‚ÇÅ x‚ÇÅ y') * Ks s‚ÇÇ x‚ÇÇ y')‚Äñ‚Çë := by
      simp only [correlation, sub_add_sub_cancel]
    _ ‚â§ ‚Äñconj (Ks s‚ÇÅ x‚ÇÅ y) * Ks s‚ÇÇ x‚ÇÇ y - conj (Ks s‚ÇÅ x‚ÇÅ y') * Ks s‚ÇÇ x‚ÇÇ y‚Äñ‚Çë +
        ‚Äñconj (Ks s‚ÇÅ x‚ÇÅ y') * Ks s‚ÇÇ x‚ÇÇ y - conj (Ks s‚ÇÅ x‚ÇÅ y') * Ks s‚ÇÇ x‚ÇÇ y'‚Äñ‚Çë := enorm_add_le _ _
    _ = ‚ÄñKs s‚ÇÅ x‚ÇÅ y - Ks s‚ÇÅ x‚ÇÅ y'‚Äñ‚Çë * ‚ÄñKs s‚ÇÇ x‚ÇÇ y‚Äñ‚Çë +
        ‚ÄñKs s‚ÇÅ x‚ÇÅ y'‚Äñ‚Çë * ‚ÄñKs s‚ÇÇ x‚ÇÇ y - Ks s‚ÇÇ x‚ÇÇ y'‚Äñ‚Çë := by
      simp only [‚Üê sub_mul, ‚Üê mul_sub, enorm_mul, RCLike.enorm_conj, ‚Üê map_sub]
    _ ‚â§ 2 ^ ((2 * ùïî + 4 + ùïî / 4) * a ^ 3) / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) *
        volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) *
        (edist y y' ^ œÑ / (D ^ s‚ÇÅ) ^ œÑ + edist y y' ^ œÑ / (D ^ s‚ÇÇ) ^ œÑ) := by
      have h2 : (2 : ‚Ñù‚â•0‚àû) ^ ((2 * ùïî + 4 + ùïî / 4) * a ^ 3) = C2_1_3 a * D2_1_3 a := by
        simp only [C2_1_3, D2_1_3]
        norm_cast
        ring
      rw [mul_comm, mul_add, h2, mul_comm (volume _)]
      rw [ENNReal.mul_div_mul_comm (.inr measure_ball_ne_top) (.inl measure_ball_ne_top), mul_assoc]
      apply add_le_add (aux_6_2_3 s‚ÇÅ s‚ÇÇ x‚ÇÅ x‚ÇÇ y y')
      rw [‚Üê neg_sub, enorm_neg]
      convert aux_6_2_3 s‚ÇÇ s‚ÇÅ x‚ÇÇ x‚ÇÅ y' y using 1
      simp only [‚Üê mul_assoc,
        ‚Üê ENNReal.mul_div_mul_comm (.inr measure_ball_ne_top) (.inl measure_ball_ne_top)]
      rw [mul_comm (volume _), edist_comm]
    _ ‚â§ 2 ^ ((2 * ùïî + 4 + ùïî / 4) * a ^ 3) / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) *
        volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) * (2 * (edist y y' ^ œÑ / (D ^ s‚ÇÅ) ^ œÑ)) := by
      simp only [two_mul, defaultA, defaultD, Nat.cast_pow, Nat.cast_ofNat, defaultœÑ]
      gcongr
      exact_mod_cast one_le_realD _
    _ = 2 ^ ((2 * ùïî + 4 + ùïî / 4) * a ^ 3) * 2 / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) *
        volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) * (edist y y' ^ œÑ / (D ^ s‚ÇÅ) ^ œÑ) := by
      rw [‚Üê mul_assoc, mul_comm _ 2]
      congr 1
      rw [‚Üê mul_div_assoc, mul_comm]
    _ ‚â§ 2 ^ ((2 * ùïî + 5 + ùïî / 4) * a ^ 3) / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) *
        volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) * (edist y y' ^ œÑ / (2 * D ^ s‚ÇÅ) ^ œÑ) := by
      rw [ENNReal.mul_rpow_of_nonneg _ _ (œÑ_nonneg X)]
      nth_rw 4 [‚Üê neg_neg œÑ]; rw [ENNReal.rpow_neg, ‚Üê ENNReal.div_eq_inv_mul, ‚Üê ENNReal.div_mul]
      rotate_left
      ¬∑ right; rw [‚Üê ENNReal.inv_ne_top, ENNReal.rpow_neg, inv_inv]
        exact ENNReal.rpow_ne_top_of_nonneg' zero_lt_two ENNReal.ofNat_ne_top
      ¬∑ exact .inr (ENNReal.rpow_ne_top_of_nonneg' zero_lt_two ENNReal.ofNat_ne_top)
      rw [‚Üê mul_assoc, ‚Üê mul_rotate, ‚Üê mul_div_assoc (2 ^ (-œÑ))]; gcongr ?_ / _ * _
      rw [show (2 : ‚Ñù‚â•0‚àû) ^ (-œÑ) * 2 ^ ((2 * ùïî + 5 + ùïî / 4) * a ^ 3) =
        2 ^ ((2 * ùïî + 4 + ùïî / 4) * a ^ 3) * (2 ^ (a ^ 3) * 2 ^ (-œÑ)) by ring]; gcongr
      nth_rw 1 [‚Üê ENNReal.rpow_one 2, ‚Üê ENNReal.rpow_natCast,
        ‚Üê ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top]
      refine ENNReal.rpow_le_rpow_of_exponent_le one_le_two ?_
      rw [‚Üê sub_eq_add_neg, le_sub_iff_add_le']
      calc
        _ ‚â§ (1 : ‚Ñù) + 1 := by gcongr; exact œÑ_le_one (X := X)
        _ ‚â§ a := by norm_cast; linarith only [four_le_a X]
        _ ‚â§ _ := mod_cast Nat.le_self_pow three_ne_zero _
    _ = _ := by rw [‚Üê ENNReal.mul_comm_div]

/-- Second part of Lemma 6.2.1 (eq. 6.2.3). -/
lemma correlation_kernel_bound {s‚ÇÅ s‚ÇÇ : ‚Ñ§} {x‚ÇÅ x‚ÇÇ : X} (hs : s‚ÇÅ ‚â§ s‚ÇÇ) :
    iHolENorm (correlation s‚ÇÅ s‚ÇÇ x‚ÇÅ x‚ÇÇ) x‚ÇÅ (2 * D ^ s‚ÇÅ) ‚â§
    C6_2_1 a / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) * volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) := by
  -- 6.2.4
  have hœÜ' (y : X) : ‚Äñcorrelation s‚ÇÅ s‚ÇÇ x‚ÇÅ x‚ÇÇ y‚Äñ‚Çë ‚â§
      (C2_1_3 a) ^ 2 / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) * volume (ball x‚ÇÇ (D ^ s‚ÇÇ))):= by
    simp only [correlation, enorm_mul, RCLike.enorm_conj, pow_two,
      ENNReal.mul_div_mul_comm (.inr measure_ball_ne_top) (.inl measure_ball_ne_top)]
    exact mul_le_mul' enorm_Ks_le enorm_Ks_le
  -- Bound 6.2.6 + 6.2.7
  calc
    _ ‚â§ C2_1_3 a ^ 2 / (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) * volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) +
        2 ^ ((2 * ùïî + 5 + ùïî / 4) * a ^ 3) /
        (volume (ball x‚ÇÅ (D ^ s‚ÇÅ)) * volume (ball x‚ÇÇ (D ^ s‚ÇÇ))) := by
      apply add_le_add (iSup‚ÇÇ_le fun x _ ‚Ü¶ hœÜ' x)
      simp only [ENNReal.mul_iSup, iSup_le_iff]
      intro z hz z' hz' hzz'
      convert e625 hzz' hs
      rw [ENNReal.ofReal_mul zero_le_two, ENNReal.ofReal_ofNat, ‚Üê Real.rpow_intCast,
        ‚Üê ENNReal.ofReal_rpow_of_pos (realD_pos _), ENNReal.ofReal_natCast,
        ENNReal.rpow_intCast]
    _ ‚â§ _ := by
      rw [‚Üê ENNReal.add_div]
      refine ENNReal.div_le_div_right ?_ _
      rw [C2_1_3, C6_2_1]
      norm_cast
      rw [‚Üê pow_mul]
      apply add_le_pow_two ?_ le_rfl ?_
      ¬∑ ring_nf
        omega
      ¬∑ ring_nf
        suffices 1 ‚â§ a ^ 3 by omega
        exact one_le_pow‚ÇÄ (by linarith [four_le_a X])

variable [TileStructure Q D Œ∫ S o]

/-- Lemma 6.2.2. -/
lemma range_support {p : ùîì X} {g : X ‚Üí ‚ÑÇ} {y : X} (hpy : adjointCarleson p g y ‚â† 0) :
    y ‚àà ball (ùî† p) (5 * D ^ ùî∞ p) := by
  simp only [adjointCarleson] at hpy
  obtain ‚ü®x, hxE, hx0‚ü© := exists_ne_zero_of_setIntegral_ne_zero hpy
  have hxp : dist x (ùî† p) < 4 * D ^ ùî∞ p := -- 6.2.13
    Grid_subset_ball (mem_of_subset_of_mem (fun _ ha ‚Ü¶ ha.1) hxE)
  have hyx : dist y x ‚â§ 1 / 2 * D ^ ùî∞ p := by -- 6.2.14
    have hK : Ks (ùî∞ p) x y ‚â† 0 := by
      by_contra h0
      simp [h0] at hx0
    rw [dist_comm]
    convert (dist_mem_Icc_of_Ks_ne_zero hK).2 using 1
    ring
  have hpos := defaultD_pow_pos a (ùî∞ p)
  have hle : (9 : ‚Ñù) / 2 < 5 := by norm_num
  calc
    _ ‚â§ dist y x + dist x (ùî† p) := dist_triangle ..
    _ ‚â§ 1 / 2 * D ^ ùî∞ p + 4 * D ^ ùî∞ p := add_le_add hyx hxp.le
    _ < _ := by ring_nf; gcongr -- uses hpos, hle.

/-- The constant from lemma 6.2.3. -/
def C6_2_3 (a : ‚Ñï) : ‚Ñù‚â•0 := 2 ^ (8 * a)

private lemma ineq_6_2_16 {p : ùîì X} {x : X} (hx : x ‚àà E p) : dist_(p) (Q x) (ùí¨ p) < 1 :=
  subset_cball hx.2.1

/-- Lemma 6.2.3 (dist version). -/
lemma uncertainty' (ha : 1 ‚â§ a) {p‚ÇÅ p‚ÇÇ : ùîì X} (hle : ùî∞ p‚ÇÅ ‚â§ ùî∞ p‚ÇÇ)
    (hinter : (ball (ùî† p‚ÇÅ) (5 * D ^ ùî∞ p‚ÇÅ) ‚à© ball (ùî† p‚ÇÇ) (5 * D ^ ùî∞ p‚ÇÇ)).Nonempty) {x‚ÇÅ x‚ÇÇ : X}
    (hx‚ÇÅ : x‚ÇÅ ‚àà E p‚ÇÅ) (hx‚ÇÇ : x‚ÇÇ ‚àà E p‚ÇÇ) :
    1 + dist_(p‚ÇÅ) (ùí¨ p‚ÇÅ) (ùí¨ p‚ÇÇ) ‚â§ C6_2_3 a * (1 + dist_{x‚ÇÅ, D ^ ùî∞ p‚ÇÅ} (Q x‚ÇÅ) (Q x‚ÇÇ)) := by
  -- Inequalities 6.2.16.
  have hp‚ÇÅ : dist_(p‚ÇÅ) (ùí¨ p‚ÇÅ) (Q x‚ÇÅ) < 1 := by rw [dist_comm]; exact ineq_6_2_16 hx‚ÇÅ
  have hp‚ÇÇ := ineq_6_2_16 hx‚ÇÇ
  --Needed for ineq. 6.2.17
  have hss : ‚Üë(ùìò p‚ÇÅ) ‚äÜ ball (ùî† p‚ÇÇ) (14 * D^ùî∞ p‚ÇÇ) := by
    have h1D : 1 ‚â§ (D : ‚Ñù) := one_le_realD a
    have hdist : dist (ùî† p‚ÇÅ) (ùî† p‚ÇÇ) < 10 * D ^ ùî∞ p‚ÇÇ := by
      have h5 : 10 * (D : ‚Ñù) ^ ùî∞ p‚ÇÇ = 5 * D ^ ùî∞ p‚ÇÇ + 5 * D ^ ùî∞ p‚ÇÇ := by ring
      obtain ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü© := hinter
      rw [mem_ball, dist_comm] at hy‚ÇÅ
      apply (dist_triangle ..).trans_lt
      apply (add_lt_add hy‚ÇÅ hy‚ÇÇ).trans_le
      rw [h5]
      gcongr -- uses h1D
    refine Grid_subset_ball.trans fun x hx ‚Ü¶ ?_
    rw [mem_ball] at hx ‚ä¢
    calc
      _ ‚â§ dist x (ùî† p‚ÇÅ) + dist (ùî† p‚ÇÅ) (ùî† p‚ÇÇ) := dist_triangle ..
      _ < 4 * D ^ ùî∞ p‚ÇÅ + 10 * D ^ ùî∞ p‚ÇÇ := add_lt_add hx hdist
      _ ‚â§ 4 * D ^ ùî∞ p‚ÇÇ + 10 * D ^ ùî∞ p‚ÇÇ := by gcongr -- uses h1D, hle
      _ = _ := by ring
  -- Inequality 6.2.17.
  have hp‚ÇÅp‚ÇÇ : dist_(p‚ÇÅ) (Q x‚ÇÇ) (ùí¨ p‚ÇÇ) ‚â§ 2 ^ (6 * a) := by
    calc
      _ ‚â§ 2 ^ (6 * a) * dist_(p‚ÇÇ) (Q x‚ÇÇ) (ùí¨ p‚ÇÇ) := by
        set r := (D : ‚Ñù) ^ ùî∞ p‚ÇÇ / 4 with hr_def
        have hr : 0 < (D : ‚Ñù) ^ ùî∞ p‚ÇÇ / 4 := by
          rw [div_pos_iff_of_pos_right (by positivity)]
          exact defaultD_pow_pos a (ùî∞ p‚ÇÇ)
        have haux : dist_{ùî† p‚ÇÇ, 2 ^ 6 * r} (Q x‚ÇÇ) (ùí¨ p‚ÇÇ) ‚â§
          2 ^ (6 * a) * dist_{ùî† p‚ÇÇ, r} (Q x‚ÇÇ) (ùí¨ p‚ÇÇ) := by
          have h6a : (2 : ‚Ñù) ^ (6 * a) = defaultA a ^ 6 := by simp; ring
          convert cdist_le_iterate hr (Q x‚ÇÇ) (ùí¨ p‚ÇÇ) 6
        exact (cdist_mono (ball_subset_Grid.trans
          (hss.trans (ball_subset_ball (by linarith))))).trans haux
      _ ‚â§ _ := by
        nth_rw 2 [‚Üê mul_one (2 ^ _)]
        exact mul_le_mul_of_nonneg_left hp‚ÇÇ.le (by positivity)
  -- Auxiliary ineq. for 6.2.18
  have haux : dist_(p‚ÇÅ) (ùí¨ p‚ÇÅ) (ùí¨ p‚ÇÇ) ‚â§ 1 + 2 ^ (6 * a) + dist_(p‚ÇÅ) (Q x‚ÇÅ) (Q x‚ÇÇ) :=
    calc
      _ ‚â§ dist_(p‚ÇÅ) (ùí¨ p‚ÇÅ) (Q x‚ÇÅ) + dist_(p‚ÇÅ) (Q x‚ÇÅ) (Q x‚ÇÇ) + dist_(p‚ÇÅ) (Q x‚ÇÇ) (ùí¨ p‚ÇÇ) :=
        dist_triangle4 ..
      _ ‚â§ 1 + dist_(p‚ÇÅ) (Q x‚ÇÅ) (Q x‚ÇÇ) + 2 ^ (6 * a) := add_le_add_three hp‚ÇÅ.le le_rfl hp‚ÇÅp‚ÇÇ
      _ = _ := by ring
  calc
    -- 6.2.18
    _ ‚â§ 2 + 2 ^ (6 * a) + dist_(p‚ÇÅ) (Q x‚ÇÅ) (Q x‚ÇÇ) := by
      have h2 : (2 + 2 ^ (6 * a) : ‚Ñù) = 1 + (1 + 2 ^ (6 * a)) := by ring
      rw [h2, add_assoc]
      exact add_le_add le_rfl haux
    -- 6.2.21
    _ ‚â§ 2 + 2 ^ (6 * a) + dist_{x‚ÇÅ, 8 * D ^ ùî∞ p‚ÇÅ} (Q x‚ÇÅ) (Q x‚ÇÇ) := by
      apply add_le_add le_rfl
      -- 6.2.19
      have h1 : dist (ùî† p‚ÇÅ) x‚ÇÅ < 4 * D ^ ùî∞ p‚ÇÅ := by rw [dist_comm]; exact Grid_subset_ball hx‚ÇÅ.1
      -- 6.2.20
      have hI : ‚Üë(ùìò p‚ÇÅ) ‚äÜ ball x‚ÇÅ (8 * D ^ ùî∞ p‚ÇÅ) := by
        refine Grid_subset_ball.trans fun x hx ‚Ü¶ ?_
        calc
          _ ‚â§ dist x (ùî† p‚ÇÅ) + dist (ùî† p‚ÇÅ) x‚ÇÅ := dist_triangle _ _ _
          _ < 4 * D ^ ùî∞ p‚ÇÅ + 4 * D ^ ùî∞ p‚ÇÅ := add_lt_add hx h1
          _ = _ := by ring
      exact cdist_mono (subset_trans ball_subset_Grid hI)
    -- 6.2.22
    _ ‚â§ 2 + 2 ^ (6 * a) + 2 ^ (3 * a) * dist_{x‚ÇÅ, D ^ ùî∞ p‚ÇÅ} (Q x‚ÇÅ) (Q x‚ÇÇ) := by
      gcongr
      have hr : 0 < (D : ‚Ñù) ^ ùî∞ p‚ÇÅ := defaultD_pow_pos a (ùî∞ p‚ÇÅ)
      have h8 : (8 : ‚Ñù) = 2 ^ 3 := by norm_num
      have h3a : (2 : ‚Ñù) ^ (3 * a) = defaultA a ^ 3 := by simp; ring
      convert cdist_le_iterate hr (Q x‚ÇÅ) (Q x‚ÇÇ) 3 -- uses h8, h3a
    -- 6.2.15
    _ ‚â§ _ := by
      have hpow : (2 : ‚Ñù) + 2 ^ (6 * a) ‚â§ 2 ^ (a * 8) :=
        calc
          _ ‚â§ (2 : ‚Ñù) ^ (6 * a) + 2 ^ (6 * a) := by
            apply add_le_add_right
            norm_cast
            nth_rw 1 [‚Üê pow_one 2]
            exact Nat.pow_le_pow_right zero_lt_two (by omega)
          _ = 2 * (2 : ‚Ñù) ^ (6 * a) := by ring
          _ ‚â§ _ := by
            nth_rw 1 [‚Üê pow_one 2, ‚Üê pow_add]
            norm_cast
            exact Nat.pow_le_pow_right zero_lt_two (by omega)
      have h38 : 3 ‚â§ 8 := by omega
      have h12 : (1 : ‚Ñù) ‚â§ 2 := by norm_num
      rw [C6_2_3]
      conv_rhs => ring_nf
      push_cast
      rw [mul_comm 3]
      gcongr

/-- Lemma 6.2.3 (edist version). -/
lemma uncertainty (ha : 1 ‚â§ a) {p‚ÇÅ p‚ÇÇ : ùîì X} (hle : ùî∞ p‚ÇÅ ‚â§ ùî∞ p‚ÇÇ)
    (hinter : (ball (ùî† p‚ÇÅ) (5 * D ^ ùî∞ p‚ÇÅ) ‚à© ball (ùî† p‚ÇÇ) (5 * D ^ ùî∞ p‚ÇÇ)).Nonempty) {x‚ÇÅ x‚ÇÇ : X}
    (hx‚ÇÅ : x‚ÇÅ ‚àà E p‚ÇÅ) (hx‚ÇÇ : x‚ÇÇ ‚àà E p‚ÇÇ) :
    1 + edist_(p‚ÇÅ) (ùí¨ p‚ÇÅ) (ùí¨ p‚ÇÇ) ‚â§ C6_2_3 a * (1 + edist_{x‚ÇÅ, D ^ ùî∞ p‚ÇÅ} (Q x‚ÇÅ) (Q x‚ÇÇ)) := by
  have hC : C6_2_3 a = ENNReal.ofReal (C6_2_3 a) := by rw [ENNReal.ofReal_coe_nnreal]
  simp only [edist_dist, ‚Üê ENNReal.ofReal_one, hC, ‚Üê ENNReal.ofReal_add zero_le_one dist_nonneg,
    ‚Üê ENNReal.ofReal_mul NNReal.zero_le_coe]
  exact ENNReal.ofReal_le_ofReal (uncertainty' ha hle hinter hx‚ÇÅ hx‚ÇÇ)

section lemma_6_1_5

/-- The constant from lemma 6.1.5.
Has value `2 ^ (232 * a ^ 3)` in the blueprint. -/
def C6_1_5 (a : ‚Ñï) : ‚Ñù‚â•0 := 2 ^ ((2 * ùïî + 7 + ùïî / 4) * a ^ 3)

lemma C6_1_5_bound (ha : 4 ‚â§ a) :
    2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 1) * 2 ^ (11 * a) ‚â§ C6_1_5 a := by
  have h142 : a ^ 3 = a ^ 2 * a := rfl
  rw [C6_1_5, ‚Üê pow_add]
  exact pow_le_pow le_rfl one_le_two (by nlinarith)

open GridStructure

lemma complex_exp_lintegral {p : ùîì X} {g : X ‚Üí ‚ÑÇ} (y : X) :
    conj (‚à´ y1 in E p, conj (Ks (ùî∞ p) y1 y) * exp (I * (Q y1 y1 - Q y1 y)) * g y1) =
    ‚à´ y1 in E p, Ks (ùî∞ p) y1 y * exp (I * (-Q y1 y1 + Q y1 y)) * conj (g y1) := by
  simp only [‚Üê integral_conj, map_mul, RingHomCompTriple.comp_apply, RingHom.id_apply]
  congr; ext x; rw [‚Üê exp_conj]; congr
  simp only [map_mul, conj_I, map_sub, conj_ofReal]
  ring

/-- Definition (6.2.27). -/
def I12 (p p' : ùîì X) (g : X ‚Üí ‚ÑÇ) (x1 x2 : X) : ‚Ñù‚â•0‚àû :=
  ‚Äñ(‚à´ y, exp (I * (-Q x1 y + Q x2 y)) * correlation (ùî∞ p') (ùî∞ p) x1 x2 y) * g x1 * g x2‚Äñ‚Çë

/-- Inequality (6.2.28). -/
lemma I12_le' {p p' : ùîì X} (hle : ùî∞ p' ‚â§ ùî∞ p) {g : X ‚Üí ‚ÑÇ} (x1 : E p') (x2 : E p) :
    I12 p p' g x1 x2 ‚â§
    2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 8 * a) *
      ((1 + edist_{x1.1, D ^ ùî∞ p'} (Q x1) (Q x2)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π)) /
    volume (ball x2.1 (D ^ ùî∞ p)) * ‚Äñg x1‚Äñ‚Çë * ‚Äñg x2‚Äñ‚Çë := by
  have hD' : 0 < (D : ‚Ñù) ^ ùî∞ p' := defaultD_pow_pos a (ùî∞ p')
  have hsupp : support (correlation (ùî∞ p') (ùî∞ p) x1.1 x2) ‚äÜ ball x1 (D ^ ùî∞ p') :=
    fun _ hx ‚Ü¶ mem_ball_of_correlation_ne_zero hx
  -- For compatibility with holder_van_der_corput
  have heq : 2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 8 * a) *
      (1 + edist_{x1.1, D ^ ùî∞ p'} (Q x1) (Q x2)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) /
      volume (ball x2.1 (D ^ ùî∞ p)) =
      (2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 8 * a)) / volume (ball x2.1 (D ^ ùî∞ p)) *
      (1 + edist_{x1.1, D ^ ùî∞ p'} (Q x1) (Q x2)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) := by
    rw [ENNReal.mul_comm_div, mul_comm, mul_comm _ (2 ^ _), mul_div_assoc]
  simp only [I12, enorm_mul]
  gcongr
  simp_rw [‚Üê sub_eq_neg_add]
  apply (holder_van_der_corput hsupp).trans
  rw [heq, edist_comm]
  gcongr
  ¬∑ have hbdd := correlation_kernel_bound (a := a) (X := X) hle (x‚ÇÅ := x1) (x‚ÇÇ := x2)
    have hle : C2_0_5 a * volume (ball x1.1 (D ^ ùî∞ p')) *
        iHolENorm (a := a) (correlation (ùî∞ p') (ùî∞ p) x1.1 x2.1) x1 (2 * D ^ ùî∞ p') ‚â§
        C2_0_5 a * volume (ball x1.1 (D ^ ùî∞ p')) *
        (C6_2_1 a / (volume (ball x1.1 (D ^ ùî∞ p')) * volume (ball x2.1 (D ^ ùî∞ p)))) := by
      gcongr
    -- Note: simp, ring_nf, field_simp did not help.
    have heq : C2_0_5 a * volume (ball x1.1 (D ^ ùî∞ p')) *
      (C6_2_1 a / (volume (ball x1.1 (D ^ ùî∞ p')) * volume (ball x2.1 (D ^ ùî∞ p)))) =
      C2_0_5 a * (C6_2_1 a / volume (ball x2.1 (D ^ ùî∞ p))) := by
      simp only [mul_assoc]
      congr 1
      rw [ENNReal.div_eq_inv_mul, ENNReal.mul_inv (.inr measure_ball_ne_top)
        (.inl measure_ball_ne_top), ‚Üê mul_assoc, ‚Üê mul_assoc, ENNReal.mul_inv_cancel
        (measure_ball_pos volume _ hD').ne' measure_ball_ne_top, one_mul, ENNReal.div_eq_inv_mul]
    apply hle.trans
    rw [heq, mul_div]
    apply ENNReal.div_le_div _ le_rfl
    simp only [C2_0_5, C6_2_1, ENNReal.coe_pow, ENNReal.coe_ofNat]
    rw [pow_add, mul_comm]
    norm_cast
    gcongr
    ¬∑ exact one_le_two
    ¬∑ omega

private lemma exp_ineq (ha : 4 ‚â§ a) : 0 < (8 * a : ‚Ñï) * -(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π + 1 := by
  have hpos : 0 < (a : ‚Ñù) ^ 2 * 2 + a ^ 3 := by positivity
  ring_nf
  rw [Nat.cast_mul, Nat.cast_ofNat, sub_pos, ‚Üê div_eq_mul_inv, div_lt_one hpos]
  norm_cast
  nlinarith

/-- Inequality (6.2.29). -/
lemma I12_le (ha : 4 ‚â§ a) {p p' : ùîì X} (hle : ùî∞ p' ‚â§ ùî∞ p) {g : X ‚Üí ‚ÑÇ}
    (hinter : (ball (ùî† p') (5 * D ^ ùî∞ p') ‚à© ball (ùî† p) (5 * D ^ ùî∞ p)).Nonempty)
    (x1 : E p') (x2 : E p) :
    I12 p p' g x1 x2 ‚â§
    (2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 8 * a + 1) *
      ((1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π))) /
    volume (ball x2.1 (D ^ ùî∞ p)) * ‚Äñg x1‚Äñ‚Çë * ‚Äñg x2‚Äñ‚Çë := by
  apply (I12_le' hle x1 x2).trans
  gcongr ?_ * _ * _
  rw [pow_add 2 _ 1, pow_one, mul_comm _ 2, mul_assoc, mul_comm 2 (_ * _), mul_assoc]
  gcongr
  -- Now we need to use Lemma 6.2.3 to conclude this inequality.
  have h623 := uncertainty (by omega) hle hinter x1.2 x2.2
  rw [C6_2_3, ENNReal.coe_pow, ENNReal.coe_ofNat] at h623
  have hneg : -(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π < 0 :=
    neg_neg_iff_pos.mpr (inv_pos.mpr (by norm_cast; nlinarith))
  rw [‚Üê ENNReal.rpow_le_rpow_iff_of_neg hneg] at h623
  have h0 : ((2 : ‚Ñù‚â•0‚àû) ^ (8 * a)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) ‚â† 0 := by simp
  have h210 : (2 : ‚Ñù‚â•0‚àû) ^ (1 : ‚Ñù) ‚â† 0 := by rw [ENNReal.rpow_one]; exact two_ne_zero
  rw [ENNReal.mul_rpow_of_ne_top (Ne.symm (not_eq_of_beq_eq_false rfl)) (by simp [edist_dist]),
    mul_comm, ‚Üê ENNReal.le_div_iff_mul_le (.inl h0) (.inr (by simp [edist_dist]))] at h623
  apply h623.trans
  rw [ENNReal.div_eq_inv_mul, mul_comm _ 2]
  gcongr
  conv_rhs => rw [‚Üê ENNReal.rpow_one (2 : ‚Ñù‚â•0‚àû)]
  rw [ENNReal.inv_le_iff_le_mul (fun _ ‚Ü¶ h0) (fun _ ‚Ü¶ h210), ‚Üê ENNReal.rpow_natCast 2,
    ‚Üê ENNReal.rpow_mul, ‚Üê ENNReal.rpow_add _ _ two_ne_zero ENNReal.ofNat_ne_top]
  exact ENNReal.one_le_rpow one_le_two (exp_ineq ha)

/-- Inequality (6.2.32). -/
lemma volume_coeGrid_le {p : ùîì X} (x2 : E p) :
    volume (ùìò p : Set X) ‚â§ 2 ^ (3 * a) * volume (ball x2.1 (D ^ ùî∞ p)) := by
  -- Inequality 6.2.30
  have hdist : dist (ùî† p) x2 < 4 * D ^ ùî∞ p :=
    dist_comm (ùî† p) x2 ‚ñ∏ Grid_subset_ball (mem_of_subset_of_mem (fun _ ha ‚Ü¶ ha.1) x2.prop)
  -- Inclusion 6.2.31
  have hsub : (ùìò p : Set X) ‚äÜ ball x2 (8 * D ^ ùî∞ p) := by
    refine Grid_subset_ball.trans fun x hx ‚Ü¶ ?_
    calc
      _ ‚â§ dist x (ùî† p) + dist (ùî† p) x2 := dist_triangle ..
      _ < 4 * D ^ ùî∞ p + 4 * D ^ ùî∞ p := add_lt_add hx hdist
      _ = _ := by ring
  apply (measure_mono hsub).trans
  rw [show (8 : ‚Ñù) = 2 ^ 3 by norm_num]
  convert measure_ball_two_le_same_iterate (Œº := volume) x2.1 (D ^ ùî∞ p) 3 using 2
  rw [mul_comm 3, pow_mul]; simp

lemma bound_6_2_29 (ha : 4 ‚â§ a) {p p' : ùîì X} (x2 : E p) :
    2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 8 * a + 1) *
    (1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) / volume (ball x2.1 (D ^ ùî∞ p)) ‚â§
    C6_1_5 a *
    (1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) / volume (ùìò p : Set X) := by
  rw [mul_comm, mul_div_assoc, mul_comm (C6_1_5 a : ‚Ñù‚â•0‚àû), mul_div_assoc]
  refine mul_le_mul_left' ?_ _
  calc
    _ = 2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 1) * 2 ^ (11 * a) * 2 ^ (-(3 : ‚Ñ§) * a) /
        volume (ball x2.1 (D ^ ùî∞ p)) := by
      simp_rw [‚Üê zpow_natCast, ‚Üê ENNReal.zpow_add two_ne_zero ENNReal.ofNat_ne_top]
      congr; push_cast; ring
    _ = 2 ^ ((2 * ùïî + 6 + ùïî / 4) * a ^ 3 + 1) * 2 ^ (11 * a) /
        (2 ^ (3 * a) * volume (ball x2.1 (D ^ ùî∞ p))) := by
      rw [div_eq_mul_inv, div_eq_mul_inv, ENNReal.mul_inv (by left; positivity) (by left; simp),
        ‚Üê mul_assoc, ‚Üê zpow_natCast _ (3 * a), ‚Üê ENNReal.zpow_neg two_ne_zero ENNReal.ofNat_ne_top]
      congr
    _ ‚â§ C6_1_5 a / (2 ^ (3 * a) * volume (ball x2.1 (D ^ ùî∞ p))) := by
      gcongr; exact ENNReal.coe_le_coe.mpr (C6_1_5_bound ha)
    _ ‚â§ _ := by gcongr; exact volume_coeGrid_le _

omit [TileStructure Q D Œ∫ S o] in
lemma enorm_eq_zero_of_notMem_closedBall {g : X ‚Üí ‚ÑÇ} (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x)
    {x : X} (hx : x ‚àâ closedBall o (D ^ S / 4)) : ‚Äñg x‚Äñ‚Çë = 0 := by
  rw [enorm_eq_zero, ‚Üê norm_eq_zero]
  refine le_antisymm ((hg1 _).trans ?_) (norm_nonneg _)
  rw [indicator_of_notMem (notMem_subset G_subset (notMem_subset ball_subset_closedBall hx))]

omit [TileStructure Q D Œ∫ S o] in
lemma eq_zero_of_notMem_closedBall {g : X ‚Üí ‚ÑÇ} (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x)
    {x : X} (hx : x ‚àâ closedBall o (D ^ S / 4)) : g x = 0 := by
  simpa [coe_nnnorm, norm_eq_zero] using enorm_eq_zero_of_notMem_closedBall hg1 hx

lemma boundedCompactSupport_star_Ks_mul_g {p' : ùîì X} {g : X ‚Üí ‚ÑÇ}
    (hg : Measurable g) (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x) :
    BoundedCompactSupport fun x : X √ó X ‚Ü¶ conj (Ks (ùî∞ p') x.1 x.2) * g x.1 := by
  apply BoundedCompactSupport.mul_bdd_left' (bcs_of_measurable_of_le_indicator_g hg hg1)
    continuous_fst
  ¬∑ exact quasiMeasurePreserving_fst
  ¬∑ fun_prop
  ¬∑ intros K hK
    obtain ‚ü®C, hC‚ü© := isBounded_iff.1 hK.isBounded
    apply isCompact_of_isClosed_isBounded
      ((IsClosed.preimage continuous_fst hK.isClosed).inter (isClosed_tsupport _))
    rw [isBounded_iff]
    use D ^ ùî∞ p' + C
    intros x hx y hy
    rw [Prod.dist_eq, sup_le_iff]
    constructor
    ¬∑ calc
        _ ‚â§ _ := hC hx.1 hy.1
        _ ‚â§ _ := le_add_of_nonneg_left (by positivity)
    ¬∑ calc
        _ ‚â§ dist x.2 x.1 + dist x.1 y.1 + dist y.1 y.2 := dist_triangle4 ..
        _ ‚â§ D ^ ùî∞ p' / 2 + C + D ^ ùî∞ p' / 2 := by
          gcongr
          ¬∑ rw [dist_comm]
            have hx' : x ‚àà tsupport fun x ‚Ü¶ Ks (ùî∞ p') x.1 x.2 := by
              convert hx.2 using 1
              simp only [tsupport]
              apply congr_arg
              ext z
              simp only [mem_support, ne_eq, map_eq_zero]
            exact (dist_mem_Icc_of_mem_tsupport_Ks hx').2
          ¬∑ exact hC hx.1 hy.1
          ¬∑ have hy' : y ‚àà tsupport fun x ‚Ü¶ Ks (ùî∞ p') x.1 x.2 := by
              convert hy.2 using 1
              simp only [tsupport]
              apply congr_arg
              ext z
              simp only [mem_support, ne_eq, map_eq_zero]
            exact (dist_mem_Icc_of_mem_tsupport_Ks hy').2
        _ = _ := by ring
  ¬∑ intro A hA; rw [isBounded_image_iff]
    obtain ‚ü®C, hC0, hC‚ü© := Bornology.IsBounded.exists_bound_of_norm_Ks hA (ùî∞ p')
    use C + C; intro x hx y hy; rw [dist_conj_conj]
    calc
      _ ‚â§ _ := dist_le_norm_add_norm ..
      _ ‚â§ _ := add_le_add (hC x.1 x.2 hx) (hC y.1 y.2 hy)

lemma boundedCompactSupport_Ks_mul_star_g {p : ùîì X} {g : X ‚Üí ‚ÑÇ}
    (hg : Measurable g) (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x) :
    BoundedCompactSupport fun x : X √ó X ‚Ü¶ Ks (ùî∞ p) x.1 x.2 * (conj ‚àò g) x.1 := by
  conv => enter [1, x]; rw [‚Üê conj_conj (_ * _), map_mul, comp_apply, conj_conj]
  exact (boundedCompactSupport_star_Ks_mul_g hg hg1).conj

lemma boundedCompactSupport_aux_6_2_26 {p p' : ùîì X} {g : X ‚Üí ‚ÑÇ}
    (hg : Measurable g) (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x) :
    BoundedCompactSupport fun (x, z1, z2) ‚Ü¶
      conj (Ks (ùî∞ p') z1 x) * exp (I * (Q z1 z1 - Q z1 x)) * g z1 *
      (Ks (ùî∞ p) z2 x * exp (I * (-Q z2 z2 + Q z2 x)) * conj (g z2)) := by
  suffices BoundedCompactSupport fun (x, z1, z2) ‚Ü¶
      conj (Ks (ùî∞ p') z1 x) * g z1 * (Ks (ùî∞ p) z2 x * conj (g z2)) by
    have heq : (fun (x, z1, z2) ‚Ü¶ conj (Ks (ùî∞ p') z1 x) *
        exp (I * (Q z1 z1 - Q z1 x)) * g z1 * (Ks (ùî∞ p) z2 x *
          exp (I * (-Q z2 z2 + Q z2 x)) * conj (g z2))) =
        fun (x, z1, z2) ‚Ü¶ conj (Ks (ùî∞ p') z1 x) * g z1 *
          (Ks (ùî∞ p) z2 x * conj (g z2)) * (exp (I * (Q z1 z1 - Q z1 x)) *
            exp (I * (-Q z2 z2 + Q z2 x))) := by ext; ring
    exact heq ‚ñ∏ BoundedCompactSupport.mul_bdd_right this
      ‚ü®(Measurable.stronglyMeasurable (by fun_prop)).aestronglyMeasurable, lt_of_le_of_lt
        (eLpNorm_le_of_ae_bound (C := 1) (Filter.Eventually.of_forall
          (fun x ‚Ü¶ by simp [‚Üê ofReal_sub, mul_comm I, ‚Üê ofReal_neg, ‚Üê ofReal_add]))) (by simp)‚ü©
  constructor
  ¬∑ -- MemLp
    constructor
    ¬∑ -- AEStronglyMeasurable
      exact (Measurable.stronglyMeasurable (by fun_prop)).aestronglyMeasurable
    ¬∑ -- eLpNorm < ‚ä§
      simp only [eLpNorm_exponent_top, eLpNormEssSup_lt_top_iff_isBoundedUnder]
      have h1 : Filter.IsBoundedUnder (¬∑ ‚â§ ¬∑) (ae volume) fun x : X √ó X ‚Ü¶
          ‚Äñconj (Ks (ùî∞ p') x.1 x.2) * g x.1‚Äñ‚Çä := by
        rw [‚Üê eLpNormEssSup_lt_top_iff_isBoundedUnder, ‚Üê eLpNorm_exponent_top]
        exact (boundedCompactSupport_star_Ks_mul_g hg hg1).memLp_top.eLpNorm_lt_top
      have h2 : Filter.IsBoundedUnder (¬∑ ‚â§ ¬∑) (ae volume) fun x : X √ó X ‚Ü¶
          ‚ÄñKs (ùî∞ p) x.1 x.2 * conj (g x.1)‚Äñ‚Çä := by
        rw [‚Üê eLpNormEssSup_lt_top_iff_isBoundedUnder, ‚Üê eLpNorm_exponent_top]
        exact (boundedCompactSupport_Ks_mul_star_g hg hg1).memLp_top.eLpNorm_lt_top
      obtain ‚ü®B, hB‚ü© := h1
      obtain ‚ü®C, hC‚ü© := h2
      use B * C
      simp only [nnnorm_mul, RCLike.nnnorm_conj, Filter.eventually_map] at hB hC ‚ä¢
      have hp1 : QuasiMeasurePreserving (fun z : X √ó X √ó X ‚Ü¶ (z.2.1, z.1)) volume volume := by
        suffices QuasiMeasurePreserving (Prod.map (id (Œ± := X)) (Prod.fst (Œ± := X) (Œ≤ := X)))
            volume volume from measurePreserving_swap.quasiMeasurePreserving.comp this
        fun_prop
      have hp2 : QuasiMeasurePreserving (fun z : X √ó X √ó X ‚Ü¶ (z.2.2, z.1)) volume volume := by
        suffices QuasiMeasurePreserving (Prod.map (id (Œ± := X)) (Prod.snd (Œ± := X) (Œ≤ := X)))
            volume volume from measurePreserving_swap.quasiMeasurePreserving.comp this
        fun_prop
      filter_upwards [hp1.ae hB, hp2.ae hC] with x h1x h2x
      exact mul_le_mul' h1x h2x
  ¬∑ -- HasCompactSupport
    rw [‚Üê exists_compact_iff_hasCompactSupport]
    use closedBall o (D ^ S) √óÀ¢ closedBall o (D ^ S / 4) √óÀ¢ closedBall o (D ^ S / 4)
    refine ‚ü®(isCompact_closedBall _ _).prod
      ((isCompact_closedBall _ _).prod (isCompact_closedBall _ _)), fun x hx ‚Ü¶ ?_‚ü©
    simp only [mem_prod, not_and_or] at hx
    simp only [mul_eq_zero, map_eq_zero]
    rcases hx with hx | hx | hx
    ¬∑ left
      by_cases hx2 : x.2.1 ‚àà closedBall o (D ^ S / 4)
      ¬∑ left
        simp only [mem_closedBall, not_le] at hx hx2
        apply Ks_eq_zero_of_le_dist
        calc
          _ ‚â§ (D : ‚Ñù) ^ S / 2 := by
            rw [‚Üê zpow_natCast]
            have : 1 ‚â§ (D : ‚Ñù) := one_le_realD _
            have : ùî∞ p' ‚â§ S := (range_s_subset (X := X) (mem_range_self (ùìò p'))).2
            gcongr
          _ ‚â§ D ^ S - D ^ S / 4 := by ring_nf; gcongr _ * ?_; norm_num
          _ ‚â§ dist x.1 o - D ^ S / 4 := by gcongr
          _ ‚â§ dist x.1 o - dist x.2.1 o := by gcongr
          _ ‚â§ _ := by rw [tsub_le_iff_right]; exact dist_triangle_left _ _ _
      ¬∑ exact .inr (eq_zero_of_notMem_closedBall hg1 hx2)
    ¬∑ exact .inl (.inr (eq_zero_of_notMem_closedBall hg1 hx))
    ¬∑ exact .inr (.inr (eq_zero_of_notMem_closedBall hg1 hx))

lemma bound_6_2_26_aux {p p' : ùîì X} {g : X ‚Üí ‚ÑÇ} :
    let f := fun (x, z1, z2) ‚Ü¶
      conj (Ks (ùî∞ p') z1 x) * exp (I * (Q z1 z1 - Q z1 x)) * g z1 *
      (Ks (ùî∞ p) z2 x * exp (I * (-Q z2 z2 + Q z2 x)) * conj (g z2))
    ‚à´‚Åª x in E p' √óÀ¢ E p, ‚Äñ‚à´ y, f (y, x)‚Äñ‚Çë = ‚à´‚Åª z in E p' √óÀ¢ E p, I12 p p' g z.1 z.2 := by
  congr; ext x
  -- We move `exp (I * Q x.1 x.1)`, `exp (I * -Q x.2 x.2)` and `g x.1` to the right
  -- so that we can take their product with `conj (g x.2)` out of the integral.
  have heq :
      ‚à´ y, conj (Ks (ùî∞ p') x.1 y) * exp (I * (Q x.1 x.1 - Q x.1 y)) * g x.1 *
      (Ks (ùî∞ p) x.2 y * exp (I * (-Q x.2 x.2 + Q x.2 y)) * conj (g x.2)) =
      ‚à´ y, conj (Ks (ùî∞ p') x.1 y) * exp (I * -Q x.1 y) *
      (Ks (ùî∞ p) x.2 y * exp (I * Q x.2 y)) * (exp (I * Q x.1 x.1) *
        exp (I * -Q x.2 x.2) * g x.1 * conj (g x.2)) := by
    congr; ext y
    simp_rw [mul_add I, mul_sub I, sub_eq_add_neg, exp_add]
    ring_nf
  have hx1 : ‚Äñexp (I * Q x.1 x.1)‚Äñ‚Çë = 1 := enorm_exp_I_mul_ofReal _
  have hx2 : ‚Äñexp (I * -Q x.2 x.2)‚Äñ‚Çë = 1 := mod_cast enorm_exp_I_mul_ofReal _
  simp only [I12, enorm_mul]
  simp_rw [heq, integral_mul_const, enorm_mul, RCLike.enorm_conj, ‚Üê mul_assoc]
  rw [hx1, hx2]
  simp only [mul_neg, mul_one, correlation]
  congr; ext y
  rw [mul_add I, exp_add]
  ring_nf

lemma bound_6_2_26 {p p' : ùîì X} {g : X ‚Üí ‚ÑÇ}
    (hg : Measurable g) (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x) :
    ‚Äñ‚à´ y, adjointCarleson p' g y * conj (adjointCarleson p g y)‚Äñ‚Çë ‚â§
    ‚à´‚Åª z in E p' √óÀ¢ E p, I12 p p' g z.1 z.2 := by
  have haux : ‚àÄ y,
      conj (‚à´ y1 in E p, conj (Ks (ùî∞ p) y1 y) * exp (I * (Q y1 y1 - Q y1 y)) * g y1) =
      ‚à´ y1 in E p, Ks (ùî∞ p) y1 y * exp (I * (-Q y1 y1 + Q y1 y)) * conj (g y1) :=
    complex_exp_lintegral
  simp_rw [adjointCarleson, haux, ‚Üê setIntegral_prod_mul]; rw [‚Üê setIntegral_univ]
  let f := fun (x, z1, z2) ‚Ü¶
    conj (Ks (ùî∞ p') z1 x) * exp (I * (Q z1 z1 - Q z1 x)) * g z1 *
    (Ks (ùî∞ p) z2 x * exp (I * (-Q z2 z2 + Q z2 x)) * conj (g z2))
  have hf : IntegrableOn f (univ √óÀ¢ E p' √óÀ¢ E p) (volume.prod (volume.prod volume)) :=
    (boundedCompactSupport_aux_6_2_26 hg hg1).integrable.integrableOn
  have hf' : IntegrableOn (f ¬∑.swap) ((E p' √óÀ¢ E p) √óÀ¢ univ) ((volume.prod volume).prod volume) :=
    hf.swap
  rw [‚Üê setIntegral_prod _ hf, ‚Üê setIntegral_prod_swap, setIntegral_prod _ hf', restrict_univ]
  simp_rw [Prod.swap_prod_mk, ‚Üê bound_6_2_26_aux]
  exact enorm_integral_le_lintegral_enorm _

-- We assume 6.2.23.
lemma correlation_le_of_nonempty_inter (ha : 4 ‚â§ a) {p p' : ùîì X} (hle : ùî∞ p' ‚â§ ùî∞ p) {g : X ‚Üí ‚ÑÇ}
    (hg : Measurable g) (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x)
    (hinter : (ball (ùî† p') (5 * D ^ ùî∞ p') ‚à© ball (ùî† p) (5 * D ^ ùî∞ p)).Nonempty) :
    ‚Äñ‚à´ y, adjointCarleson p' g y * conj (adjointCarleson p g y)‚Äñ‚Çë ‚â§
    C6_1_5 a * (1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) /
    volume (ùìò p : Set X) * (‚à´‚Åª y in E p', ‚Äñg y‚Äñ‚Çë) * ‚à´‚Åª y in E p, ‚Äñg y‚Äñ‚Çë := by
  calc
    _ ‚â§ _ := bound_6_2_26 hg hg1
    _ ‚â§ ‚à´‚Åª z in E p' √óÀ¢ E p,
        C6_1_5 a * (1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) /
        volume (ùìò p : Set X) * ‚Äñg z.1‚Äñ‚Çë * ‚Äñg z.2‚Äñ‚Çë := by
      refine setLIntegral_mono' (measurableSet_E.prod measurableSet_E) fun z hz ‚Ü¶ ?_
      apply (I12_le ha hle hinter ‚ü®_, hz.1‚ü© ‚ü®_, hz.2‚ü©).trans
      gcongr ?_ * _ * _; exact bound_6_2_29 ha _
    _ = _ := by
      simp only [mul_assoc]
      rw [lintegral_const_mul _ (by fun_prop)]; congr 1
      rw [‚Üê lintegral_prod_mul (by fun_prop) (by fun_prop), prod_restrict]; rfl

/-- If (6.2.23) does not hold, the LHS is zero and the result follows trivially. -/
lemma correlation_le_of_empty_inter {p p' : ùîì X} {g : X ‚Üí ‚ÑÇ}
    (hinter : ¬¨(ball (ùî† p') (5 * D ^ ùî∞ p') ‚à© ball (ùî† p) (5 * D ^ ùî∞ p)).Nonempty) :
    ‚Äñ‚à´ y, adjointCarleson p' g y * conj (adjointCarleson p g y)‚Äñ‚Çë ‚â§
    C6_1_5 a * (1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) /
    volume (ùìò p : Set X) * (‚à´‚Åª y in E p', ‚Äñg y‚Äñ‚Çë) * ‚à´‚Åª y in E p, ‚Äñg y‚Äñ‚Çë := by
  suffices ‚Äñ‚à´ y, adjointCarleson p' g y * conj (adjointCarleson p g y)‚Äñ‚Çë = 0 by
    rw [this]; exact zero_le _
  simp only [inter_nonempty, not_exists, not_and_or] at hinter
  rw [enorm_eq_zero]
  apply integral_eq_zero_of_ae (Eq.eventuallyEq _)
  ext y
  rcases hinter y with hp'y | hpy
  ¬∑ have hp'0 : adjointCarleson p' g y = 0 := by
      by_contra hy
      exact hp'y (range_support hy)
    simp [hp'0, zero_mul]
  ¬∑ have hp'0 : adjointCarleson p g y = 0 := by
      by_contra hy
      exact hpy (range_support hy)
    simp [hp'0, map_zero, mul_zero]

/-- Part 1 of Lemma 6.1.5 (eq. 6.1.43). -/
lemma correlation_le {p p' : ùîì X} (hle : ùî∞ p' ‚â§ ùî∞ p) {g : X ‚Üí ‚ÑÇ}
    (hg : Measurable g) (hg1 : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ G.indicator 1 x) :
    ‚Äñ‚à´ y, adjointCarleson p' g y * conj (adjointCarleson p g y)‚Äñ‚Çë ‚â§
    C6_1_5 a * (1 + edist_(p') (ùí¨ p') (ùí¨ p)) ^ (-(2 * a ^ 2 + a ^ 3 : ‚Ñù)‚Åª¬π) /
    volume (ùìò p : Set X) * (‚à´‚Åª y in E p', ‚Äñg y‚Äñ‚Çë) * ‚à´‚Åª y in E p, ‚Äñg y‚Äñ‚Çë := by
  by_cases hinter : (ball (ùî† p') (5 * D ^ ùî∞ p') ‚à© ball (ùî† p) (5 * D ^ ùî∞ p)).Nonempty
  ¬∑ exact correlation_le_of_nonempty_inter (four_le_a X) hle hg hg1 hinter
  ¬∑ exact correlation_le_of_empty_inter hinter

/-- Part 2 of Lemma 6.1.5 (claim 6.1.44). -/
lemma correlation_zero_of_ne_subset {p p' : ùîì X} (hle : ùî∞ p' ‚â§ ùî∞ p) {g : X ‚Üí ‚ÑÇ}
    (hp : ¬¨(ùìò p' : Set X) ‚äÜ ball (ùî† p) (14 * D ^ ùî∞ p)) :
    ‚Äñ‚à´ y, adjointCarleson p' g y * conj (adjointCarleson p g y)‚Äñ‚Çë = 0 := by
  contrapose! hp; rw [enorm_ne_zero] at hp
  obtain ‚ü®y, hy‚ü© := exists_ne_zero_of_integral_ne_zero hp
  rw [mul_ne_zero_iff, map_ne_zero] at hy
  refine Grid_subset_ball.trans fun x (mx : x ‚àà ball (ùî† p') (4 * D ^ ùî∞ p')) ‚Ü¶ ?_
  rw [mem_ball] at mx ‚ä¢
  calc
    _ ‚â§ dist x (ùî† p') + dist (ùî† p') (ùî† p) := dist_triangle ..
    _ < 4 * D ^ ùî∞ p' + (5 * D ^ ùî∞ p' + 5 * D ^ ùî∞ p) := by
      gcongr
      exact dist_lt_of_not_disjoint_ball
        (not_disjoint_iff.mpr ‚ü®_, range_support hy.1, range_support hy.2‚ü©)
    _ ‚â§ 4 * D ^ ùî∞ p + (5 * D ^ ùî∞ p + 5 * D ^ ùî∞ p) := by gcongr <;> exact one_le_realD a
    _ = _ := by ring

end lemma_6_1_5

end Tile
