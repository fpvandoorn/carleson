/- The arguments in this file replace section 10.2 (Piecewise constant functions) from the paper. -/

import Carleson.Carleson
import Carleson.HomogeneousType
import Carleson.Theorem1_1.Basic

import Mathlib.Analysis.Fourier.AddCircle
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Analysis.Convolution
import Mathlib.Analysis.Calculus.BumpFunction.Convolution
import Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension
import Mathlib.Analysis.PSeries

noncomputable section

open BigOperators
open Finset

section
open Metric
variable {Œ± : Type} {Œ≤ : Type}
--might be generalized
--TODO : choose better name
lemma uniformContinuous_iff_bounded [PseudoMetricSpace Œ±] [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {b : ‚Ñù} (bpos : b > 0):
  UniformContinuous f ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, Œ¥ < b ‚àß ‚àÄ {x y : Œ±}, dist x y < Œ¥ ‚Üí dist (f x) (f y) < Œµ := by
  rw [Metric.uniformContinuous_iff]
  constructor
  . intro h Œµ Œµpos
    obtain ‚ü®Œ¥', Œ¥'pos, hŒ¥'‚ü© := h Œµ Œµpos
    use min Œ¥' (b / 2)
    constructor
    . exact (lt_min Œ¥'pos (by linarith)).gt
    constructor
    . apply min_lt_of_right_lt
      linarith
    . intro x y hxy
      exact hŒ¥' (lt_of_lt_of_le hxy (min_le_left Œ¥' (b / 2)))
  . intro h Œµ Œµpos
    obtain ‚ü®Œ¥, Œ¥pos, _, hŒ¥‚ü© := h Œµ Œµpos
    use Œ¥
end section

/- TODO: might be generalized. -/
lemma closeSmoothApprox {f : ‚Ñù ‚Üí ‚ÑÇ} (unicontf : UniformContinuous f) {Œµ : ‚Ñù} (Œµpos : Œµ > 0):
    ‚àÉ (f‚ÇÄ : ‚Ñù ‚Üí ‚ÑÇ), ContDiff ‚Ñù ‚ä§ f‚ÇÄ ‚àß ‚àÄ x, Complex.abs (f x - f‚ÇÄ x) ‚â§ Œµ := by
  obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© := (Metric.uniformContinuous_iff.mp unicontf) Œµ Œµpos
  let œÜ : ContDiffBump (0 : ‚Ñù) := ‚ü®Œ¥/2, Œ¥, by linarith, by linarith‚ü©
  let f_0 := MeasureTheory.convolution (œÜ.normed MeasureTheory.volume) f (ContinuousLinearMap.lsmul ‚Ñù ‚Ñù) MeasureTheory.volume
  use f_0
  constructor
  . /-TODO: improve this-/
    apply HasCompactSupport.contDiff_convolution_left
    . exact ContDiffBump.hasCompactSupport_normed œÜ
    . exact ContDiffBump.contDiff_normed œÜ
    . refine Continuous.locallyIntegrable ?h.left.hg.hf
      exact unicontf.continuous
  . intro x
    rw [‚Üê Complex.dist_eq, dist_comm]
    apply ContDiffBump.dist_normed_convolution_le
    . exact unicontf.continuous.aestronglyMeasurable
    . intro y hy
      simp at hy
      exact (hŒ¥ hy).le

/- Slightly different version-/
lemma closeSmoothApproxPeriodic {f : ‚Ñù ‚Üí ‚ÑÇ} (unicontf : UniformContinuous f) (periodicf : Function.Periodic f (2 * Real.pi)) {Œµ : ‚Ñù} (Œµpos : Œµ > 0):
    ‚àÉ (f‚ÇÄ : ‚Ñù ‚Üí ‚ÑÇ), ContDiff ‚Ñù ‚ä§ f‚ÇÄ ‚àß Function.Periodic f‚ÇÄ (2 * Real.pi) ‚àß ‚àÄ x, Complex.abs (f x - f‚ÇÄ x) ‚â§ Œµ := by
  obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© := (Metric.uniformContinuous_iff.mp unicontf) Œµ Œµpos
  let œÜ : ContDiffBump (0 : ‚Ñù) := ‚ü®Œ¥/2, Œ¥, by linarith, by linarith‚ü©
  set f‚ÇÄ := MeasureTheory.convolution (œÜ.normed MeasureTheory.volume) f (ContinuousLinearMap.lsmul ‚Ñù ‚Ñù) MeasureTheory.volume with f‚ÇÄdef
  use f‚ÇÄ
  constructor
  . /-TODO: improve this-/
    apply HasCompactSupport.contDiff_convolution_left
    . exact ContDiffBump.hasCompactSupport_normed œÜ
    . exact ContDiffBump.contDiff_normed œÜ
    . refine Continuous.locallyIntegrable ?h.left.hg.hf
      exact unicontf.continuous
  constructor
  . /-TODO: improve this. -/
    intro x
    rw [f‚ÇÄdef, MeasureTheory.convolution, MeasureTheory.convolution]
    congr
    ext t
    congr 1
    convert periodicf (x - t) using 2
    ring
  . intro x
    rw [‚Üê Complex.dist_eq, dist_comm]
    apply ContDiffBump.dist_normed_convolution_le
    . exact unicontf.continuous.aestronglyMeasurable
    . intro y hy
      simp at hy
      exact (hŒ¥ hy).le

/- Inspired by mathlib : NNReal.summable_of_le-/
lemma Real.summable_of_le {Œ≤ : Type} {f g : Œ≤ ‚Üí ‚Ñù} (hgpos : 0 ‚â§ g) (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b) (summablef : Summable f) :
    Summable g := by
  exact Summable.of_nonneg_of_le hgpos hgf summablef
  /-
  set g' : Œ≤ ‚Üí NNReal := fun b ‚Ü¶ ‚ü®g b, hgpos b‚ü© with g'def
  set f' : Œ≤ ‚Üí NNReal := fun b ‚Ü¶ ‚ü®f b, (hgpos b).trans (hgf b)‚ü© with f'def
  have hf'f: f = (fun b ‚Ü¶ (f' b : ‚Ñù)) := by norm_cast
  have hg'g: g = (fun b ‚Ü¶ (g' b : ‚Ñù)) := by norm_cast
  rw [hg'g, NNReal.summable_coe]
  have : ‚àÄ b : Œ≤, g' b ‚â§ f' b := by
    intro b
    rw [f'def, g'def, ‚ÜêNNReal.coe_le_coe]
    simp
    exact hgf b
  apply NNReal.summable_of_le this
  rwa [‚ÜêNNReal.summable_coe, ‚Üêhf'f]
  -/

-- local lemma
lemma summable_of_le_on_nonzero {f g : ‚Ñ§ ‚Üí ‚Ñù} (hgpos : 0 ‚â§ g) (hgf : ‚àÄ i ‚â† 0, g i ‚â§ f i) (summablef : Summable f) : Summable g := by
  set f' : ‚Ñ§ ‚Üí ‚Ñù := fun i ‚Ü¶ if i = 0 then g i else f i with f'def
  have : ‚àÄ i, g i ‚â§ f' i := by
    intro i
    rw [f'def]
    by_cases h : i = 0
    . simp [h]
    . simp [h]
      exact hgf i h
  apply Real.summable_of_le hgpos this

  let s : Finset ‚Ñ§ := {0}
  rw [‚Üês.summable_compl_iff]
  apply (summable_congr _).mpr (s.summable_compl_iff.mpr summablef)
  intro ‚ü®b, hb‚ü©
  simp
  rw [mem_singleton] at hb
  rw [f'def]
  simp [hb]


  lemma continuous_bounded {f : ‚Ñù ‚Üí ‚ÑÇ} (hf : ContinuousOn f (Set.Icc 0 (2 * Real.pi))) : ‚àÉ C, ‚àÄ x ‚àà Set.Icc 0 (2 * Real.pi), Complex.abs (f x) ‚â§ C := by
    have interval_compact := (@isCompact_Icc ‚Ñù _ _ _ 0 (2 * Real.pi))
    have abs_f_continuousOn := Complex.continuous_abs.comp_continuousOn hf
    obtain ‚ü®a, _, ha‚ü© := interval_compact.exists_isMaxOn (Set.nonempty_Icc.mpr Real.two_pi_pos.le) abs_f_continuousOn
    set C := Complex.abs (f a) with C_def
    use C
    intro x hx
    rw [C_def]
    rw [isMaxOn_iff] at ha
    exact ha x hx

/-TODO: might be generalized assumptions might be weakened, and constant given explicitely -/
lemma fourierCoeffOn_bound {f : ‚Ñù ‚Üí ‚ÑÇ} (f_continuous : Continuous f) : ‚àÉ C, ‚àÄ n, Complex.abs (fourierCoeffOn Real.two_pi_pos f n) ‚â§ C := by
  obtain ‚ü®C, f_bounded‚ü© := continuous_bounded f_continuous.continuousOn
  use C
  intro n
  rw [fourierCoeffOn_eq_integral]
  simp only [sub_zero, one_div, mul_inv_rev, fourier_apply, neg_smul, fourier_neg',
    fourier_coe_apply', Complex.ofReal_mul, Complex.ofReal_ofNat, smul_eq_mul, Complex.real_smul,
    Complex.ofReal_inv, map_mul, map_inv‚ÇÄ, Complex.abs_ofReal, Complex.abs_ofNat]
  field_simp
  rw [abs_of_nonneg Real.pi_pos.le, mul_comm Real.pi, div_le_iff Real.two_pi_pos, ‚ÜêComplex.norm_eq_abs]
  calc ‚Äñ‚à´ (x : ‚Ñù) in (0 : ‚Ñù)..(2 * Real.pi), (starRingEnd ‚ÑÇ) (Complex.exp (2 * Real.pi * Complex.I * n * x / (2 * Real.pi))) * f x‚Äñ
    _ = ‚Äñ‚à´ (x : ‚Ñù) in (0 : ‚Ñù)..(2 * Real.pi), (starRingEnd ‚ÑÇ) (Complex.exp (Complex.I * n * x)) * f x‚Äñ := by
      congr
      ext x
      congr
      ring_nf
      rw [mul_comm, ‚Üêmul_assoc, ‚Üêmul_assoc, ‚Üêmul_assoc, inv_mul_cancel]
      . ring
      . simp
        exact Real.pi_pos.ne.symm
    _ ‚â§ ‚à´ (x : ‚Ñù) in (0 : ‚Ñù)..(2 * Real.pi), ‚Äñ(starRingEnd ‚ÑÇ) (Complex.exp (Complex.I * n * x)) * f x‚Äñ := by
      apply intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ = ‚à´ (x : ‚Ñù) in (0 : ‚Ñù)..(2 * Real.pi), ‚Äñ(Complex.exp (Complex.I * n * x)) * f x‚Äñ := by
      simp
    _ = ‚à´ (x : ‚Ñù) in (0 : ‚Ñù)..(2 * Real.pi), ‚Äñf x‚Äñ := by
      congr
      ext x
      simp
      rw [mul_assoc, mul_comm Complex.I]
      norm_cast
      rw [Complex.abs_exp_ofReal_mul_I]
      ring
    _ ‚â§ ‚à´ (_ : ‚Ñù) in (0 : ‚Ñù)..(2 * Real.pi), C := by
      apply intervalIntegral.integral_mono_on
      . exact Real.two_pi_pos.le
      . rw [IntervalIntegrable.intervalIntegrable_norm_iff]
        /-Could specify these two specific requirements intead of f_continuous. -/
        . apply f_continuous.intervalIntegrable
        . apply f_continuous.aestronglyMeasurable
      . apply intervalIntegrable_const
      . intro x hx
        rw [Complex.norm_eq_abs]
        exact f_bounded x hx
    _ = C * (2 * Real.pi) := by
      rw [intervalIntegral.integral_const]
      simp
      ring

/-TODO: Assumptions might be weakened. -/
lemma periodic_deriv {ùïú : Type} [NontriviallyNormedField ùïú] {F : Type} [NormedAddCommGroup F] [NormedSpace ùïú F]
    {f : ùïú ‚Üí F} {T : ùïú} (diff_f : ContDiff ùïú 1 f) (periodic_f : Function.Periodic f T) : Function.Periodic (deriv f) T := by
  intro x
  set g : ùïú ‚Üí ùïú := fun x ‚Ü¶ x + T with gdef
  have diff_g : Differentiable ùïú g := by
    apply differentiable_id.add_const
  have : deriv (f ‚àò g) x = ((deriv f) ‚àò g) x := by
    calc deriv (f ‚àò g) x
      _ = deriv g x ‚Ä¢ deriv f (g x) := deriv.scomp x (diff_f.differentiable (by norm_num)).differentiableAt diff_g.differentiableAt
      _ = deriv f (g x) := by rw [gdef, deriv_add_const, deriv_id'']; simp
  rw [gdef] at this
  simp at this
  convert this.symm
  ext y
  simp
  exact (periodic_f y).symm

/-TODO: might be generalized. -/
/-TODO: Assumption periodicf is probably not needed actually. -/
lemma fourierCoeffOn_ContDiff_two_bound {f : ‚Ñù ‚Üí ‚ÑÇ} (periodicf : Function.Periodic f (2 * Real.pi)) (fdiff : ContDiff ‚Ñù 2 f): ‚àÉ C, ‚àÄ n ‚â† 0, Complex.abs (fourierCoeffOn Real.two_pi_pos f n) ‚â§ C / n ^ 2 := by
--#check IsCompact.exists_isMaxOn
  --TODO: improve this
  have h : ‚àÄ x ‚àà Set.uIcc 0 (2 * Real.pi), HasDerivAt f (deriv f x) x := by
    intro x _
    rw [hasDerivAt_deriv_iff]
    apply fdiff.differentiable (by norm_num)
  have h' : ‚àÄ x ‚àà Set.uIcc 0 (2 * Real.pi), HasDerivAt (deriv f) (deriv (deriv f) x) x := by
    intro x _
    rw [hasDerivAt_deriv_iff]
    apply (contDiff_succ_iff_deriv.mp fdiff).2.differentiable (by norm_num)
  /-Get better representation for the fourier coefficients of f. -/
  have fourierCoeffOn_eq {n : ‚Ñ§} (hn : n ‚â† 0): (fourierCoeffOn Real.two_pi_pos f n) = - 1 / (n^2) * fourierCoeffOn Real.two_pi_pos (fun x ‚Ü¶ deriv (deriv f) x) n := by
    rw [fourierCoeffOn_of_hasDerivAt Real.two_pi_pos hn h, fourierCoeffOn_of_hasDerivAt Real.two_pi_pos hn h']
    . have := periodicf 0
      simp at this
      simp [this]
      have periodic_deriv_f : Function.Periodic (deriv f) (2 * Real.pi) := periodic_deriv (fdiff.of_le one_le_two) periodicf
      have := periodic_deriv_f 0
      simp at this
      simp [this]
      ring_nf
      simp
      left
      rw [mul_inv_cancel, one_mul]
      simp
      exact Real.pi_pos.ne.symm
    . apply Continuous.intervalIntegrable
      exact (contDiff_one_iff_deriv.mp (contDiff_succ_iff_deriv.mp fdiff).2).2
    . apply Continuous.intervalIntegrable
      exact (contDiff_succ_iff_deriv.mp fdiff).2.continuous

  obtain ‚ü®C, hC‚ü© := fourierCoeffOn_bound (contDiff_one_iff_deriv.mp (contDiff_succ_iff_deriv.mp fdiff).2).2
  use C
  intro n hn
  rw [fourierCoeffOn_eq hn]
  simp only [Nat.cast_one, Int.cast_pow, map_mul, map_div‚ÇÄ, map_neg_eq_map, map_one, map_pow,
    Complex.abs_intCast, sq_abs, one_div]
  rw [div_eq_mul_inv, mul_comm]
  gcongr
  exact hC n

open Topology Filter

/-TODO : Assumptions might be weakened-/
lemma int_sum_nat {Œ≤ : Type} [AddCommGroup Œ≤] [TopologicalSpace Œ≤] [ContinuousAdd Œ≤] {f : ‚Ñ§ ‚Üí Œ≤} {a : Œ≤} (hfa : HasSum f a) :
    Filter.Tendsto (fun N ‚Ü¶ ‚àë n in Icc (-Int.ofNat ‚ÜëN) N, f n) Filter.atTop (ùìù a) := by
  have := hfa.nat_add_neg.tendsto_sum_nat
  have := (Filter.Tendsto.add_const (- (f 0))) this
  simp at this
  /-Need to start at 1 instead of zero for the base case to be true. -/
  rw [‚Üêtendsto_add_atTop_iff_nat 1] at this
  convert this using 1
  ext N
  induction' N with N ih
  . simp
  . have : Icc (- Int.ofNat (Nat.succ N)) (Nat.succ N) = insert (‚Üë(Nat.succ N)) (insert (-Int.ofNat (Nat.succ N)) (Icc (-Int.ofNat N) N)) := by
      rw [‚ÜêIco_insert_right, ‚ÜêIoo_insert_left]
      . congr
        ext n
        simp only [Int.ofNat_eq_coe, mem_Ioo, mem_Icc]
        push_cast
        rw [Int.lt_add_one_iff, neg_add, ‚Üêsub_eq_add_neg, Int.sub_one_lt_iff]
      . norm_num
        linarith
      . norm_num
        linarith
    rw [this, sum_insert, sum_insert, ih, ‚Üêadd_assoc]
    symm
    rw [sum_range_succ, add_comm, ‚Üêadd_assoc, add_comm]
    simp
    rw [add_comm]
    . simp
    . norm_num
      linarith


--theorem HasSum.nat_add_neg {f : ‚Ñ§ ‚Üí M} (hf : HasSum f m) :
--    HasSum (fun n : ‚Ñï ‚Ü¶ f n + f (-n)) (m + f 0) := by

/-TODO: Weaken statement to pointwise convergence to simplify proof?-/
lemma fourierConv_ofTwiceDifferentiable {f : ‚Ñù ‚Üí ‚ÑÇ} (periodicf : Function.Periodic f (2 * Real.pi)) (fdiff : ContDiff ‚Ñù 2 f) {Œµ : ‚Ñù} (Œµpos : Œµ > 0) :
    ‚àÉ N‚ÇÄ, ‚àÄ N > N‚ÇÄ, ‚àÄ x ‚àà Set.Ico 0 (2 * Real.pi), Complex.abs (f x - partialFourierSum f N x) ‚â§ Œµ := by
  have fact_two_pi_pos : Fact (0 < 2 * Real.pi) := by
    rw [fact_iff]
    exact Real.two_pi_pos
  set g : C(AddCircle (2 * Real.pi), ‚ÑÇ) := ‚ü®AddCircle.liftIco (2*Real.pi) 0 f, AddCircle.liftIco_continuous ((periodicf 0).symm) fdiff.continuous.continuousOn‚ü© with g_def
  have two_pi_pos' : 0 < 0 + 2 * Real.pi := by linarith [Real.two_pi_pos]
  have fourierCoeff_correspondence {i : ‚Ñ§} : fourierCoeff g i = fourierCoeffOn two_pi_pos' f i := fourierCoeff_liftIco_eq f i
  simp at fourierCoeff_correspondence
  have function_sum : HasSum (fun (i : ‚Ñ§) => fourierCoeff g i ‚Ä¢ fourier i) g := by
    apply hasSum_fourier_series_of_summable

    obtain ‚ü®C, hC‚ü© := fourierCoeffOn_ContDiff_two_bound periodicf fdiff
    set maj : ‚Ñ§ ‚Üí ‚Ñù := fun i ‚Ü¶ 1 / (i ^ 2) * C with maj_def
    have summable_maj : Summable maj := by
      by_cases Ceq0 : C = 0
      . rw [maj_def, Ceq0]
        simp
        exact summable_zero
      . rw [‚Üê summable_div_const_iff Ceq0]
        convert Real.summable_one_div_int_pow.mpr one_lt_two using 1
        rw [maj_def]
        ext i
        simp
        rw [mul_div_cancel_right‚ÇÄ]
        exact Ceq0
    rw [summable_congr @fourierCoeff_correspondence, ‚Üêsummable_norm_iff]

    apply summable_of_le_on_nonzero _ _ summable_maj
    . intro i
      simp
    . intro i ine0
      rw [maj_def, Complex.norm_eq_abs]
      field_simp
      exact hC i ine0

  have := int_sum_nat function_sum
  rw [ContinuousMap.tendsto_iff_tendstoUniformly, Metric.tendstoUniformly_iff] at this
  have := this Œµ Œµpos
  rw [Filter.eventually_atTop] at this
  obtain ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü© := this
  use N‚ÇÄ
  intro N hN x hx
  have := hN‚ÇÄ N hN.le x
  rw [Complex.dist_eq] at this
  simp only [ContinuousMap.coe_sum, sum_apply] at this
  convert this.le using 2
  congr 1
  . rw [g_def]
    simp
    rw [AddCircle.liftIco_coe_apply]
    rw [zero_add]
    exact hx
  . rw [partialFourierSum]
    congr
    ext n
    rw [fourierCoeff_correspondence]
    simp
