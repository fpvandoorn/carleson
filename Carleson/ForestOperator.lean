import Carleson.Forest
import Carleson.HardyLittlewood
import Carleson.Discrete.Forests

open ShortVariables TileStructure
variable {X : Type*} {a : â„•} {q : â„} {K : X â†’ X â†’ â„‚} {Ïƒâ‚ Ïƒâ‚‚ : X â†’ â„¤} {F G : Set X}
  [MetricSpace X] [ProofData a q K Ïƒâ‚ Ïƒâ‚‚ F G] [TileStructure Q D Îº S o]
  {n j j' : â„•} {t : Forest X n} {u uâ‚ uâ‚‚ p : ğ”“ X} {x x' : X} {ğ”– : Set (ğ”“ X)} {f fâ‚ fâ‚‚ g gâ‚ gâ‚‚ : X â†’ â„‚}
  {I J J' L : Grid X}
variable {E' : Type*} [NormedAddCommGroup E'] [NormedSpace â„ E']

noncomputable section

open Set MeasureTheory Metric Function Complex Bornology TileStructure Classical
open scoped NNReal ENNReal ComplexConjugate

namespace TileStructure.Forest

/-! ## Section 7.1 and Lemma 7.1.3 -/

variable (t) in
/-- The definition `Ïƒ(u, x)` given in Section 7.1.
We may assume `u âˆˆ t` whenever proving things about this definition. -/
def Ïƒ (u : ğ”“ X) (x : X) : Finset â„¤ := .image ğ”° { p | p âˆˆ t u âˆ§ x âˆˆ E p }

/- Maybe we should try to avoid using \overline{Ïƒ} and \underline{Ïƒ} in Lean:
I don't think the set is always non-empty(?) -/
-- def ÏƒMax (u : ğ”“ X) (x : X) : â„¤ :=
--  Finset.image ğ”° { p | p âˆˆ t u âˆ§ x âˆˆ E p } |>.max' sorry

/-- The definition of `ğ“™â‚€(ğ”–), defined above Lemma 7.1.2 -/
def ğ“™â‚€ (ğ”– : Set (ğ”“ X)) : Set (Grid X) :=
  { J : Grid X | s J = - S âˆ¨ âˆ€ p âˆˆ ğ”–, Â¬ (ğ“˜ p : Set X) âŠ† ball (c J)  (100 * D ^ (s J + 1)) }

/-- The definition of `ğ“™(ğ”–), defined above Lemma 7.1.2 -/
def ğ“™ (ğ”– : Set (ğ”“ X)) : Set (Grid X) :=
  { x | Maximal (Â· âˆˆ ğ“™â‚€ ğ”–) x}

/-- The definition of `ğ“›â‚€(ğ”–), defined above Lemma 7.1.2 -/
def ğ“›â‚€ (ğ”– : Set (ğ”“ X)) : Set (Grid X) :=
  { L : Grid X | s L = - S âˆ¨ (âˆƒ p âˆˆ ğ”–, L â‰¤ ğ“˜ p) âˆ§ âˆ€ p âˆˆ ğ”–, Â¬ ğ“˜ p â‰¤ L }

/-- The definition of `ğ“›(ğ”–), defined above Lemma 7.1.2 -/
def ğ“› (ğ”– : Set (ğ”“ X)) : Set (Grid X) :=
  { x | Maximal (Â· âˆˆ ğ“›â‚€ ğ”–) x}

/-- The projection operator `P_ğ“’ f(x)`, given above Lemma 7.1.3.
In lemmas the `c` will be pairwise disjoint on `C`. -/
def approxOnCube (C : Set (Grid X)) (f : X â†’ E') (x : X) : E' :=
  âˆ‘ J âˆˆ { p | p âˆˆ C }, (J : Set X).indicator (fun _ â†¦ â¨ y, f y) x

/-- The definition `I_i(x)`, given above Lemma 7.1.3.
The cube of scale `s` that contains `x`. There is at most 1 such cube, if it exists. -/
def cubeOf (i : â„¤) (x : X) : Grid X :=
  Classical.epsilon (fun I â†¦ x âˆˆ I âˆ§ s I = i)

/-- The definition `T_ğ“^Î¸ f(x)`, given in (7.1.3).
For convenience, the suprema are written a bit differently than in the blueprint
(avoiding `cubeOf`), but this should be equivalent.
This is `0` if `x` doesn't lie in a cube. -/
def nontangentialMaximalFunction (Î¸ : Î˜ X) (f : X â†’ â„‚) (x : X) : â„â‰¥0âˆ :=
  â¨† (I : Grid X) (_ : x âˆˆ I) (x' âˆˆ I) (sâ‚‚ âˆˆ Ioc (s I) S) (_ : D ^ (sâ‚‚ - 1) â‰¤ upperRadius Q Î¸ x'),
  â€–âˆ‘ i âˆˆ Icc (s I) sâ‚‚, âˆ« y, Ks i x' y * f yâ€–â‚Š

variable (t) in
/-- The operator `S_{1,ğ”²} f(x)`, given in (7.1.4). -/
def boundaryOperator (u : ğ”“ X) (f : X â†’ â„‚) (x : X) : â„â‰¥0âˆ :=
  âˆ‘ I : Grid X, (I : Set X).indicator (x := x) fun _ â†¦
  âˆ‘ J âˆˆ { J | J âˆˆ ğ“™ (t u) âˆ§ (J : Set X) âŠ† ball (c I) (16 * D ^ (s I)) âˆ§ s J â‰¤ s I },
  D ^ ((s J - s I) / a) / volume (ball (c I) (16 * D ^ (s I))) * âˆ«â» y in J, â€–f yâ€–â‚Š

/-- The indexing set for the collection of balls ğ“‘, defined above Lemma 7.1.3. -/
def ğ“‘ : Set (â„• Ã— Grid X) := Icc 0 (S + 5) Ã—Ë¢ univ

/-- The center function for the collection of balls ğ“‘. -/
def cğ“‘ (z : â„• Ã— Grid X) : X := c z.2

/-- The radius function for the collection of balls ğ“‘. -/
def rğ“‘ (z : â„• Ã— Grid X) : â„ := 2 ^ z.1 * D ^ s z.2

/-- Lemma 7.1.1, freely translated. -/
lemma convex_scales (hu : u âˆˆ t) : OrdConnected (t.Ïƒ u x : Set â„¤) := sorry

/-- Part of Lemma 7.1.2 -/
@[simp]
lemma biUnion_ğ“™ : â‹ƒ J âˆˆ ğ“™ ğ”–, J = â‹ƒ I : Grid X, (I : Set X) := by
  sorry

/-- Part of Lemma 7.1.2 -/
lemma pairwiseDisjoint_ğ“™ : (ğ“™ ğ”–).PairwiseDisjoint (fun I â†¦ (I : Set X)) := by
  sorry

/-- Part of Lemma 7.1.2 -/
@[simp]
lemma biUnion_ğ“› : â‹ƒ J âˆˆ ğ“› ğ”–, J = â‹ƒ I : Grid X, (I : Set X) := by
  sorry

/-- Part of Lemma 7.1.2 -/
lemma pairwiseDisjoint_ğ“› : (ğ“› ğ”–).PairwiseDisjoint (fun I â†¦ (I : Set X)) := by
  sorry

/-- The constant used in `first_tree_pointwise`.
Has value `10 * 2 ^ (105 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_1_4 (a : â„•) : â„â‰¥0 := 10 * 2 ^ (105 * (a : â„) ^ 3)

/-- Lemma 7.1.4 -/
lemma first_tree_pointwise (hu : u âˆˆ t) (hL : L âˆˆ ğ“› (t u)) (hx : x âˆˆ L) (hx' : x' âˆˆ L)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â€–âˆ‘ i in t.Ïƒ u x, âˆ« y, (exp (.I * (- ğ’¬ u y + Q x y + ğ’¬ u x - Q x x)) - 1) * Ks i x y * f y â€–â‚Š â‰¤
    C7_1_4 a * MB volume ğ“‘ cğ“‘ rğ“‘ (approxOnCube (ğ“™ (t u)) (â€–f Â·â€–)) x' := by
  sorry

/-- Lemma 7.1.5 -/
lemma second_tree_pointwise (hu : u âˆˆ t) (hL : L âˆˆ ğ“› (t u)) (hx : x âˆˆ L) (hx' : x' âˆˆ L)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â€–âˆ‘ i in t.Ïƒ u x, âˆ« y, Ks i x y * approxOnCube (ğ“™ (t u)) f yâ€–â‚Š â‰¤
    nontangentialMaximalFunction (ğ’¬ u) (approxOnCube (ğ“™ (t u)) f) x' := by
  sorry

/-- The constant used in `third_tree_pointwise`.
Has value `2 ^ (151 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_1_6 (a : â„•) : â„â‰¥0 := 2 ^ (151 * (a : â„) ^ 3)

/-- Lemma 7.1.6 -/
lemma third_tree_pointwise (hu : u âˆˆ t) (hL : L âˆˆ ğ“› (t u)) (hx : x âˆˆ L) (hx' : x' âˆˆ L)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â€–âˆ‘ i in t.Ïƒ u x, âˆ« y, Ks i x y * (f y - approxOnCube (ğ“™ (t u)) f y)â€–â‚Š â‰¤
    C7_1_6 a * t.boundaryOperator u (approxOnCube (ğ“™ (t u)) (â€–f Â·â€–)) x' := by
  sorry

/-- The constant used in `pointwise_tree_estimate`.
Has value `2 ^ (151 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_1_3 (a : â„•) : â„â‰¥0 := 2 ^ (151 * (a : â„) ^ 3)

/-- Lemma 7.1.3. -/
lemma pointwise_tree_estimate (hu : u âˆˆ t) (hL : L âˆˆ ğ“› (t u)) (hx : x âˆˆ L) (hx' : x' âˆˆ L)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â€–carlesonSum (t u) (fun y â†¦ exp (.I * - ğ’¬ u y) * f y) xâ€–â‚Š â‰¤
    C7_1_3 a * (MB volume ğ“‘ cğ“‘ rğ“‘ (approxOnCube (ğ“™ (t u)) (â€–f Â·â€–)) x' +
    t.boundaryOperator u (approxOnCube (ğ“™ (t u)) (â€–f Â·â€–)) x' +
    nontangentialMaximalFunction (ğ’¬ u) (approxOnCube (ğ“™ (t u)) f) x'):= by
  set g := approxOnCube (ğ“™ (t u)) (â€–f Â·â€–)
  sorry


/-! ## Section 7.2 and Lemma 7.2.1 -/

/-- The constant used in `nontangential_operator_bound`.
Has value `2 ^ (103 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_2_2 (a : â„•) : â„â‰¥0 := 2 ^ (103 * (a : â„) ^ 3)

/-- Lemma 7.2.2. -/
lemma nontangential_operator_bound
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) (Î¸ : Î˜ X) :
    eLpNorm (nontangentialMaximalFunction Î¸ f Â· |>.toReal) 2 volume â‰¤ eLpNorm f 2 volume := by
  sorry

/-- Lemma 7.2.4. -/
lemma boundary_overlap (I : Grid X) :
    Finset.card { J | s J = s I âˆ§ Â¬ Disjoint (ball (c I) (4 * D ^ s I)) (ball (c J) (4 * D ^ s J)) }
    â‰¤ 2 ^ (9 * a) := by
  sorry

/-- Lemma 7.2.3. -/
lemma boundary_operator_bound
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) (hu : u âˆˆ t) :
    eLpNorm (boundaryOperator t u f Â· |>.toReal) 2 volume â‰¤ eLpNorm f 2 volume := by
  sorry

/-- The constant used in `nontangential_operator_bound`.
Has value `2 ^ (104 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_2_1 (a : â„•) : â„â‰¥0 := 2 ^ (104 * (a : â„) ^ 3)

/-- Lemma 7.2.1. -/
lemma tree_projection_estimate
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f)
    (hg : IsBounded (range g)) (h2g : HasCompactSupport g) (hu : u âˆˆ t) :
    â€–âˆ« x, conj (g x) * carlesonSum (t u) f xâ€–â‚Š â‰¤
    C7_2_1 a * eLpNorm (approxOnCube (ğ“™ (t u)) (â€–f Â·â€–)) 2 volume *
    eLpNorm (approxOnCube (ğ“› (t u)) (â€–g Â·â€–)) 2 volume := by
  sorry

/-! ## Section 7.3 and Lemma 7.3.1 -/

/-- The constant used in `local_dens1_tree_bound`.
Has value `2 ^ (101 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_3_2 (a : â„•) : â„â‰¥0 := 2 ^ (101 * (a : â„) ^ 3)

/-- Lemma 7.3.2. -/
lemma local_dens1_tree_bound (hu : u âˆˆ t) (hL : L âˆˆ ğ“› (t u)) :
    volume (L âˆ© â‹ƒ (p âˆˆ t u), E p) â‰¤ C7_3_2 a * densâ‚ (t u) * volume (L : Set X) := by
  sorry

/-- The constant used in `local_dens2_tree_bound`.
Has value `2 ^ (200 * a ^ 3 + 19)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
-- feel free to modify the constant to something simpler.
def C7_3_3 (a : â„•) : â„â‰¥0 := 2 ^ (201 * (a : â„) ^ 3)

/-- Lemma 7.3.3. -/
lemma local_dens2_tree_bound (hJ : J âˆˆ ğ“™ (t u)) {q : ğ”“ X} (hq : q âˆˆ t u)
    (hJq : Â¬ Disjoint (J : Set X) (ğ“˜ q)) :
    volume (F âˆ© J) â‰¤ C7_3_3 a * densâ‚‚ (t u) * volume (J : Set X) := by
  sorry

/-- The constant used in `density_tree_bound1`.
Has value `2 ^ (155 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_3_1_1 (a : â„•) : â„â‰¥0 := 2 ^ (155 * (a : â„) ^ 3)

/-- First part of Lemma 7.3.1. -/
lemma density_tree_bound1
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f)
    (hg : IsBounded (range g)) (h2g : HasCompactSupport g) (hu : u âˆˆ t) :
    â€–âˆ« x, conj (g x) * carlesonSum (t u) f xâ€–â‚Š â‰¤
    C7_3_1_1 a *  densâ‚ (t u) ^ (2 : â„)â»Â¹ * eLpNorm f 2 volume * eLpNorm g 2 volume := by
  sorry

/-- The constant used in `density_tree_bound2`.
Has value `2 ^ (256 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_3_1_2 (a : â„•) : â„â‰¥0 := 2 ^ (256 * (a : â„) ^ 3)

/-- Second part of Lemma 7.3.1. -/
lemma density_tree_bound2
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) (h3f : âˆ€ x, â€–f xâ€– â‰¤ F.indicator 1 x)
    (hg : IsBounded (range g)) (h2g : HasCompactSupport g) (hu : u âˆˆ t) :
    â€–âˆ« x, conj (g x) * carlesonSum (t u) f xâ€–â‚Š â‰¤
    C7_3_1_2 a * densâ‚ (t u) ^ (2 : â„)â»Â¹ * densâ‚‚ (t u) ^ (2 : â„)â»Â¹ *
    eLpNorm f 2 volume * eLpNorm g 2 volume := by
  sorry

/-! ## Section 7.4 except Lemmas 4-6 -/

/-- The definition of `Tâ‚š*g(x), defined above Lemma 7.4.1 -/
def adjointCarleson (p : ğ”“ X) (f : X â†’ â„‚) (x : X) : â„‚ :=
  âˆ« y in E p, conj (Ks (ğ”° p) y x) * exp (.I * (Q y y - Q y x)) * f y

/-- The definition of `T_â„­*g(x), defined at the bottom of Section 7.4 -/
def adjointCarlesonSum (â„­ : Set (ğ”“ X)) (f : X â†’ â„‚) (x : X) : â„‚ :=
  âˆ‘ p âˆˆ {p | p âˆˆ â„­}, adjointCarleson p f x

variable (t) in
/-- The operator `S_{2,ğ”²} f(x)`, given above Lemma 7.4.3. -/
def adjointBoundaryOperator (u : ğ”“ X) (f : X â†’ â„‚) (x : X) : â„â‰¥0âˆ :=
  â€–adjointCarlesonSum (t u) f xâ€–â‚Š + MB volume ğ“‘ cğ“‘ rğ“‘ f x + â€–f xâ€–â‚Š

variable (t uâ‚ uâ‚‚) in
/-- The set `ğ”–` defined in the proof of Lemma 7.4.4.
We append a subscript 0 to distinguish it from the section variable. -/
def ğ”–â‚€ : Set (ğ”“ X) := { p âˆˆ t uâ‚ âˆª t uâ‚‚ | 2 ^ ((Z : â„) * n / 2) â‰¤ dist_(p) (ğ’¬ uâ‚) (ğ’¬ uâ‚‚) }

/-- Part 1 of Lemma 7.4.1.
Todo: update blueprint with precise properties needed on the function. -/
lemma adjoint_tile_support1 (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    adjointCarleson p f =
    (ball (ğ”  p) (5 * D ^ ğ”° p)).indicator (adjointCarleson p ((ğ“˜ p : Set X).indicator f)) := by
  sorry

/-- Part 2 of Lemma 7.4.1.
Todo: update blueprint with precise properties needed on the function. -/
lemma adjoint_tile_support2 (hu : u âˆˆ t) (hp : p âˆˆ t u)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    adjointCarleson p f =
    (ğ“˜ p : Set X).indicator (adjointCarleson p ((ğ“˜ p : Set X).indicator f)) := by
  sorry

/-- The constant used in `adjoint_tree_estimate`.
Has value `2 ^ (155 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_4_2 (a : â„•) : â„â‰¥0 := 2 ^ (155 * (a : â„) ^ 3)

/-- Lemma 7.4.2. -/
lemma adjoint_tree_estimate (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    eLpNorm (adjointCarlesonSum (t u) f) 2 volume â‰¤
    C7_4_2 a * densâ‚ (t u) ^ (2 : â„)â»Â¹ * eLpNorm f 2 volume := by
  sorry

/-- The constant used in `adjoint_tree_control`.
Has value `2 ^ (156 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_4_3 (a : â„•) : â„â‰¥0 := 2 ^ (155 * (a : â„) ^ 3)

/-- Lemma 7.4.3. -/
lemma adjoint_tree_control (hu : u âˆˆ t) (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    eLpNorm (adjointBoundaryOperator t u f Â· |>.toReal) 2 volume â‰¤
    C7_4_3 a * eLpNorm f 2 volume := by
  sorry

/-- Part 2 of Lemma 7.4.7. -/
lemma ğ”—_subset_ğ”–â‚€ (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) : t uâ‚ âŠ† ğ”–â‚€ t uâ‚ uâ‚‚ := by
  sorry

/-- Part 1 of Lemma 7.4.7. -/
lemma overlap_implies_distance (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hp : p âˆˆ t uâ‚ âˆª t uâ‚‚)
    (hpuâ‚ : Â¬ Disjoint (ğ“˜ p : Set X) (ğ“˜ uâ‚)) : p âˆˆ ğ”–â‚€ t uâ‚ uâ‚‚ := by
  sorry

/-! ## Section 7.5 -/

variable (t uâ‚ uâ‚‚) in
/-- The definition `ğ“™'` at the start of Section 7.5.1.
We use a different notation to distinguish it from the ğ“™' used in Section 7.6 -/
def ğ“™â‚… : Set (Grid X) := ğ“™ (ğ”–â‚€ t uâ‚ uâ‚‚) âˆ© Iic (ğ“˜ uâ‚)

/-- The definition of Ï‡-tilde, defined in the proof of Lemma 7.5.2 -/
def Ï‡tilde (J : Grid X) (x : X) : â„â‰¥0 :=
  8 - D ^ (- s J) * dist x (c J) |>.toNNReal

variable (t uâ‚ uâ‚‚) in
/-- The definition of Ï‡, defined in the proof of Lemma 7.5.2 -/
def Ï‡ (J : Grid X) (x : X) : â„â‰¥0 :=
  Ï‡tilde J x / âˆ‘ J' âˆˆ { I | I âˆˆ ğ“™â‚… t uâ‚ uâ‚‚ }, Ï‡tilde J' x

-- /-- The definition of `B`, defined in (7.5.1) -/
-- protected def _root_.Grid.ball (I : Grid X) : Set X := ball (c I) (8 * D ^ s I)

variable (t uâ‚ uâ‚‚) in
/-- The definition of h_J, defined in the proof of Section 7.5.2 -/
def holderFunction (fâ‚ fâ‚‚ : X â†’ â„‚)  (J : Grid X) (x : X) : â„‚ :=
  Ï‡ t uâ‚ uâ‚‚ J x * (exp (.I * ğ’¬ uâ‚ x) * adjointCarlesonSum (t uâ‚) fâ‚ x) *
  conj (exp (.I * ğ’¬ uâ‚‚ x) * adjointCarlesonSum (t uâ‚‚ âˆ© ğ”–â‚€ t uâ‚ uâ‚‚) fâ‚‚ x)

/-! ### Subsection 7.5.1 and Lemma 7.5.2 -/

/-- Part of Lemma 7.5.1. -/
lemma union_ğ“™â‚… (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) :
    â‹ƒ J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚, (J : Set X) = ğ“˜ uâ‚ := by
  sorry

/-- Part of Lemma 7.5.1. -/
lemma pairwiseDisjoint_ğ“™â‚… (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) :
    (ğ“™â‚… t uâ‚ uâ‚‚).PairwiseDisjoint (fun I â†¦ (I : Set X)) := by
  sorry

/-- Lemma 7.5.3 (stated somewhat differently). -/
lemma moderate_scale_change (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) (hJ' : J' âˆˆ ğ“™â‚… t uâ‚ uâ‚‚)
  (h : Â¬ Disjoint (J : Set X) J') : s J + 1 â‰¤ s J' := by
  sorry

/-- The constant used in `dist_Ï‡_Ï‡_le`.
Has value `2 ^ (226 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_2 (a : â„•) : â„â‰¥0 := 2 ^ (226 * (a : â„) ^ 3)

/-- Part of Lemma 7.5.2. -/
lemma sum_Ï‡ (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (x : X) :
    âˆ‘ J âˆˆ { I | I âˆˆ ğ“™â‚… t uâ‚ uâ‚‚ }, Ï‡ t uâ‚ uâ‚‚ J x = (ğ“˜ uâ‚ : Set X).indicator 1 x := by
  sorry

/-- Part of Lemma 7.5.2. -/
lemma Ï‡_mem_Icc (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) (hx : x âˆˆ ğ“˜ uâ‚) :
    Ï‡ t uâ‚ uâ‚‚ J x âˆˆ Icc 0 ((ball (c I) (8 * D ^ s I)).indicator 1 x) := by
  sorry

/-- Part of Lemma 7.5.2. -/
lemma dist_Ï‡_Ï‡_le (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) (hx : x âˆˆ ğ“˜ uâ‚) (hx' : x' âˆˆ ğ“˜ uâ‚) :
    dist (Ï‡ t uâ‚ uâ‚‚ J x) (Ï‡ t uâ‚ uâ‚‚ J x) â‰¤ C7_5_2 a * dist x x' / D ^ s J := by
  sorry


/-! ### Subsection 7.5.2 and Lemma 7.5.4 -/

/-- The constant used in `holder_correlation_tile`.
Has value `2 ^ (151 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_5 (a : â„•) : â„â‰¥0 := 2 ^ (151 * (a : â„) ^ 3)

/-- Lemma 7.5.5. -/
lemma holder_correlation_tile (hu : u âˆˆ t) (hp : p âˆˆ t u)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    nndist (exp (.I * ğ’¬ u x) * adjointCarleson p f x)
      (exp (.I * ğ’¬ u x') * adjointCarleson p f x') â‰¤
    C7_5_5 a / volume (ball (ğ”  p) (4 * D ^ ğ”° p)) *
    (nndist x x' / D ^ (ğ”° p : â„)) ^ (a : â„)â»Â¹ * âˆ«â» x in E p, â€–f xâ€–â‚Š := by
  sorry

/-- Lemma 7.5.6. -/
lemma limited_scale_impact (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hp : p âˆˆ t uâ‚‚ \ ğ”–â‚€ t uâ‚ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚)
    (h : Â¬ Disjoint (ball (ğ”  p) (8 * D ^ ğ”° p)) (ball (c J) (8â»Â¹ * D ^ s J))) :
    ğ”° p âˆˆ Icc (s J) (s J + 3) := by
  sorry

/-- The constant used in `local_tree_control`.
Has value `2 ^ (104 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_7 (a : â„•) : â„â‰¥0 := 2 ^ (104 * (a : â„) ^ 3)

/-- Lemma 7.5.7. -/
lemma local_tree_control (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â¨† x âˆˆ ball (c J) (8â»Â¹ * D ^ s J), â€–adjointCarlesonSum (t uâ‚‚ \ ğ”–â‚€ t uâ‚ uâ‚‚) f xâ€–â‚Š â‰¤
    C7_5_7 a * â¨… x âˆˆ J, MB volume ğ“‘ cğ“‘ rğ“‘ (â€–f Â·â€–) x := by
  sorry

/-- Lemma 7.5.8. -/
lemma scales_impacting_interval (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) (hp : p âˆˆ t uâ‚ âˆª (t uâ‚‚ âˆ© ğ”–â‚€ t uâ‚ uâ‚‚))
    (h : Â¬ Disjoint (ball (ğ”  p) (8 * D ^ ğ”° p)) (ball (c J) (8 * D ^ s J))) : s J â‰¤ ğ”° p := by
  sorry

/-- The constant used in `global_tree_control1_1`.
Has value `2 ^ (154 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_9_1 (a : â„•) : â„â‰¥0 := 2 ^ (154 * (a : â„) ^ 3)

/-- The constant used in `global_tree_control1_2`.
Has value `2 ^ (153 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_9_2 (a : â„•) : â„â‰¥0 := 2 ^ (153 * (a : â„) ^ 3)

/-- Part 1 of Lemma 7.5.9 -/
lemma global_tree_control1_1 (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (â„­ : Set (ğ”“ X)) (hâ„­ : â„­ = t uâ‚ âˆ¨ â„­ = t uâ‚‚ âˆ© ğ”–â‚€ t uâ‚ uâ‚‚)
    (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â¨† x âˆˆ ball (c J) (8 * D ^ s J), â€–adjointCarlesonSum â„­ f xâ€–â‚Š â‰¤
    (â¨… x âˆˆ ball (c J) (8â»Â¹ * D ^ s J), â€–adjointCarlesonSum â„­ f xâ€–â‚Š) +
    C7_5_9_1 a * â¨… x âˆˆ J, MB volume ğ“‘ cğ“‘ rğ“‘ (â€–f Â·â€–) x := by
  sorry

/-- Part 2 of Lemma 7.5.9 -/
lemma global_tree_control1_2 (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (â„­ : Set (ğ”“ X)) (hâ„­ : â„­ = t uâ‚ âˆ¨ â„­ = t uâ‚‚ âˆ© ğ”–â‚€ t uâ‚ uâ‚‚)
    (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) (hf : IsBounded (range f)) (h2f : HasCompactSupport f)
    (hx : x âˆˆ ball (c J) (8 * D ^ s J)) (hx' : x' âˆˆ ball (c J) (8 * D ^ s J)) :
    nndist (exp (.I * ğ’¬ u x) * adjointCarlesonSum â„­ f x)
      (exp (.I * ğ’¬ u x') * adjointCarlesonSum â„­ f x') â‰¤
    C7_5_9_1 a * (nndist x x' / D ^ (ğ”° p : â„)) ^ (a : â„)â»Â¹ *
    â¨… x âˆˆ J, MB volume ğ“‘ cğ“‘ rğ“‘ (â€–f Â·â€–) x := by
  sorry

/-- The constant used in `global_tree_control2`.
Has value `2 ^ (155 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_10 (a : â„•) : â„â‰¥0 := 2 ^ (155 * (a : â„) ^ 3)

/-- Lemma 7.5.10 -/
lemma global_tree_control2 (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚)
    (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    â¨† x âˆˆ ball (c J) (8 * D ^ s J), â€–adjointCarlesonSum (t uâ‚‚ âˆ© ğ”–â‚€ t uâ‚ uâ‚‚) f xâ€–â‚Š â‰¤
    â¨… x âˆˆ ball (c J) (8â»Â¹ * D ^ s J), â€–adjointCarlesonSum (t uâ‚‚) f xâ€–â‚Š +
    C7_5_10 a * â¨… x âˆˆ J, MB volume ğ“‘ cğ“‘ rğ“‘ (â€–f Â·â€–) x := by
  sorry

/-- The constant used in `holder_correlation_tree`.
Has value `2 ^ (535 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_4 (a : â„•) : â„â‰¥0 := 2 ^ (535 * (a : â„) ^ 3)

/-- Lemma 7.5.4. -/
lemma holder_correlation_tree (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    HolderOnWith (C7_5_4 a *
    ((â¨… x âˆˆ ball (c J) (8â»Â¹ * D ^ s J), â€–adjointCarlesonSum (t uâ‚) fâ‚ xâ€–â‚Š) +
    (â¨… x âˆˆ J, MB volume ğ“‘ cğ“‘ rğ“‘ (â€–fâ‚ Â·â€–) x).toNNReal) *
    ((â¨… x âˆˆ ball (c J) (8â»Â¹ * D ^ s J), â€–adjointCarlesonSum (t uâ‚‚) fâ‚‚ xâ€–â‚Š) +
    (â¨… x âˆˆ J, MB volume ğ“‘ cğ“‘ rğ“‘ (â€–fâ‚‚ Â·â€–) x).toNNReal))
    nnÏ„ (holderFunction t uâ‚ uâ‚‚ fâ‚ fâ‚‚ J) (ball (c J) (8 * D ^ s J)) := by
  sorry


/-! ### Subsection 7.5.3 and Lemma 7.4.5 -/

/-- The constant used in `lower_oscillation_bound`.
Has value `2 ^ (Z * n / 2 - 201 * a ^ 3)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_5_11 (a n : â„•) : â„â‰¥0 := 2 ^ (Z * n / 2 - 201 * (a : â„) ^ 3)

/-- Lemma 7.5.11 -/
lemma lower_oscillation_bound (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hJ : J âˆˆ ğ“™â‚… t uâ‚ uâ‚‚) :
    C7_5_11 a n â‰¤ dist_{c J, 8 * D ^ s J} (ğ’¬ uâ‚) (ğ’¬ uâ‚‚) := by
  sorry

/-- The constant used in `correlation_distant_tree_parts`.
Has value `2 ^ (541 * a ^ 3 - Z * n / (4 * a ^ 2 + 2 * a ^ 3))` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_4_5 (a n : â„•) : â„â‰¥0 := 2 ^ (541 * (a : â„) ^ 3 - Z * n / (4 * a ^ 2 + 2 * a ^ 3))

/-- Lemma 7.4.5 -/
lemma correlation_distant_tree_parts (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, adjointCarlesonSum (t uâ‚) gâ‚ x * conj (adjointCarlesonSum (t uâ‚‚ âˆ© ğ”–â‚€ t uâ‚ uâ‚‚) gâ‚‚ x)â€–â‚Š â‰¤
    C7_4_5 a n *
    eLpNorm ((ğ“˜ uâ‚ : Set X).indicator (adjointBoundaryOperator t uâ‚ gâ‚) Â· |>.toReal) 2 volume *
    eLpNorm ((ğ“˜ uâ‚ : Set X).indicator (adjointBoundaryOperator t uâ‚‚ gâ‚‚) Â· |>.toReal) 2 volume := by
  sorry

/-! ## Section 7.6 and Lemma 7.4.6 -/

variable (t uâ‚) in
/-- The definition `ğ“™'` at the start of Section 7.6.
We use a different notation to distinguish it from the ğ“™' used in Section 7.5 -/
def ğ“™â‚† : Set (Grid X) := ğ“™ (t uâ‚) âˆ© Iic (ğ“˜ uâ‚)

/-- Part of Lemma 7.6.1. -/
lemma union_ğ“™â‚† (huâ‚ : uâ‚ âˆˆ t) :
    â‹ƒ J âˆˆ ğ“™â‚† t uâ‚, (J : Set X) = ğ“˜ uâ‚ := by
  sorry

/-- Part of Lemma 7.6.1. -/
lemma pairwiseDisjoint_ğ“™â‚† (huâ‚ : uâ‚ âˆˆ t) :
    (ğ“™â‚† t uâ‚).PairwiseDisjoint (fun I â†¦ (I : Set X)) := by
  sorry

/-- The constant used in `thin_scale_impact`. This is denoted `sâ‚` in the proof of Lemma 7.6.3.
Has value `Z * n / (202 * a ^ 3) - 2` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_6_3 (a n : â„•) : â„ := Z * n / (202 * a ^ 3) - 2

-- if needed
lemma C7_6_3_pos [ProofData a q K Ïƒâ‚ Ïƒâ‚‚ F G] (h : 1 â‰¤ n) : 0 < C7_6_3 a n := by
  sorry

/-- Lemma 7.6.3. -/
lemma thin_scale_impact (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hp : p âˆˆ t uâ‚‚ \ ğ”–â‚€ t uâ‚ uâ‚‚) (hJ : J âˆˆ ğ“™â‚† t uâ‚)
    (h : Â¬ Disjoint (ball (ğ”  p) (8 * D ^ ğ”° p)) (ball (c J) (8 * D ^ s J))) :
    ğ”° p â‰¤ s J - C7_6_3 a n := by
  sorry

/-- The constant used in `square_function_count`.
Has value `Z * n / (202 * a ^ 3) - 2` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_6_4 (a : â„•) (s : â„¤) : â„â‰¥0 := 2 ^ (104 * (a : â„) ^ 2) * (8 * D ^ (- s)) ^ Îº

/-- Lemma 7.6.4. -/
lemma square_function_count (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hp : p âˆˆ t uâ‚‚ \ ğ”–â‚€ t uâ‚ uâ‚‚) (hJ : J âˆˆ ğ“™â‚† t uâ‚) (s' : â„¤ /- ? -/) :
    â¨â» x : X, (âˆ‘ I âˆˆ {I : Grid X | s I = s J - s' âˆ§ Disjoint (I : Set X) (ğ“˜ uâ‚) âˆ§
    Â¬ Disjoint (J : Set X) (ball (c I) (8 * D ^ s I)) },
    (ball (c I) (8 * D ^ s I)).indicator 1 x) ^ 2 â‰¤ C7_6_4 a s' := by
  sorry




/-- The constant used in `bound_for_tree_projection`.
Has value `2 ^ (118 * a ^ 3 - 100 / (202 * a) * Z * n * Îº)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_6_2 (a n : â„•) : â„â‰¥0 := 2 ^ (118 * (a : â„) ^ 3 - 100 / (202 * a) * Z * n * Îº)

/-- Lemma 7.6.2. Todo: add needed hypothesis to LaTeX -/
lemma bound_for_tree_projection (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚) (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    eLpNorm (approxOnCube (ğ“™â‚† t uâ‚) (â€–adjointCarlesonSum (t uâ‚‚ \ ğ”–â‚€ t uâ‚ uâ‚‚) f Â·â€–)) 2 volume â‰¤
    C7_6_2 a n *
    eLpNorm ((ğ“˜ uâ‚ : Set X).indicator (MB volume ğ“‘ cğ“‘ rğ“‘ (â€–f Â·â€–) Â· |>.toReal)) 2 volume := by
  sorry

/-- The constant used in `correlation_near_tree_parts`.
Has value `2 ^ (541 * a ^ 3 - Z * n / (4 * a ^ 2 + 2 * a ^ 3))` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_4_6 (a n : â„•) : â„â‰¥0 := 2 ^ (222 * (a : â„) ^ 3 - Z * n * 2 ^ (-10 * (a : â„)))

/-- Lemma 7.4.6 -/
lemma correlation_near_tree_parts (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚) (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, adjointCarlesonSum (t uâ‚) gâ‚ x * conj (adjointCarlesonSum (t uâ‚‚ \ ğ”–â‚€ t uâ‚ uâ‚‚) gâ‚‚ x)â€–â‚Š â‰¤
    C7_4_6 a n *
    eLpNorm ((ğ“˜ uâ‚ : Set X).indicator (adjointBoundaryOperator t uâ‚ gâ‚) Â· |>.toReal) 2 volume *
    eLpNorm ((ğ“˜ uâ‚ : Set X).indicator (adjointBoundaryOperator t uâ‚‚ gâ‚‚) Â· |>.toReal) 2 volume := by
  sorry


/-! ## Lemmas 7.4.4 -/

/-- The constant used in `correlation_separated_trees`.
Has value `2 ^ (550 * a ^ 3 - 3 * n)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_4_4 (a n : â„•) : â„â‰¥0 := 2 ^ (550 * (a : â„) ^ 3 - 3 * n)

lemma correlation_separated_trees_of_subset (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (h2u : ğ“˜ uâ‚ â‰¤ ğ“˜ uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, adjointCarlesonSum (t uâ‚) gâ‚ x * conj (adjointCarlesonSum (t uâ‚‚) gâ‚‚ x)â€–â‚Š â‰¤
    C7_4_4 a n *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚ gâ‚) Â· |>.toReal) 2 volume *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚‚ gâ‚‚) Â· |>.toReal) 2 volume := by
  sorry

/-- Lemma 7.4.4. -/
lemma correlation_separated_trees (huâ‚ : uâ‚ âˆˆ t) (huâ‚‚ : uâ‚‚ âˆˆ t) (hu : uâ‚ â‰  uâ‚‚)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, adjointCarlesonSum (t uâ‚) gâ‚ x * conj (adjointCarlesonSum (t uâ‚‚) gâ‚‚ x)â€–â‚Š â‰¤
    C7_4_4 a n *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚ gâ‚) Â· |>.toReal) 2 volume *
    eLpNorm
      ((ğ“˜ uâ‚ âˆ© ğ“˜ uâ‚‚ : Set X).indicator (adjointBoundaryOperator t uâ‚‚ gâ‚‚) Â· |>.toReal) 2 volume := by
  sorry


/-! ## Section 7.7 and Proposition 2.0.4 -/


/-- The row-decomposition of a tree, defined in the proof of Lemma 7.7.1.
The indexing is off-by-one compared to the blueprint. -/
def rowDecomp (t : Forest X n) (j : â„•) : Row X n := sorry

/-- Part of Lemma 7.7.1 -/
@[simp]
lemma biUnion_rowDecomp : â‹ƒ j < 2 ^ n, t.rowDecomp j = (t : Set (ğ”“ X)) := by
  sorry

/-- Part of Lemma 7.7.1 -/
lemma pairwiseDisjoint_rowDecomp :
    (Iio (2 ^ n)).PairwiseDisjoint (rowDecomp t Â· : â„• â†’ Set (ğ”“ X)) := by
  sorry

@[simp] lemma rowDecomp_apply : t.rowDecomp j u = t u := by
  sorry

/-- The constant used in `row_bound`.
Has value `2 ^ (156 * a ^ 3 - n / 2)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_7_2_1 (a n : â„•) : â„â‰¥0 := 2 ^ (156 * (a : â„) ^ 3 - n / 2)

/-- The constant used in `indicator_row_bound`.
Has value `2 ^ (257 * a ^ 3 - n / 2)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_7_2_2 (a n : â„•) : â„â‰¥0 := 2 ^ (257 * (a : â„) ^ 3 - n / 2)

/-- Part of Lemma 7.7.2. -/
lemma row_bound (hj : j < 2 ^ n) (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    eLpNorm (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j}, adjointCarlesonSum (t u) f) 2 volume â‰¤
    C7_7_2_1 a n * eLpNorm f 2 volume := by
  sorry

/-- Part of Lemma 7.7.2. -/
lemma indicator_row_bound (hj : j < 2 ^ n) (hf : IsBounded (range f)) (h2f : HasCompactSupport f) :
    eLpNorm (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j}, F.indicator <| adjointCarlesonSum (t u) f) 2 volume â‰¤
    C7_7_2_2 a n * densâ‚‚ (â‹ƒ u âˆˆ t, t u) ^ (2 : â„)â»Â¹ * eLpNorm f 2 volume := by
  sorry

/-- The constant used in `row_correlation`.
Has value `2 ^ (862 * a ^ 3 - 3 * n)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C7_7_3 (a n : â„•) : â„â‰¥0 := 2 ^ (862 * (a : â„) ^ 3 - 2 * n)

/-- Lemma 7.7.3. -/
lemma row_correlation (hjj' : j < j') (hj' : j' < 2 ^ n)
    (hfâ‚ : IsBounded (range fâ‚)) (h2fâ‚ : HasCompactSupport fâ‚)
    (hfâ‚‚ : IsBounded (range fâ‚‚)) (h2fâ‚‚ : HasCompactSupport fâ‚‚) :
    â€–âˆ« x, (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j}, adjointCarlesonSum (t u) fâ‚ x) *
    (âˆ‘ u âˆˆ {p | p âˆˆ rowDecomp t j'}, adjointCarlesonSum (t u) fâ‚‚ x)â€–â‚Š â‰¤
    C7_7_3 a n * eLpNorm fâ‚ 2 volume * eLpNorm fâ‚‚ 2 volume := by
  sorry

variable (t) in
/-- The definition of `E_j` defined above Lemma 7.7.4. -/
def rowSupport (j : â„•) : Set X := â‹ƒ (u âˆˆ rowDecomp t j) (p âˆˆ t u), E p

/-- Lemma 7.7.4 -/
lemma pairwiseDisjoint_rowSupport :
    (Iio (2 ^ n)).PairwiseDisjoint (rowSupport t) := by
  sorry

end TileStructure.Forest

/-- The constant used in `forest_operator`.
Has value `2 ^ (432 * a ^ 3 - (q - 1) / q * n)` in the blueprint. -/
-- Todo: define this recursively in terms of previous constants
def C2_0_4 (a q : â„) (n : â„•) : â„â‰¥0 := 2 ^ (432 * a ^ 3 - (q - 1) / q * n)

theorem forest_operator {n : â„•} (ğ”‰ : Forest X n) {f g : X â†’ â„‚}
    (hf : Measurable f) (h2f : âˆ€ x, â€–f xâ€– â‰¤ F.indicator 1 x) (hg : Measurable g)
    (h2g : IsBounded (support g)) :
    â€–âˆ« x, conj (g x) * âˆ‘ u âˆˆ { p | p âˆˆ ğ”‰ }, carlesonSum (ğ”‰ u) f xâ€–â‚Š â‰¤
    C2_0_4 a q n * (densâ‚‚ (X := X) (â‹ƒ u âˆˆ ğ”‰, ğ”‰ u)) ^ (qâ»Â¹ - 2â»Â¹) *
    eLpNorm f 2 volume * eLpNorm g 2 volume := by
  sorry
